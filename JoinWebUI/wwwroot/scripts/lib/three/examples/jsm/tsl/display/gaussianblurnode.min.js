/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/tsl/display/GaussianBlurNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{RenderTarget,Vector2,PostProcessingUtils}from"three";import{TempNode,nodeObject,Fn,If,float,NodeUpdateType,uv,uniform,convertToTexture,vec2,vec4,QuadMesh,passTexture,mul,NodeMaterial}from"three/tsl";const _quadMesh1=new QuadMesh,_quadMesh2=new QuadMesh;let _rendererState;const premult=Fn((([e])=>vec4(e.rgb.mul(e.a),e.a))).setLayout({name:"premult",type:"vec4",inputs:[{name:"color",type:"vec4"}]}),unpremult=Fn((([e])=>(If(e.a.equal(0),(()=>vec4(0))),vec4(e.rgb.div(e.a),e.a)))).setLayout({name:"unpremult",type:"vec4",inputs:[{name:"color",type:"vec4"}]});class GaussianBlurNode extends TempNode{static get type(){return"GaussianBlurNode"}constructor(e,t=null,r=2){super("vec4"),this.textureNode=e,this.directionNode=t,this.sigma=r,this._invSize=uniform(new Vector2),this._passDirection=uniform(new Vector2),this._horizontalRT=new RenderTarget(1,1,{depthBuffer:!1}),this._horizontalRT.texture.name="GaussianBlurNode.horizontal",this._verticalRT=new RenderTarget(1,1,{depthBuffer:!1}),this._verticalRT.texture.name="GaussianBlurNode.vertical",this._textureNode=passTexture(this,this._verticalRT.texture),this._textureNode.uvNode=e.uvNode,this.updateBeforeType=NodeUpdateType.FRAME,this.resolution=new Vector2(1,1),this.premultipliedAlpha=!1}setPremultipliedAlpha(e){return this.premultipliedAlpha=e,this}getPremultipliedAlpha(){return this.premultipliedAlpha}setSize(e,t){e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._invSize.value.set(1/e,1/t),this._horizontalRT.setSize(e,t),this._verticalRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e;_rendererState=PostProcessingUtils.resetRendererState(t,_rendererState);const r=this.textureNode,s=r.value,i=r.value;_quadMesh1.material=this._material,_quadMesh2.material=this._material,this.setSize(s.image.width,s.image.height);const a=s.type;this._horizontalRT.texture.type=a,this._verticalRT.texture.type=a,t.setRenderTarget(this._horizontalRT),this._passDirection.value.set(1,0),_quadMesh1.render(t),r.value=this._horizontalRT.texture,t.setRenderTarget(this._verticalRT),this._passDirection.value.set(0,1),_quadMesh2.render(t),r.value=i,PostProcessingUtils.restoreRendererState(t,_rendererState)}getTextureNode(){return this._textureNode}setup(e){const t=this.textureNode,r=t.uvNode||uv(),s=vec2(this.directionNode||1);let i,a;this.premultipliedAlpha?(i=e=>premult(t.uv(e)),a=e=>unpremult(e)):(i=e=>t.uv(e),a=e=>e);const o=Fn((()=>{const e=3+2*this.sigma,t=this._getCoefficients(e),o=this._invSize,u=s.mul(this._passDirection),n=float(t[0]).toVar(),l=vec4(i(r).mul(n)).toVar();for(let s=1;s<e;s++){const e=float(s),a=float(t[s]),d=vec2(u.mul(o.mul(e))).toVar(),h=i(r.add(d)),p=i(r.sub(d));l.addAssign(h.add(p).mul(a)),n.addAssign(mul(2,a))}return a(l.div(n))})),u=this._material||(this._material=new NodeMaterial);u.fragmentNode=o().context(e.getSharedContext()),u.name="Gaussian_blur",u.needsUpdate=!0;return e.getNodeProperties(this).textureNode=t,this._textureNode}dispose(){this._horizontalRT.dispose(),this._verticalRT.dispose()}_getCoefficients(e){const t=[];for(let r=0;r<e;r++)t.push(.39894*Math.exp(-.5*r*r/(e*e))/e);return t}}export default GaussianBlurNode;export const gaussianBlur=(e,t,r)=>nodeObject(new GaussianBlurNode(convertToTexture(e),t,r));export const premultipliedGaussianBlur=(e,t,r)=>nodeObject(new GaussianBlurNode(convertToTexture(e),t,r).setPremultipliedAlpha(!0));
//# sourceMappingURL=/sm/7ea1bcfa87379a75a42af6549569fc7b901aea532097214b134f313d43599be2.map