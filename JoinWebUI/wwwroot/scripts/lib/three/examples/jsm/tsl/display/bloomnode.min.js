/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/tsl/display/BloomNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{HalfFloatType,RenderTarget,Vector2,Vector3,PostProcessingUtils}from"three";import{TempNode,nodeObject,Fn,float,NodeUpdateType,uv,passTexture,uniform,QuadMesh,NodeMaterial,Loop,texture,luminance,smoothstep,mix,vec4,uniformArray,add,int}from"three/tsl";const _quadMesh=new QuadMesh,_size=new Vector2,_BlurDirectionX=new Vector2(1,0),_BlurDirectionY=new Vector2(0,1);let _rendererState;class BloomNode extends TempNode{static get type(){return"BloomNode"}constructor(e,t=1,r=0,s=0){super(),this.inputNode=e,this.strength=uniform(t),this.radius=uniform(r),this.threshold=uniform(s),this.smoothWidth=uniform(.01),this._renderTargetsHorizontal=[],this._renderTargetsVertical=[],this._nMips=5,this._renderTargetBright=new RenderTarget(1,1,{depthBuffer:!1,type:HalfFloatType}),this._renderTargetBright.texture.name="UnrealBloomPass.bright",this._renderTargetBright.texture.generateMipmaps=!1;for(let e=0;e<this._nMips;e++){const t=new RenderTarget(1,1,{depthBuffer:!1,type:HalfFloatType});t.texture.name="UnrealBloomPass.h"+e,t.texture.generateMipmaps=!1,this._renderTargetsHorizontal.push(t);const r=new RenderTarget(1,1,{depthBuffer:!1,type:HalfFloatType});r.texture.name="UnrealBloomPass.v"+e,r.texture.generateMipmaps=!1,this._renderTargetsVertical.push(r)}this._compositeMaterial=null,this._highPassFilterMaterial=null,this._separableBlurMaterials=[],this._textureNodeBright=texture(this._renderTargetBright.texture),this._textureNodeBlur0=texture(this._renderTargetsVertical[0].texture),this._textureNodeBlur1=texture(this._renderTargetsVertical[1].texture),this._textureNodeBlur2=texture(this._renderTargetsVertical[2].texture),this._textureNodeBlur3=texture(this._renderTargetsVertical[3].texture),this._textureNodeBlur4=texture(this._renderTargetsVertical[4].texture),this._textureOutput=passTexture(this,this._renderTargetsHorizontal[0].texture),this.updateBeforeType=NodeUpdateType.FRAME}getTextureNode(){return this._textureOutput}setSize(e,t){let r=Math.round(e/2),s=Math.round(t/2);this._renderTargetBright.setSize(r,s);for(let e=0;e<this._nMips;e++)this._renderTargetsHorizontal[e].setSize(r,s),this._renderTargetsVertical[e].setSize(r,s),this._separableBlurMaterials[e].invSize.value.set(1/r,1/s),r=Math.round(r/2),s=Math.round(s/2)}updateBefore(e){const{renderer:t}=e;_rendererState=PostProcessingUtils.resetRendererState(t,_rendererState);const r=t.getDrawingBufferSize(_size);this.setSize(r.width,r.height),t.setRenderTarget(this._renderTargetBright),_quadMesh.material=this._highPassFilterMaterial,_quadMesh.render(t);let s=this._renderTargetBright;for(let e=0;e<this._nMips;e++)_quadMesh.material=this._separableBlurMaterials[e],this._separableBlurMaterials[e].colorTexture.value=s.texture,this._separableBlurMaterials[e].direction.value=_BlurDirectionX,t.setRenderTarget(this._renderTargetsHorizontal[e]),_quadMesh.render(t),this._separableBlurMaterials[e].colorTexture.value=this._renderTargetsHorizontal[e].texture,this._separableBlurMaterials[e].direction.value=_BlurDirectionY,t.setRenderTarget(this._renderTargetsVertical[e]),_quadMesh.render(t),s=this._renderTargetsVertical[e];t.setRenderTarget(this._renderTargetsHorizontal[0]),_quadMesh.material=this._compositeMaterial,_quadMesh.render(t),PostProcessingUtils.restoreRendererState(t,_rendererState)}setup(e){const t=Fn((()=>{const e=this.inputNode,t=luminance(e.rgb),r=smoothstep(this.threshold,this.threshold.add(this.smoothWidth),t);return mix(vec4(0),e,r)}));this._highPassFilterMaterial=this._highPassFilterMaterial||new NodeMaterial,this._highPassFilterMaterial.fragmentNode=t().context(e.getSharedContext()),this._highPassFilterMaterial.name="Bloom_highPass",this._highPassFilterMaterial.needsUpdate=!0;const r=[3,5,7,9,11];for(let t=0;t<this._nMips;t++)this._separableBlurMaterials.push(this._getSeperableBlurMaterial(e,r[t]));const s=uniformArray([1,.8,.6,.4,.2]),i=uniformArray([new Vector3(1,1,1),new Vector3(1,1,1),new Vector3(1,1,1),new Vector3(1,1,1),new Vector3(1,1,1)]),a=Fn((([e,t])=>{const r=float(1.2).sub(e);return mix(e,r,t)})).setLayout({name:"lerpBloomFactor",type:"float",inputs:[{name:"factor",type:"float"},{name:"radius",type:"float"}]}),o=Fn((()=>{const e=a(s.element(0),this.radius).mul(vec4(i.element(0),1)).mul(this._textureNodeBlur0),t=a(s.element(1),this.radius).mul(vec4(i.element(1),1)).mul(this._textureNodeBlur1),r=a(s.element(2),this.radius).mul(vec4(i.element(2),1)).mul(this._textureNodeBlur2),o=a(s.element(3),this.radius).mul(vec4(i.element(3),1)).mul(this._textureNodeBlur3),n=a(s.element(4),this.radius).mul(vec4(i.element(4),1)).mul(this._textureNodeBlur4);return e.add(t).add(r).add(o).add(n).mul(this.strength)}));return this._compositeMaterial=this._compositeMaterial||new NodeMaterial,this._compositeMaterial.fragmentNode=o().context(e.getSharedContext()),this._compositeMaterial.name="Bloom_comp",this._compositeMaterial.needsUpdate=!0,this._textureOutput}dispose(){for(let e=0;e<this._renderTargetsHorizontal.length;e++)this._renderTargetsHorizontal[e].dispose();for(let e=0;e<this._renderTargetsVertical.length;e++)this._renderTargetsVertical[e].dispose();this._renderTargetBright.dispose()}_getSeperableBlurMaterial(e,t){const r=[];for(let e=0;e<t;e++)r.push(.39894*Math.exp(-.5*e*e/(t*t))/t);const s=texture(),i=uniformArray(r),a=uniform(new Vector2),o=uniform(new Vector2(.5,.5)),n=uv(),l=e=>s.uv(e),h=Fn((()=>{const e=i.element(0).toVar(),r=l(n).rgb.mul(e).toVar();return Loop({start:int(1),end:int(t),type:"int",condition:"<"},(({i:t})=>{const s=float(t),h=i.element(t),u=o.mul(a).mul(s),d=l(n.add(u)).rgb,_=l(n.sub(u)).rgb;r.addAssign(add(d,_).mul(h)),e.addAssign(float(2).mul(h))})),vec4(r.div(e),1)})),u=new NodeMaterial;return u.fragmentNode=h().context(e.getSharedContext()),u.name="Bloom_seperable",u.needsUpdate=!0,u.colorTexture=s,u.direction=o,u.invSize=a,u}}export const bloom=(e,t,r,s)=>nodeObject(new BloomNode(nodeObject(e),t,r,s));export default BloomNode;
//# sourceMappingURL=/sm/f5735162ebc676139572aa745c814944fc1a2dd577881098dfd6193593f4ccb1.map