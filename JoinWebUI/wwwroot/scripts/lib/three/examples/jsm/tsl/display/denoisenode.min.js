/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/tsl/display/DenoiseNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Vector2,Vector3}from"three";import{getNormalFromDepth,getViewPosition,convertToTexture,TempNode,nodeObject,Fn,float,NodeUpdateType,uv,uniform,Loop,luminance,vec2,vec3,vec4,uniformArray,int,dot,max,pow,abs,If,textureSize,sin,cos,mat2,PI}from"three/tsl";class DenoiseNode extends TempNode{static get type(){return"DenoiseNode"}constructor(e,t,o,i,r){super(),this.textureNode=e,this.depthNode=t,this.normalNode=o,this.noiseNode=i,this.cameraProjectionMatrixInverse=uniform(r.projectionMatrixInverse),this.lumaPhi=uniform(5),this.depthPhi=uniform(5),this.normalPhi=uniform(5),this.radius=uniform(5),this.index=uniform(0),this._resolution=uniform(new Vector2),this._sampleVectors=uniformArray(generatePdSamplePointInitializer(16,2,1)),this.updateBeforeType=NodeUpdateType.FRAME}updateBefore(){const e=this.textureNode.value;this._resolution.value.set(e.image.width,e.image.height)}setup(){const e=uv(),t=e=>this.textureNode.uv(e),o=e=>this.depthNode.uv(e).x,i=e=>null!==this.normalNode?this.normalNode.uv(e).rgb.normalize():getNormalFromDepth(e,this.depthNode.value,this.cameraProjectionMatrixInverse),r=e=>this.noiseNode.uv(e),n=Fn((([e,r,n,a])=>{const s=t(a).toVar(),u=o(a).toVar(),d=i(a).toVar(),m=s.rgb,h=getViewPosition(a,u,this.cameraProjectionMatrixInverse).toVar(),c=dot(r,d).toVar(),l=pow(max(c,0),this.normalPhi).toVar(),p=abs(luminance(m).sub(luminance(e))).toVar(),v=max(float(1).sub(p.div(this.lumaPhi)),0).toVar(),V=abs(dot(n.sub(h),r)).toVar(),f=max(float(1).sub(V.div(this.depthPhi)),0),x=v.mul(f).mul(l);return vec4(m.mul(x),x)})),a=Fn((([e])=>{const a=o(e).toVar(),s=i(e).toVar(),u=t(e).toVar();If(a.greaterThanEqual(1).or(dot(s,s).equal(0)),(()=>u));const d=vec3(u.rgb).toVar(),m=getViewPosition(e,a,this.cameraProjectionMatrixInverse).toVar(),h=textureSize(this.noiseNode,0);let c=vec2(e.x,e.y.oneMinus());c=c.mul(this._resolution.div(h));const l=r(c).toVar(),p=sin(l.element(this.index.mod(4).mul(2).mul(PI))).toVar(),v=cos(l.element(this.index.mod(4).mul(2).mul(PI))).toVar(),V=vec2(p,v).toVar(),f=mat2(V.x,V.y.negate(),V.x,V.y).toVar(),x=float(1).toVar(),g=vec3(u.rgb).toVar();return Loop({start:int(0),end:int(16),type:"int",condition:"<"},(({i:t})=>{const o=this._sampleVectors.element(t).toVar(),i=f.mul(o.xy.mul(float(1).add(o.z.mul(this.radius.sub(1))))).div(this._resolution).toVar(),r=e.add(i).toVar(),a=n(d,s,m,r);g.addAssign(a.xyz),x.addAssign(a.w)})),If(x.greaterThan(float(0)),(()=>{g.divAssign(x)})),vec4(g,u.a)})).setLayout({name:"denoise",type:"vec4",inputs:[{name:"uv",type:"vec2"}]});return Fn((()=>a(e)))()}}export default DenoiseNode;function generatePdSamplePointInitializer(e,t,o){const i=generateDenoiseSamples(e,t,o),r=[];for(let t=0;t<e;t++){const e=i[t];r.push(e)}return r}function generateDenoiseSamples(e,t,o){const i=[];for(let r=0;r<e;r++){const n=2*Math.PI*t*r/e,a=Math.pow(r/(e-1),o);i.push(new Vector3(Math.cos(n),Math.sin(n),a))}return i}export const denoise=(e,t,o,i,r)=>nodeObject(new DenoiseNode(convertToTexture(e),nodeObject(t),nodeObject(o),nodeObject(i),r));
//# sourceMappingURL=/sm/210ab55ad32a0206dbe95c0d5a2c5fa4689b12cea5ac818e43ae55ca75af3307.map