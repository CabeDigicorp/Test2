/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/tsl/display/SSAAPassNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{AdditiveBlending,Color,Vector2,PostProcessingUtils}from"three";import{nodeObject,uniform,mrt,PassNode,QuadMesh,texture,NodeMaterial,getTextureIndex}from"three/tsl";const _size=new Vector2;let _rendererState;class SSAAPassNode extends PassNode{static get type(){return"SSAAPassNode"}constructor(e,t){super(PassNode.COLOR,e,t),this.isSSAAPassNode=!0,this.sampleLevel=4,this.unbiased=!0,this.clearColor=new Color(0),this.clearAlpha=0,this.sampleWeight=uniform(1),this.sampleRenderTarget=null,this._quadMesh=new QuadMesh}updateBefore(e){const{renderer:t}=e,{scene:s,camera:r}=this;_rendererState=PostProcessingUtils.resetRendererAndSceneState(t,s,_rendererState),this._pixelRatio=t.getPixelRatio();const a=t.getSize(_size);this.setSize(a.width,a.height),this.sampleRenderTarget.setSize(this.renderTarget.width,this.renderTarget.height),this._cameraNear.value=r.near,this._cameraFar.value=r.far,t.setMRT(this.getMRT()),t.autoClear=!1;const i=_JitterVectors[Math.max(0,Math.min(this.sampleLevel,5))],h=1/i.length,l={fullWidth:this.renderTarget.width,fullHeight:this.renderTarget.height,offsetX:0,offsetY:0,width:this.renderTarget.width,height:this.renderTarget.height},d=Object.assign({},r.view);d.enabled&&Object.assign(l,d);for(let e=0;e<i.length;e++){const a=i[e];if(r.setViewOffset&&r.setViewOffset(l.fullWidth,l.fullHeight,l.offsetX+.0625*a[0],l.offsetY+.0625*a[1],l.width,l.height),this.sampleWeight.value=h,this.unbiased){const t=(e+.5)/i.length-.5;this.sampleWeight.value+=.03125*t}t.setClearColor(this.clearColor,this.clearAlpha),t.setRenderTarget(this.sampleRenderTarget),t.clear(),t.render(s,r),t.setRenderTarget(this.renderTarget),0===e&&(t.setClearColor(0,0),t.clear()),this._quadMesh.render(t)}t.copyTextureToTexture(this.sampleRenderTarget.depthTexture,this.renderTarget.depthTexture),r.setViewOffset&&d.enabled?r.setViewOffset(d.fullWidth,d.fullHeight,d.offsetX,d.offsetY,d.width,d.height):r.clearViewOffset&&r.clearViewOffset(),PostProcessingUtils.restoreRendererAndSceneState(t,s,_rendererState)}setup(e){let t;null===this.sampleRenderTarget&&(this.sampleRenderTarget=this.renderTarget.clone());const s=this.getMRT();if(null!==s){const e={};for(const t in s.outputNodes){const s=getTextureIndex(this.sampleRenderTarget.textures,t);s>=0&&(e[t]=texture(this.sampleRenderTarget.textures[s]).mul(this.sampleWeight))}t=mrt(e)}else t=texture(this.sampleRenderTarget.texture).mul(this.sampleWeight);return this._quadMesh.material=new NodeMaterial,this._quadMesh.material.fragmentNode=t,this._quadMesh.material.transparent=!0,this._quadMesh.material.depthTest=!1,this._quadMesh.material.depthWrite=!1,this._quadMesh.material.premultipliedAlpha=!0,this._quadMesh.material.blending=AdditiveBlending,this._quadMesh.material.name="SSAA",super.setup(e)}dispose(){super.dispose(),null!==this.sampleRenderTarget&&this.sampleRenderTarget.dispose()}}export default SSAAPassNode;const _JitterVectors=[[[0,0]],[[4,4],[-4,-4]],[[-2,-6],[6,-2],[-6,2],[2,6]],[[1,-3],[-1,3],[5,1],[-3,-5],[-5,5],[-7,-1],[3,7],[7,-7]],[[1,1],[-1,-3],[-3,2],[4,-1],[-5,-2],[2,5],[5,3],[3,-5],[-2,6],[0,-7],[-4,-6],[-6,4],[-8,0],[7,-4],[6,7],[-7,-8]],[[-4,-7],[-7,-5],[-3,-5],[-5,-4],[-1,-4],[-2,-2],[-6,-1],[-4,0],[-7,1],[-1,2],[-6,3],[-3,3],[-7,6],[-3,6],[-5,7],[-1,7],[5,-7],[1,-6],[6,-5],[4,-4],[2,-3],[7,-2],[1,-1],[4,-1],[2,1],[6,2],[0,4],[4,4],[2,5],[7,5],[5,6],[3,7]]];export const ssaaPass=(e,t)=>nodeObject(new SSAAPassNode(e,t));
//# sourceMappingURL=/sm/28bce4e57fc74d54d39cecf1cd0a21278bfe127986781dc0cc13fa636c081a57.map