/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/tsl/display/SSRNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{NearestFilter,RenderTarget,Vector2,PostProcessingUtils}from"three";import{getScreenPosition,getViewPosition,sqrt,mul,div,cross,float,Continue,Break,Loop,int,max,abs,sub,If,dot,reflect,normalize,screenCoordinate,QuadMesh,TempNode,nodeObject,Fn,NodeUpdateType,passTexture,NodeMaterial,uv,uniform,perspectiveDepthToViewZ,orthographicDepthToViewZ,vec2,vec3,vec4}from"three/tsl";const _quadMesh=new QuadMesh,_size=new Vector2;let _rendererState;class SSRNode extends TempNode{static get type(){return"SSRNode"}constructor(e,t,r,a,s){super(),this.colorNode=e,this.depthNode=t,this.normalNode=r,this.metalnessNode=a,this.camera=s,this.resolutionScale=.5,this.updateBeforeType=NodeUpdateType.FRAME,this._ssrRenderTarget=new RenderTarget(1,1,{depthBuffer:!1,minFilter:NearestFilter,magFilter:NearestFilter}),this._ssrRenderTarget.texture.name="SSRNode.SSR",this.maxDistance=uniform(1),this.thickness=uniform(.1),this.opacity=uniform(1),this._cameraNear=uniform(s.near),this._cameraFar=uniform(s.far),this._cameraProjectionMatrix=uniform(s.projectionMatrix),this._cameraProjectionMatrixInverse=uniform(s.projectionMatrixInverse),this._isPerspectiveCamera=uniform(s.isPerspectiveCamera?1:0),this._resolution=uniform(new Vector2),this._maxStep=uniform(0),this._material=new NodeMaterial,this._material.name="SSRNode.SSR",this._textureNode=passTexture(this,this._ssrRenderTarget.texture)}getTextureNode(){return this._textureNode}setSize(e,t){e=Math.round(this.resolutionScale*e),t=Math.round(this.resolutionScale*t),this._resolution.value.set(e,t),this._maxStep.value=Math.round(Math.sqrt(e*e+t*t)),this._ssrRenderTarget.setSize(e,t)}updateBefore(e){const{renderer:t}=e;_rendererState=PostProcessingUtils.resetRendererState(t,_rendererState);const r=t.getDrawingBufferSize(_size);_quadMesh.material=this._material,this.setSize(r.width,r.height),t.setMRT(null),t.setClearColor(0,0),t.setRenderTarget(this._ssrRenderTarget),_quadMesh.render(t),PostProcessingUtils.restoreRendererState(t,_rendererState)}setup(e){const t=uv(),r=Fn((([e,t,r])=>cross(e.sub(t),e.sub(r)).length().div(r.sub(t).length()))),a=Fn((([e,t,r])=>{const a=mul(r.x,t.x).add(mul(r.y,t.y)).add(mul(r.z,t.z)).negate().toVar(),s=sqrt(mul(r.x,r.x).add(mul(r.y,r.y)).add(mul(r.z,r.z))).toVar();return div(mul(r.x,e.x).add(mul(r.y,e.y)).add(mul(r.z,e.z)).add(a),s)})),s=Fn((([e])=>{let t;return t=this.camera.isPerspectiveCamera?perspectiveDepthToViewZ(e,this._cameraNear,this._cameraFar):orthographicDepthToViewZ(e,this._cameraNear,this._cameraFar),t})),o=Fn((()=>{const e=this.metalnessNode.uv(t).r;e.equal(0).discard();const o=this.depthNode.uv(t).r.toVar(),i=getViewPosition(t,o,this._cameraProjectionMatrixInverse).toVar(),n=this.normalNode.rgb.normalize().toVar(),d=(this.camera.isPerspectiveCamera?normalize(i):vec3(0,0,-1)).toVar(),h=reflect(d,n).toVar(),u=this.maxDistance.div(dot(d.negate(),n)).toVar(),c=i.add(h.mul(u)).toVar();If(this._isPerspectiveCamera.equal(float(1)).and(c.z.greaterThan(this._cameraNear.negate())),(()=>{const e=sub(this._cameraNear.negate(),i.z).div(h.z);c.assign(i.add(h.mul(e)))}));const l=screenCoordinate.xy.toVar(),m=getScreenPosition(c,this._cameraProjectionMatrix).mul(this._resolution).toVar(),g=m.sub(l).length().toVar(),p=m.x.sub(l.x).toVar(),_=m.y.sub(l.y).toVar(),x=max(abs(p),abs(_)).toVar(),v=p.div(x).toVar(),f=_.div(x).toVar(),V=vec4(0).toVar();return Loop({start:int(0),end:int(this._maxStep),type:"int",condition:"<"},(({i:t})=>{If(float(t).greaterThanEqual(x),(()=>{Break()}));const o=vec2(l.x.add(v.mul(float(t))),l.y.add(f.mul(float(t)))).toVar();If(o.x.lessThan(0).or(o.x.greaterThan(this._resolution.x)).or(o.y.lessThan(0)).or(o.y.greaterThan(this._resolution.y)),(()=>{Break()}));const u=o.div(this._resolution),m=this.depthNode.uv(u).r.toVar(),p=s(m).toVar(),_=getViewPosition(u,m,this._cameraProjectionMatrixInverse).toVar(),N=float(0).toVar(),S=o.sub(l).length().div(g);If(this._isPerspectiveCamera.equal(float(1)),(()=>{const e=float(1).div(i.z).toVar();N.assign(float(1).div(e.add(S.mul(float(1).div(c.z).sub(e)))))})).Else((()=>{N.assign(i.z.add(S.mul(c.z.sub(i.z))))})),If(N.lessThanEqual(p),(()=>{const t=r(_,i,c).toVar(),s=vec2(o.x.add(1),o.y).toVar().div(this._resolution),l=getViewPosition(s,m,this._cameraProjectionMatrixInverse).toVar().x.sub(_.x).toVar();l.mulAssign(3);const g=max(l,this.thickness).toVar();If(t.lessThanEqual(g),(()=>{const t=this.normalNode.uv(u).rgb.normalize().toVar();If(dot(h,t).greaterThanEqual(0),(()=>{Continue()}));const r=a(_,i,n).toVar();If(r.greaterThan(this.maxDistance),(()=>{Break()}));const s=this.opacity.mul(e).toVar(),o=float(1).sub(r.div(this.maxDistance)).toVar(),c=o.mul(o);s.mulAssign(c);const l=div(dot(d,h).add(1),2);s.mulAssign(l);const m=this.colorNode.uv(u);V.assign(vec4(m.rgb,s)),Break()}))}))})),V}));return this._material.fragmentNode=o().context(e.getSharedContext()),this._material.needsUpdate=!0,this._textureNode}dispose(){this._ssrRenderTarget.dispose(),this._material.dispose()}}export default SSRNode;export const ssr=(e,t,r,a,s)=>nodeObject(new SSRNode(nodeObject(e),nodeObject(t),nodeObject(r),nodeObject(a),s));
//# sourceMappingURL=/sm/f3bbd2e1e6738bf88406bebcf8e4280d265226c4c3f00dae6e3ad1e72462f43b.map