/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/tsl/lighting/TiledLightsNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{storageObject,nodeProxy,int,float,vec2,ivec2,ivec4,uniform,Break,Loop,Fn,If,Return,textureLoad,instanceIndex,screenCoordinate,directPointLight}from"three/tsl";import{DataTexture,FloatType,LightsNode,NodeUpdateType,RGBAFormat,StorageBufferAttribute,Vector2,Vector3}from"three";export const circleIntersectsAABB=Fn((([t,e,i,s])=>{const n=i.x.max(t.x.min(s.x)),r=i.y.max(t.y.min(s.y)),o=t.x.sub(n),a=t.y.sub(r);return o.mul(o).add(a.mul(a)).lessThanEqual(e.mul(e))})).setLayout({name:"circleIntersectsAABB",type:"bool",inputs:[{name:"circleCenter",type:"vec2"},{name:"radius",type:"float"},{name:"minBounds",type:"vec2"},{name:"maxBounds",type:"vec2"}]});const _vector3=new Vector3,_size=new Vector2;class TiledLightsNode extends LightsNode{static get type(){return"TiledLightsNode"}constructor(t=1024,e=32){super(),this.materialLights=[],this.tiledLights=[],this.maxLights=t,this.tileSize=e,this.bufferSize=null,this.lightIndexes=null,this.screenTileIndex=null,this.compute=null,this.lightsTexture=null,this.lightsCount=uniform(0,"int"),this.tileLightCount=8,this.screenSize=uniform(new Vector2),this.cameraProjectionMatrix=uniform("mat4"),this.cameraViewMatrix=uniform("mat4"),this.updateBeforeType=NodeUpdateType.RENDER}updateLightsTexture(){const{lightsTexture:t,tiledLights:e}=this,i=t.image.data,s=4*t.image.width;this.lightsCount.value=e.length;for(let t=0;t<e.length;t++){const n=e[t];_vector3.setFromMatrixPosition(n.matrixWorld);const r=4*t;i[r+0]=_vector3.x,i[r+1]=_vector3.y,i[r+2]=_vector3.z,i[r+3]=n.distance,i[s+r+0]=n.color.r*n.intensity,i[s+r+1]=n.color.g*n.intensity,i[s+r+2]=n.color.b*n.intensity,i[s+r+3]=n.decay}t.needsUpdate=!0}updateBefore(t){const{renderer:e,camera:i}=t;this.updateProgram(e),this.updateLightsTexture(i),this.cameraProjectionMatrix.value=i.projectionMatrix,this.cameraViewMatrix.value=i.matrixWorldInverse,e.getDrawingBufferSize(_size),this.screenSize.value.copy(_size),e.compute(this.compute)}setLights(t){const{tiledLights:e,materialLights:i}=this;let s=0,n=0;for(const r of t)!0===r.isPointLight?e[n++]=r:i[s++]=r;return i.length=s,e.length=n,super.setLights(i)}getBlock(t=0){return this.lightIndexes.element(this.screenTileIndex.mul(int(2).add(int(t))))}getTile(t){t=int(t);const e=int(4),i=t.div(e),s=this.screenTileIndex.mul(int(2)).add(i);return this.lightIndexes.element(s).element(t.modInt(e))}getLightData(t){t=int(t);const e=textureLoad(this.lightsTexture,ivec2(t,0)),i=textureLoad(this.lightsTexture,ivec2(t,1)),s=e.xyz;return{position:s,viewPosition:this.cameraViewMatrix.mul(s),distance:e.w,color:i.rgb,decay:i.w}}setupLights(t,e){this.updateProgram(t.renderer);const i=t.context.reflectedLight;i.directDiffuse.append(),i.directSpecular.append(),Fn((()=>{Loop(this.tileLightCount,(({i:t})=>{const e=this.getTile(t);If(e.equal(int(0)),(()=>{Break()}));const{color:i,decay:s,viewPosition:n,distance:r}=this.getLightData(e.sub(1));directPointLight({color:i,lightViewPosition:n,cutoffDistance:r,decayExponent:s}).append()}))}))().append(),super.setupLights(t,e)}getBufferFitSize(t){const e=this.tileSize;return Math.ceil(t/e)*e}setSize(t,e){return t=this.getBufferFitSize(t),e=this.getBufferFitSize(e),this.bufferSize&&this.bufferSize.width===t&&this.bufferSize.height===e||this.create(t,e),this}updateProgram(t){t.getDrawingBufferSize(_size);const e=this.getBufferFitSize(_size.width),i=this.getBufferFitSize(_size.height);null===this.bufferSize?this.create(e,i):this.bufferSize.width===e&&this.bufferSize.height===i||this.create(e,i)}create(t,e){const{tileSize:i,maxLights:s}=this,n=new Vector2(t,e),r=Math.floor(n.width/i),o=Math.floor(n.width*n.height/i),a=new Float32Array(4*s*2),h=new DataTexture(a,a.length/8,2,RGBAFormat,FloatType),c=new Int32Array(4*o*2),l=new StorageBufferAttribute(c,4),d=storageObject(l,"ivec4",l.count).label("lightIndexes"),u=t=>{const e=instanceIndex.mul(int(2)).add(int(t));return d.element(e)},g=Fn((()=>{const{cameraProjectionMatrix:t,bufferSize:e,screenSize:s}=this,n=e.clone().divideScalar(i).floor(),r=vec2(instanceIndex.modInt(n.width),instanceIndex.div(n.width)).mul(i).div(s),o=float(i).div(s),a=r,h=a.add(o),c=int(0).toVar();u(0).assign(ivec4(0)),u(1).assign(ivec4(0)),Loop(this.maxLights,(({i:e})=>{If(c.greaterThanEqual(this.tileLightCount).or(int(e).greaterThanEqual(int(this.lightsCount))),(()=>{Return()}));const{viewPosition:i,distance:s}=this.getLightData(e),n=t.mul(i),r=n.div(n.w).xy.mul(.5).add(.5).flipY(),o=i.z,l=s.div(o);If(circleIntersectsAABB(r,l,a,h),(()=>{(t=>{t=int(t);const e=int(4),i=t.div(e),s=instanceIndex.mul(int(2)).add(i);return d.element(s).element(t.modInt(e))})(c).assign(e.add(int(1))),c.addAssign(int(1))}))}))}))().compute(o),m=screenCoordinate.div(i).floor().toVar(),f=m.x.add(m.y.mul(r));this.bufferSize=n,this.lightIndexes=d,this.screenTileIndex=f,this.compute=g,this.lightsTexture=h}get hasLights(){return super.hasLights||this.tiledLights.length>0}}export default TiledLightsNode;export const tiledLights=nodeProxy(TiledLightsNode);
//# sourceMappingURL=/sm/33fedfe7f9ba244f3ccad4e043f548b420012f11a97d6ad6f7b6b337fa054fbd.map