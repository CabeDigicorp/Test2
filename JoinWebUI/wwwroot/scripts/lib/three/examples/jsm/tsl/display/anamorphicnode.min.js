/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/tsl/display/AnamorphicNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{RenderTarget,Vector2,PostProcessingUtils}from"three";import{TempNode,nodeObject,Fn,float,NodeUpdateType,uv,passTexture,uniform,convertToTexture,QuadMesh,NodeMaterial,vec2,vec3,Loop,threshold}from"three/tsl";const _quadMesh=new QuadMesh;let _rendererState;class AnamorphicNode extends TempNode{static get type(){return"AnamorphicNode"}constructor(e,t,r,o){super("vec4"),this.textureNode=e,this.tresholdNode=t,this.scaleNode=r,this.colorNode=vec3(.1,0,1),this.samples=o,this.resolution=new Vector2(1,1),this._renderTarget=new RenderTarget(1,1,{depthBuffer:!1}),this._renderTarget.texture.name="anamorphic",this._invSize=uniform(new Vector2),this._textureNode=passTexture(this,this._renderTarget.texture),this.updateBeforeType=NodeUpdateType.FRAME}getTextureNode(){return this._textureNode}setSize(e,t){this._invSize.value.set(1/e,1/t),e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._renderTarget.setSize(e,t)}updateBefore(e){const{renderer:t}=e;_rendererState=PostProcessingUtils.resetRendererState(t,_rendererState);const r=this.textureNode,o=r.value;this._renderTarget.texture.type=o.type;const s=r.value;_quadMesh.material=this._material,this.setSize(o.image.width,o.image.height),t.setRenderTarget(this._renderTarget),_quadMesh.render(t),r.value=s,PostProcessingUtils.restoreRendererState(t,_rendererState)}setup(e){const t=this.textureNode,r=t.uvNode||uv(),o=Fn((()=>{const e=this.samples,o=Math.floor(e/2),s=vec3(0).toVar();return Loop({start:-o,end:o},(({i:e})=>{const i=float(e).abs().div(o).oneMinus(),a=(e=>t.uv(e))(vec2(r.x.add(this._invSize.x.mul(e).mul(this.scaleNode)),r.y)),d=threshold(a,this.tresholdNode).mul(i);s.addAssign(d)})),s.mul(this.colorNode)})),s=this._material||(this._material=new NodeMaterial);s.name="Anamorphic",s.fragmentNode=o();return e.getNodeProperties(this).textureNode=t,this._textureNode}dispose(){this._renderTarget.dispose()}}export const anamorphic=(e,t=.9,r=3,o=32)=>nodeObject(new AnamorphicNode(convertToTexture(e),nodeObject(t),nodeObject(r),o));export default AnamorphicNode;
//# sourceMappingURL=/sm/2d342aa8f8fd2352d7b9ec2f65228ac5698eacd1c4951b974ea5373e1df61967.map