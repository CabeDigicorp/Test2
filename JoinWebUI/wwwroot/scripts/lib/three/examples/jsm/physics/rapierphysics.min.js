/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/physics/RapierPhysics.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Clock,Vector3,Quaternion,Matrix4}from"three";const RAPIER_PATH="https://cdn.skypack.dev/@dimforge/rapier3d-compat@0.12.0",frameRate=60,_scale=new Vector3(1,1,1),ZERO=new Vector3;let RAPIER=null;function getShape(t){const e=t.parameters;if("BoxGeometry"===t.type){const t=void 0!==e.width?e.width/2:.5,n=void 0!==e.height?e.height/2:.5,o=void 0!==e.depth?e.depth/2:.5;return RAPIER.ColliderDesc.cuboid(t,n,o)}if("SphereGeometry"===t.type||"IcosahedronGeometry"===t.type){const t=void 0!==e.radius?e.radius:1;return RAPIER.ColliderDesc.ball(t)}if("BufferGeometry"===t.type){const e=[],n=new Vector3,o=t.getAttribute("position");for(let t=0;t<o.count;t++)n.fromBufferAttribute(o,t),e.push(n.x,n.y,n.z);const r=null===t.getIndex()?Uint32Array.from(Array(parseInt(e.length/3)).keys()):t.getIndex().array;return RAPIER.ColliderDesc.trimesh(e,r)}return null}async function RapierPhysics(){null===RAPIER&&(RAPIER=await import(`${RAPIER_PATH}`),await RAPIER.init());const t=new Vector3(0,-9.81,0),e=new RAPIER.World(t),n=[],o=new WeakMap,r=new Vector3,s=new Quaternion,i=new Matrix4;function a(t,e=0,s=0){const i=getShape(t.geometry);if(null===i)return;i.setMass(e),i.setRestitution(s);const a=t.isInstancedMesh?function(t,e,n){const o=t.instanceMatrix.array,s=[];for(let i=0;i<t.count;i++){const t=r.fromArray(o,16*i+12);s.push(c(t,null,e,n))}return s}(t,e,i):c(t.position,t.quaternion,e,i);e>0&&(n.push(t),o.set(t,a))}function c(t,n,o,r){const s=o>0?RAPIER.RigidBodyDesc.dynamic():RAPIER.RigidBodyDesc.fixed();s.setTranslation(...t),null!==n&&s.setRotation(n);const i=e.createRigidBody(s);return e.createCollider(r,i),i}const l=new Clock;return setInterval((function(){e.timestep=l.getDelta(),e.step();for(let t=0,e=n.length;t<e;t++){const e=n[t];if(e.isInstancedMesh){const t=e.instanceMatrix.array,n=o.get(e);for(let e=0;e<n.length;e++){const o=n[e],r=o.translation();s.copy(o.rotation()),i.compose(r,s,_scale).toArray(t,16*e)}e.instanceMatrix.needsUpdate=!0,e.computeBoundingSphere()}else{const t=o.get(e);e.position.copy(t.translation()),e.quaternion.copy(t.rotation())}}}),1e3/60),{addScene:function(t){t.traverse((function(t){if(t.isMesh){const e=t.userData.physics;e&&a(t,e.mass,e.restitution)}}))},addMesh:a,setMeshPosition:function(t,e,n=0){let r=o.get(t);t.isInstancedMesh&&(r=r[n]),r.setAngvel(ZERO),r.setLinvel(ZERO),r.setTranslation(e)},setMeshVelocity:function(t,e,n=0){let r=o.get(t);t.isInstancedMesh&&(r=r[n]),r.setLinvel(e)}}}export{RapierPhysics};
//# sourceMappingURL=/sm/addc387e18187eccf27662f9452242b31b46ba509047fce52ab4b44dcdfc9072.map