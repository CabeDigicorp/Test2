/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/transpiler/TSLEncoder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import*as THREE from"three";import{VariableDeclaration,Accessor}from"./AST.js";const opLib={"=":"assign","+":"add","-":"sub","*":"mul","/":"div","%":"remainder","<":"lessThan",">":"greaterThan","<=":"lessThanEqual",">=":"greaterThanEqual","==":"equal","&&":"and","||":"or","^^":"xor","&":"bitAnd","|":"bitOr","^":"bitXor","<<":"shiftLeft",">>":"shiftRight","+=":"addAssign","-=":"subAssign","*=":"mulAssign","/=":"divAssign","%=":"remainderAssign","^=":"bitXorAssign","&=":"bitAndAssign","|=":"bitOrAssign","<<=":"shiftLeftAssign",">>=":"shiftRightAssign"},unaryLib={"+":"","-":"negate","~":"bitNot","!":"not","++":"increment","--":"decrement"},isPrimitive=t=>/^(true|false|-?\d)/.test(t);class TSLEncoder{constructor(){this.tab="",this.imports=new Set,this.global=new Set,this.overloadings=new Map,this.iife=!1,this.uniqueNames=!1,this.reference=!1,this._currentProperties={},this._lastStatement=null}addImport(t){t=t.split(".")[0],void 0!==THREE[t]&&!1===this.global.has(t)&&void 0===this._currentProperties[t]&&this.imports.add(t)}emitUniform(t){let i=`const ${t.name} = `;return!0===this.reference?(this.addImport("reference"),this.global.add(t.name),i+=`reference( 'value', '${t.type}', uniforms[ '${t.name}' ] )`):(this.addImport("uniform"),this.global.add(t.name),i+=`uniform( '${t.type}' )`),i}emitExpression(t){let i;if(t.isAccessor)this.addImport(t.property),i=t.property;else if(t.isNumber)"int"===t.type||"uint"===t.type?(i=t.type+"( "+t.value+" )",this.addImport(t.type)):i=t.value;else if(t.isString)i="'"+t.value+"'";else if(t.isOperator){const e=opLib[t.type]||t.type,s=this.emitExpression(t.left),n=this.emitExpression(t.right);if(isPrimitive(s)&&isPrimitive(n))return s+" "+t.type+" "+n;isPrimitive(s)?(i=e+"( "+s+", "+n+" )",this.addImport(e)):i=s+"."+e+"( "+n+" )"}else if(t.isFunctionCall){const e=[];for(const i of t.params)e.push(this.emitExpression(i));this.addImport(t.name);const s=e.length>0?" "+e.join(", ")+" ":"";i=`${t.name}(${s})`}else if(t.isReturn)i="return",t.value&&(i+=" "+this.emitExpression(t.value));else if(t.isAccessorElements){i=t.property;for(const e of t.elements)if(e.isStaticElement)i+="."+this.emitExpression(e.value);else if(e.isDynamicElement){const t=this.emitExpression(e.value);isPrimitive(t)?i+=`[ ${t} ]`:i+=`.element( ${t} )`}}else if(t.isDynamicElement)i=this.emitExpression(t.value);else if(t.isStaticElement)i=this.emitExpression(t.value);else if(t.isFor)i=this.emitFor(t);else if(t.isVariableDeclaration)i=this.emitVariables(t);else if(t.isUniform)i=this.emitUniform(t);else if(t.isTernary)i=this.emitTernary(t);else if(t.isConditional)i=this.emitConditional(t);else if(t.isUnary&&t.expression.isNumber)i=t.type+" "+t.expression.value;else if(t.isUnary){let e=unaryLib[t.type];!1!==t.after||"++"!==t.type&&"--"!==t.type||(e+="Before");const s=this.emitExpression(t.expression);isPrimitive(s)?(this.addImport(e),i=e+"( "+s+" )"):i=s+"."+e+"()"}else console.warn("Unknown node type",t);return i||(i="/* unknown statement */"),i}emitBody(t){this.setLastStatement(null);let i="";this.tab+="\t";for(const e of t)i+=this.emitExtraLine(e),i+=this.tab+this.emitExpression(e),"}"!==i.slice(-1)&&(i+=";"),i+="\n",this.setLastStatement(e);return i=i.slice(0,-1),this.tab=this.tab.slice(0,-1),i}emitTernary(t){const i=this.emitExpression(t.cond),e=this.emitExpression(t.left),s=this.emitExpression(t.right);return this.addImport("select"),`select( ${i}, ${e}, ${s} )`}emitConditional(t){let i=`If( ${this.emitExpression(t.cond)}, () => {\n\n${this.emitBody(t.body)}\n\n${this.tab}} )`,e=t;for(;e.elseConditional;){const t=this.emitBody(e.elseConditional.body);if(e.elseConditional.cond){i+=`.ElseIf( ${this.emitExpression(e.elseConditional.cond)}, () => {\n\n${t}\n\n${this.tab}} )`}else i+=`.Else( () => {\n\n${t}\n\n${this.tab}} )`;e=e.elseConditional}return this.imports.add("If"),i}emitLoop(t){const i=this.emitExpression(t.initialization.value),e=this.emitExpression(t.condition.right),s=t.initialization.name,n=t.initialization.type,o=t.condition.type,r=t.afterthought.type;let a=`Loop( { start: ${i}, end: ${e+("i"!==s?`, name: '${s}'`:"")+("int"!==n?`, type: '${n}'`:"")+("<"!==o?`, condition: '${o}'`:"")+("++"!==r?`, update: '${r}'`:"")} }, ( { ${s} } ) => {\n\n`;return a+=this.emitBody(t.body)+"\n\n",a+=this.tab+"} )",this.imports.add("Loop"),a}emitFor(t){const{initialization:i,condition:e,afterthought:s}=t;return i&&i.isVariableDeclaration&&null===i.next&&e&&e.left.isAccessor&&e.left.property===i.name&&s&&s.isUnary&&i.name===s.expression.property?this.emitLoop(t):this.emitForWhile(t)}emitForWhile(t){const i=this.emitExpression(t.initialization),e=this.emitExpression(t.condition),s=this.emitExpression(t.afterthought);this.tab+="\t";let n="{\n\n"+this.tab+i+";\n\n";return n+=`${this.tab}While( ${e}, () => {\n\n`,n+=this.emitBody(t.body)+"\n\n",n+=this.tab+"\t"+s+";\n\n",n+=this.tab+"} )\n\n",this.tab=this.tab.slice(0,-1),n+=this.tab+"}",this.imports.add("While"),n}emitVariables(t,i=!0){const{name:e,type:s,value:n,next:o}=t,r=n?this.emitExpression(n):"";let a=i?"const ":"";return a+=e,n?n.isFunctionCall&&n.name===s?a+=" = "+r:a+=` = ${s}( ${r} )`:a+=` = ${s}()`,!1===t.immutable&&(a+=".toVar()"),o&&(a+=", "+this.emitVariables(o,!1)),this.addImport(s),a}emitOverloadingFunction(t){const{name:i}=t[0];this.addImport("overloadingFn");return`${!1===this.iife?"export ":""}const ${i} = /*#__PURE__*/ overloadingFn( [ ${t.map((i=>i.name+"_"+t.indexOf(i))).join(", ")} ] );\n`}emitFunction(t){const{name:i,type:e}=t;this._currentProperties={name:t};const s=[],n=[],o=[];let r=!1;for(const i of t.params){let t=`{ name: '${i.name}', type: '${i.type}'`,e=i.name;!1===i.immutable&&"inout"!==i.qualifier&&"out"!==i.qualifier&&(e+="_immutable",o.push(i)),i.qualifier&&("inout"!==i.qualifier&&"out"!==i.qualifier||(r=!0),t+=", qualifier: '"+i.qualifier+"'"),n.push(t+" }"),s.push(e),this._currentProperties[e]=i}for(const i of o)t.body.unshift(new VariableDeclaration(i.type,i.name,new Accessor(i.name+"_immutable")));const a=s.length>0?" [ "+s.join(", ")+" ] ":"",l=this.emitBody(t.body);let h=i,m=null;if(this.overloadings.has(i)){const e=this.overloadings.get(i);if(e.length>1){const i=e.indexOf(t);h+="_"+i,i===e.length-1&&(m=e)}}let p=`${!1===this.iife?"export ":""}const ${h} = /*#__PURE__*/ Fn( (${a}) => {\n\n${l}\n\n${this.tab}} )`;const u=n.length>0?"\n\t\t"+this.tab+n.join(",\n\t\t"+this.tab)+"\n\t"+this.tab:"";if(!1!==t.layout&&!1===r){const t=this.uniqueNames?h+"_"+Math.random().toString(36).slice(2):h;p+=`.setLayout( {\n${this.tab}\tname: '${t}',\n${this.tab}\ttype: '${e}',\n${this.tab}\tinputs: [${u}]\n${this.tab}} )`}return p+=";\n",this.imports.add("Fn"),this.global.add(t.name),null!==m&&(p+="\n"+this.emitOverloadingFunction(m)),p}setLastStatement(t){this._lastStatement=t}emitExtraLine(t){const i=this._lastStatement;if(null===i)return"";if(t.isReturn)return"\n";const e=t=>!0!==t.isFunctionDeclaration&&!0!==t.isFor&&!0!==t.isConditional,s=e(i),n=e(t);return s!==n||!s&&!n?"\n":""}emit(t){let i="\n";this.iife&&(this.tab+="\t");const e=this.overloadings;for(const i of t.body)i.isFunctionDeclaration&&(!1===e.has(i.name)&&e.set(i.name,[]),e.get(i.name).push(i));for(const e of t.body)i+=this.emitExtraLine(e),e.isFunctionDeclaration?i+=this.tab+this.emitFunction(e):i+=this.tab+this.emitExpression(e)+";\n",this.setLastStatement(e);const s=[...this.imports],n=[...this.global];let o="// Three.js Transpiler r"+THREE.REVISION+"\n\n",r="";return this.iife?(o+="( function ( TSL, uniforms ) {\n\n",o+=s.length>0?"\tconst { "+s.join(", ")+" } = TSL;\n":"",r+=n.length>0?"\treturn { "+n.join(", ")+" };\n":"",r+="\n} );"):o+=s.length>0?"import { "+s.join(", ")+" } from 'three/tsl';\n":"",o+i+r}}export default TSLEncoder;
//# sourceMappingURL=/sm/8e5cf7232219865183c5fef4555d769f7e884693fec330a10b9a48205ec34511.map