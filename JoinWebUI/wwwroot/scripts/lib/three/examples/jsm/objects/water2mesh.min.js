/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/objects/Water2Mesh.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Color,Mesh,Vector2,Vector3}from"three";import{Fn,NodeMaterial,NodeUpdateType,TempNode,vec2,viewportSafeUV,viewportSharedTexture,reflector,pow,float,abs,texture,uniform,vec4,cameraPosition,positionWorld,uv,mix,vec3,normalize,max,dot,screenUV}from"three/tsl";class WaterMesh extends Mesh{constructor(e,o={}){const t=new NodeMaterial;super(e,t),this.isWater=!0,t.fragmentNode=new WaterNode(o,this)}}class WaterNode extends TempNode{constructor(e,o){super("vec4"),this.waterBody=o,this.normalMap0=texture(e.normalMap0),this.normalMap1=texture(e.normalMap1),this.flowMap=texture(void 0!==e.flowMap?e.flowMap:null),this.color=uniform(void 0!==e.color?new Color(e.color):new Color(16777215)),this.flowDirection=uniform(void 0!==e.flowDirection?e.flowDirection:new Vector2(1,0)),this.flowSpeed=uniform(void 0!==e.flowSpeed?e.flowSpeed:.03),this.reflectivity=uniform(void 0!==e.reflectivity?e.reflectivity:.02),this.scale=uniform(void 0!==e.scale?e.scale:1),this.flowConfig=uniform(new Vector3),this.updateBeforeType=NodeUpdateType.RENDER,this._cycle=.15,this._halfCycle=.5*this._cycle,this._USE_FLOW=void 0!==e.flowMap}updateFlow(e){this.flowConfig.value.x+=this.flowSpeed.value*e,this.flowConfig.value.y=this.flowConfig.value.x+this._halfCycle,this.flowConfig.value.x>=this._cycle?(this.flowConfig.value.x=0,this.flowConfig.value.y=this._halfCycle):this.flowConfig.value.y>=this._cycle&&(this.flowConfig.value.y=this.flowConfig.value.y-this._cycle),this.flowConfig.value.z=this._halfCycle}updateBefore(e){this.updateFlow(e.deltaTime)}setup(){return Fn((()=>{const e=this.flowConfig.x,o=this.flowConfig.y,t=this.flowConfig.z,i=normalize(cameraPosition.sub(positionWorld));let l;l=!0===this._USE_FLOW?this.flowMap.rg.mul(2).sub(1):vec2(this.flowDirection.x,this.flowDirection.y),l.x.mulAssign(-1);const s=uv(),r=s.mul(this.scale).add(l.mul(e)),a=s.mul(this.scale).add(l.mul(o)),f=this.normalMap0.uv(r),h=this.normalMap1.uv(a),n=abs(t.sub(e)).div(t),c=mix(f,h,n),u=normalize(vec3(c.r.mul(2).sub(1),c.b,c.g.mul(2).sub(1))),d=max(dot(i,u),0),w=pow(float(1).sub(d),5).mul(float(1).sub(this.reflectivity)).add(this.reflectivity),m=u.xz.mul(.05).toVar(),v=reflector();this.waterBody.add(v.target),v.uvNode=v.uvNode.add(m);const p=screenUV.add(m),y=viewportSharedTexture(viewportSafeUV(p));return vec4(this.color,1).mul(mix(y,v,w))}))()}}export{WaterMesh};
//# sourceMappingURL=/sm/a40213d2e22ab50338256c1c906db4b43e2ffb5edb6bf59fb265a15ebb9b8c10.map