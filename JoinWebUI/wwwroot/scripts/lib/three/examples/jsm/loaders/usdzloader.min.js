/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/loaders/USDZLoader.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{BufferAttribute,BufferGeometry,ClampToEdgeWrapping,FileLoader,Group,NoColorSpace,Loader,Mesh,MeshPhysicalMaterial,MirroredRepeatWrapping,RepeatWrapping,SRGBColorSpace,TextureLoader,Object3D,Vector2}from"three";import*as fflate from"../libs/fflate.module.js";class USDAParser{parse(e){const t={},r=e.split("\n");let o=null,n=t;const s=[t];for(const e of r)if(e.includes("=")){const t=e.split("="),r=t[0].trim(),o=t[1].trim();if(o.endsWith("{")){const e={};s.push(e),n[r]=e,n=e}else if(o.endsWith("(")){const e=o.slice(0,-1);n[r]=e;const t={};s.push(t),n=t}else n[r]=o}else if(e.endsWith("{")){const e=n[o]||{};s.push(e),n[o]=e,n=e}else if(e.endsWith("}")){if(s.pop(),0===s.length)continue;n=s[s.length-1]}else if(e.endsWith("(")){const t={};s.push(t),o=e.split("(")[0].trim()||o,n[o]=t,n=t}else e.endsWith(")")?(s.pop(),n=s[s.length-1]):o=e.trim();return t}}class USDZLoader extends Loader{constructor(e){super(e)}load(e,t,r,o){const n=this,s=new FileLoader(n.manager);s.setPath(n.path),s.setResponseType("arraybuffer"),s.setRequestHeader(n.requestHeader),s.setWithCredentials(n.withCredentials),s.load(e,(function(r){try{t(n.parse(r))}catch(t){o?o(t):console.error(t),n.manager.itemError(e)}}),r,o)}parse(e){const t=new USDAParser;function r(e){const t=e.slice(0,7),r=new Uint8Array([80,88,82,45,85,83,68,67]);return t.every(((e,t)=>e===r[t]))}const o=fflate.unzipSync(new Uint8Array(e)),n=function(e){const o={};(new FileLoader).setResponseType("arraybuffer");for(const n in e){if(n.endsWith("png")){const t=new Blob([e[n]],{type:{type:"image/png"}});o[n]=URL.createObjectURL(t)}if(n.endsWith("usd")||n.endsWith("usda")){if(r(e[n]))throw Error("THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.");const s=fflate.strFromU8(e[n]);o[n]=t.parse(s)}}return o}(o),s=function(e){if(e.length<1)return;const t=Object.keys(e)[0];let o=!1;if(t.endsWith("usda"))return e[t];if(t.endsWith("usdc"))o=!0;else if(t.endsWith("usd")){if(!r(e[t]))return e[t];o=!0}if(o)throw Error("THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.")}(o),a=fflate.strFromU8(s),i=t.parse(a);function c(e,t){if(e){if(void 0!==t){const r=`def Mesh "${t}"`;if(r in e)return e[r]}for(const t in e){const r=e[t];if(t.startsWith("def Mesh"))return r;if("object"==typeof r){const e=c(r);if(e)return e}}}}function l(e,t){const r=[];for(let o=0;o<t.length;o++){const n=t[o],s=o*n;if(3===n){const t=e[s+0],o=e[s+1],n=e[s+2];r.push(t,o,n)}else if(4===n){const t=e[s+0],o=e[s+1],n=e[s+2],a=e[s+3];r.push(t,o,n),r.push(t,n,a)}else console.warn("THREE.USDZLoader: Face vertex count of %s unsupported.",n)}return r}function f(e,t){const r=e.array,o=e.itemSize,n=new r.constructor(t.length*o);let s=0,a=0;for(let e=0,i=t.length;e<i;e++){s=t[e]*o;for(let e=0;e<o;e++)n[a++]=r[s++]}return new BufferAttribute(n,o)}function p(e,t=""){for(const r in e){const o=e[r];if(r.startsWith("def Material"+t))return o;if("object"==typeof o){const e=p(o,t);if(e)return e}}}function u(e,t){t["float inputs:rotation"]&&(e.rotation=parseFloat(t["float inputs:rotation"])),t["float2 inputs:scale"]&&(e.repeat=(new Vector2).fromArray(JSON.parse("["+t["float2 inputs:scale"].replace(/[()]*/g,"")+"]"))),t["float2 inputs:translation"]&&(e.offset=(new Vector2).fromArray(JSON.parse("["+t["float2 inputs:translation"].replace(/[()]*/g,"")+"]")))}function d(e,t){for(const r in e){const o=e[r];if(r.startsWith(`def Shader "${t}"`))return o;if("object"==typeof o){const e=d(o,t);if(e)return e}}}function m(e){if("asset inputs:file"in e){const t=e["asset inputs:file"].replace(/@*/g,"").trim(),r=(new TextureLoader).load(n[t]),o={'"clamp"':ClampToEdgeWrapping,'"mirror"':MirroredRepeatWrapping,'"repeat"':RepeatWrapping};return"token inputs:wrapS"in e&&(r.wrapS=o[e["token inputs:wrapS"]]),"token inputs:wrapT"in e&&(r.wrapT=o[e["token inputs:wrapT"]]),r}return null}function h(e){const t=function(e){if(!e)return;const t=new BufferGeometry;let r=null,o=null,n=null,s=-1;if("int[] faceVertexIndices"in e&&(r=JSON.parse(e["int[] faceVertexIndices"])),"int[] faceVertexCounts"in e&&(o=JSON.parse(e["int[] faceVertexCounts"]),r=l(r,o)),"point3f[] points"in e){const o=JSON.parse(e["point3f[] points"].replace(/[()]*/g,""));s=o.length;let n=new BufferAttribute(new Float32Array(o),3);null!==r&&(n=f(n,r)),t.setAttribute("position",n)}if("float2[] primvars:st"in e&&(e["texCoord2f[] primvars:st"]=e["float2[] primvars:st"]),"texCoord2f[] primvars:st"in e){n=JSON.parse(e["texCoord2f[] primvars:st"].replace(/[()]*/g,""));let o=new BufferAttribute(new Float32Array(n),2);null!==r&&(o=f(o,r)),t.setAttribute("uv",o)}if("int[] primvars:st:indices"in e&&null!==n){const r=new BufferAttribute(new Float32Array(n),2);let s=JSON.parse(e["int[] primvars:st:indices"]);s=l(s,o),t.setAttribute("uv",f(r,s))}if("normal3f[] normals"in e){const n=JSON.parse(e["normal3f[] normals"].replace(/[()]*/g,""));let a=new BufferAttribute(new Float32Array(n),3);if(n.length===s)null!==r&&(a=f(a,r));else{let e=Array.from(Array(n.length/3).keys());e=l(e,o),a=f(a,e)}t.setAttribute("normal",a)}else t.computeVertexNormals();return t}(function(e){if(e){if("prepend references"in e){const t=e["prepend references"].split("@"),r=t[1].replace(/^.\//,""),o=t[2].replace(/^<\//,"").replace(/>$/,"");return c(n[r],o)}return c(e)}}(e)),r=function(e){const t=new MeshPhysicalMaterial;if(void 0!==e){const r=e["token outputs:surface.connect"],o=e[`def Shader "${/(\w+).output/.exec(r)[1]}"`];if(void 0!==o){if("color3f inputs:diffuseColor.connect"in o){const r=o["color3f inputs:diffuseColor.connect"],n=d(i,/(\w+).output/.exec(r)[1]);t.map=m(n),t.map.colorSpace=SRGBColorSpace,'def Shader "Transform2d_diffuse"'in e&&u(t.map,e['def Shader "Transform2d_diffuse"'])}else if("color3f inputs:diffuseColor"in o){const e=o["color3f inputs:diffuseColor"].replace(/[()]*/g,"");t.color.fromArray(JSON.parse("["+e+"]"))}if("color3f inputs:emissiveColor.connect"in o){const r=o["color3f inputs:emissiveColor.connect"],n=d(i,/(\w+).output/.exec(r)[1]);t.emissiveMap=m(n),t.emissiveMap.colorSpace=SRGBColorSpace,t.emissive.set(16777215),'def Shader "Transform2d_emissive"'in e&&u(t.emissiveMap,e['def Shader "Transform2d_emissive"'])}else if("color3f inputs:emissiveColor"in o){const e=o["color3f inputs:emissiveColor"].replace(/[()]*/g,"");t.emissive.fromArray(JSON.parse("["+e+"]"))}if("normal3f inputs:normal.connect"in o){const r=o["normal3f inputs:normal.connect"],n=d(i,/(\w+).output/.exec(r)[1]);t.normalMap=m(n),t.normalMap.colorSpace=NoColorSpace,'def Shader "Transform2d_normal"'in e&&u(t.normalMap,e['def Shader "Transform2d_normal"'])}if("float inputs:roughness.connect"in o){const r=o["float inputs:roughness.connect"],n=d(i,/(\w+).output/.exec(r)[1]);t.roughness=1,t.roughnessMap=m(n),t.roughnessMap.colorSpace=NoColorSpace,'def Shader "Transform2d_roughness"'in e&&u(t.roughnessMap,e['def Shader "Transform2d_roughness"'])}else"float inputs:roughness"in o&&(t.roughness=parseFloat(o["float inputs:roughness"]));if("float inputs:metallic.connect"in o){const r=o["float inputs:metallic.connect"],n=d(i,/(\w+).output/.exec(r)[1]);t.metalness=1,t.metalnessMap=m(n),t.metalnessMap.colorSpace=NoColorSpace,'def Shader "Transform2d_metallic"'in e&&u(t.metalnessMap,e['def Shader "Transform2d_metallic"'])}else"float inputs:metallic"in o&&(t.metalness=parseFloat(o["float inputs:metallic"]));if("float inputs:clearcoat.connect"in o){const r=o["float inputs:clearcoat.connect"],n=d(i,/(\w+).output/.exec(r)[1]);t.clearcoat=1,t.clearcoatMap=m(n),t.clearcoatMap.colorSpace=NoColorSpace,'def Shader "Transform2d_clearcoat"'in e&&u(t.clearcoatMap,e['def Shader "Transform2d_clearcoat"'])}else"float inputs:clearcoat"in o&&(t.clearcoat=parseFloat(o["float inputs:clearcoat"]));if("float inputs:clearcoatRoughness.connect"in o){const r=o["float inputs:clearcoatRoughness.connect"],n=d(i,/(\w+).output/.exec(r)[1]);t.clearcoatRoughness=1,t.clearcoatRoughnessMap=m(n),t.clearcoatRoughnessMap.colorSpace=NoColorSpace,'def Shader "Transform2d_clearcoatRoughness"'in e&&u(t.clearcoatRoughnessMap,e['def Shader "Transform2d_clearcoatRoughness"'])}else"float inputs:clearcoatRoughness"in o&&(t.clearcoatRoughness=parseFloat(o["float inputs:clearcoatRoughness"]));if("float inputs:ior"in o&&(t.ior=parseFloat(o["float inputs:ior"])),"float inputs:occlusion.connect"in o){const r=o["float inputs:occlusion.connect"],n=d(i,/(\w+).output/.exec(r)[1]);t.aoMap=m(n),t.aoMap.colorSpace=NoColorSpace,'def Shader "Transform2d_occlusion"'in e&&u(t.aoMap,e['def Shader "Transform2d_occlusion"'])}}}return t}(function(e){if(e){if("rel material:binding"in e){const t=e["rel material:binding"].replace(/^<\//,"").replace(/>$/,"").split("/");return p(i,` "${t[1]}"`)}return p(e)}}(e)),o=t?new Mesh(t,r):new Object3D;if("matrix4d xformOp:transform"in e){const t=JSON.parse("["+e["matrix4d xformOp:transform"].replace(/[()]*/g,"")+"]");o.matrix.fromArray(t),o.matrix.decompose(o.position,o.quaternion,o.scale)}return o}const S=new Group;return function e(t,r){for(const o in t)if(o.startsWith("def Scope"))e(t[o],r);else if(o.startsWith("def Xform")){const n=h(t[o]);/def Xform "(\w+)"/.test(o)&&(n.name=/def Xform "(\w+)"/.exec(o)[1]),r.add(n),e(t[o],n)}}(i,S),S}}export{USDZLoader};
//# sourceMappingURL=/sm/c37d1d1f71c4f52ad674d190307cc8bd97f58fe568f2c12247c051feedcd0513.map