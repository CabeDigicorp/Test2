/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/loaders/PCDLoader.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{BufferGeometry,Color,FileLoader,Float32BufferAttribute,Int32BufferAttribute,Loader,Points,PointsMaterial,SRGBColorSpace}from"three";class PCDLoader extends Loader{constructor(t){super(t),this.littleEndian=!0}load(t,e,i,n){const s=this,r=new FileLoader(s.manager);r.setPath(s.path),r.setResponseType("arraybuffer"),r.setRequestHeader(s.requestHeader),r.setWithCredentials(s.withCredentials),r.load(t,(function(i){try{e(s.parse(i))}catch(e){n?n(e):console.error(e),s.manager.itemError(t)}}),i,n)}parse(t){const e=(new TextDecoder).decode(t),i=function(t){const e={},i=t.search(/[\r\n]DATA\s(\S*)\s/i),n=/[\r\n]DATA\s(\S*)\s/i.exec(t.slice(i-1));if(e.data=n[1],e.headerLen=n[0].length+i,e.str=t.slice(0,e.headerLen),e.str=e.str.replace(/#.*/gi,""),e.version=/^VERSION (.*)/im.exec(e.str),e.fields=/^FIELDS (.*)/im.exec(e.str),e.size=/^SIZE (.*)/im.exec(e.str),e.type=/^TYPE (.*)/im.exec(e.str),e.count=/^COUNT (.*)/im.exec(e.str),e.width=/^WIDTH (.*)/im.exec(e.str),e.height=/^HEIGHT (.*)/im.exec(e.str),e.viewpoint=/^VIEWPOINT (.*)/im.exec(e.str),e.points=/^POINTS (.*)/im.exec(e.str),null!==e.version&&(e.version=parseFloat(e.version[1])),e.fields=null!==e.fields?e.fields[1].split(" "):[],null!==e.type&&(e.type=e.type[1].split(" ")),null!==e.width&&(e.width=parseInt(e.width[1])),null!==e.height&&(e.height=parseInt(e.height[1])),null!==e.viewpoint&&(e.viewpoint=e.viewpoint[1]),null!==e.points&&(e.points=parseInt(e.points[1],10)),null===e.points&&(e.points=e.width*e.height),null!==e.size&&(e.size=e.size[1].split(" ").map((function(t){return parseInt(t,10)}))),null!==e.count)e.count=e.count[1].split(" ").map((function(t){return parseInt(t,10)}));else{e.count=[];for(let t=0,i=e.fields.length;t<i;t++)e.count.push(1)}e.offset={};let s=0;for(let t=0,i=e.fields.length;t<i;t++)"ascii"===e.data?e.offset[e.fields[t]]=t:(e.offset[e.fields[t]]=s,s+=e.size[t]*e.count[t]);return e.rowSize=s,e}(e),n=[],s=[],r=[],o=[],l=[],a=new Color;if("ascii"===i.data){const t=i.offset,d=e.slice(i.headerLen).split("\n");for(let e=0,p=d.length;e<p;e++){if(""===d[e])continue;const p=d[e].split(" ");if(void 0!==t.x&&(n.push(parseFloat(p[t.x])),n.push(parseFloat(p[t.y])),n.push(parseFloat(p[t.z]))),void 0!==t.rgb){const e=i.fields.findIndex((t=>"rgb"===t)),n=i.type[e],s=parseFloat(p[t.rgb]);let o=s;if("F"===n){const t=new Float32Array(1);t[0]=s,o=new Int32Array(t.buffer)[0]}const l=(o>>16&255)/255,d=(o>>8&255)/255,f=(o>>0&255)/255;a.setRGB(l,d,f,SRGBColorSpace),r.push(a.r,a.g,a.b)}void 0!==t.normal_x&&(s.push(parseFloat(p[t.normal_x])),s.push(parseFloat(p[t.normal_y])),s.push(parseFloat(p[t.normal_z]))),void 0!==t.intensity&&o.push(parseFloat(p[t.intensity])),void 0!==t.label&&l.push(parseInt(p[t.label]))}}if("binary_compressed"===i.data){const e=new Uint32Array(t.slice(i.headerLen,i.headerLen+8)),d=e[0],p=e[1],f=function(t,e){const i=t.length,n=new Uint8Array(e);let s,r,o,l=0,a=0;do{if(s=t[l++],s<32){if(s++,a+s>e)throw new Error("Output buffer is not large enough");if(l+s>i)throw new Error("Invalid compressed data");do{n[a++]=t[l++]}while(--s)}else{if(r=s>>5,o=a-((31&s)<<8)-1,l>=i)throw new Error("Invalid compressed data");if(7===r&&(r+=t[l++],l>=i))throw new Error("Invalid compressed data");if(o-=t[l++],a+r+2>e)throw new Error("Output buffer is not large enough");if(o<0)throw new Error("Invalid compressed data");if(o>=a)throw new Error("Invalid compressed data");do{n[a++]=n[o++]}while(2+--r)}}while(l<i);return n}(new Uint8Array(t,i.headerLen+8,d),p),h=new DataView(f.buffer),u=i.offset;for(let t=0;t<i.points;t++){if(void 0!==u.x){const e=i.fields.indexOf("x"),s=i.fields.indexOf("y"),r=i.fields.indexOf("z");n.push(h.getFloat32(i.points*u.x+i.size[e]*t,this.littleEndian)),n.push(h.getFloat32(i.points*u.y+i.size[s]*t,this.littleEndian)),n.push(h.getFloat32(i.points*u.z+i.size[r]*t,this.littleEndian))}if(void 0!==u.rgb){const e=i.fields.indexOf("rgb"),n=h.getUint8(i.points*u.rgb+i.size[e]*t+2)/255,s=h.getUint8(i.points*u.rgb+i.size[e]*t+1)/255,o=h.getUint8(i.points*u.rgb+i.size[e]*t+0)/255;a.setRGB(n,s,o,SRGBColorSpace),r.push(a.r,a.g,a.b)}if(void 0!==u.normal_x){const e=i.fields.indexOf("normal_x"),n=i.fields.indexOf("normal_y"),r=i.fields.indexOf("normal_z");s.push(h.getFloat32(i.points*u.normal_x+i.size[e]*t,this.littleEndian)),s.push(h.getFloat32(i.points*u.normal_y+i.size[n]*t,this.littleEndian)),s.push(h.getFloat32(i.points*u.normal_z+i.size[r]*t,this.littleEndian))}if(void 0!==u.intensity){const e=i.fields.indexOf("intensity");o.push(h.getFloat32(i.points*u.intensity+i.size[e]*t,this.littleEndian))}if(void 0!==u.label){const e=i.fields.indexOf("label");l.push(h.getInt32(i.points*u.label+i.size[e]*t,this.littleEndian))}}}if("binary"===i.data){const e=new DataView(t,i.headerLen),d=i.offset;for(let t=0,p=0;t<i.points;t++,p+=i.rowSize){if(void 0!==d.x&&(n.push(e.getFloat32(p+d.x,this.littleEndian)),n.push(e.getFloat32(p+d.y,this.littleEndian)),n.push(e.getFloat32(p+d.z,this.littleEndian))),void 0!==d.rgb){const t=e.getUint8(p+d.rgb+2)/255,i=e.getUint8(p+d.rgb+1)/255,n=e.getUint8(p+d.rgb+0)/255;a.setRGB(t,i,n,SRGBColorSpace),r.push(a.r,a.g,a.b)}void 0!==d.normal_x&&(s.push(e.getFloat32(p+d.normal_x,this.littleEndian)),s.push(e.getFloat32(p+d.normal_y,this.littleEndian)),s.push(e.getFloat32(p+d.normal_z,this.littleEndian))),void 0!==d.intensity&&o.push(e.getFloat32(p+d.intensity,this.littleEndian)),void 0!==d.label&&l.push(e.getInt32(p+d.label,this.littleEndian))}}const d=new BufferGeometry;n.length>0&&d.setAttribute("position",new Float32BufferAttribute(n,3)),s.length>0&&d.setAttribute("normal",new Float32BufferAttribute(s,3)),r.length>0&&d.setAttribute("color",new Float32BufferAttribute(r,3)),o.length>0&&d.setAttribute("intensity",new Float32BufferAttribute(o,1)),l.length>0&&d.setAttribute("label",new Int32BufferAttribute(l,1)),d.computeBoundingSphere();const p=new PointsMaterial({size:.005});return r.length>0&&(p.vertexColors=!0),new Points(d,p)}}export{PCDLoader};
//# sourceMappingURL=/sm/3c192d29620d937d513fbd4dfc9c6b2835de8af2d0c29dbb88c677771f6e77a6.map