/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/nodes/materials/NodeMaterial.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Material,ShaderMaterial,NoColorSpace,LinearSRGBColorSpace}from"three";import{getNodeChildren,getCacheKey}from"../core/NodeUtils.js";import{attribute}from"../core/AttributeNode.js";import{output,diffuseColor}from"../core/PropertyNode.js";import{materialAlphaTest,materialColor,materialOpacity,materialEmissive,materialNormal}from"../accessors/MaterialNode.js";import{modelViewProjection}from"../accessors/ModelViewProjectionNode.js";import{transformedNormalView}from"../accessors/NormalNode.js";import{instance}from"../accessors/InstanceNode.js";import{positionLocal,positionView}from"../accessors/PositionNode.js";import{skinning}from"../accessors/SkinningNode.js";import{morph}from"../accessors/MorphNode.js";import{texture}from"../accessors/TextureNode.js";import{cubeTexture}from"../accessors/CubeTextureNode.js";import{lightNodes}from"../lighting/LightsNode.js";import{mix}from"../math/MathNode.js";import{float,vec3,vec4}from"../shadernode/ShaderNode.js";import AONode from"../lighting/AONode.js";import{lightingContext}from"../lighting/LightingContextNode.js";import EnvironmentNode from"../lighting/EnvironmentNode.js";import{depthPixel}from"../display/ViewportDepthNode.js";import{cameraLogDepth}from"../accessors/CameraNode.js";const NodeMaterials=new Map;class NodeMaterial extends ShaderMaterial{constructor(){super(),this.isNodeMaterial=!0,this.type=this.constructor.type,this.forceSinglePass=!1,this.fog=!0,this.lights=!0,this.normals=!0,this.colorSpaced=!0,this.lightsNode=null,this.envNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null,this.depthNode=null,this.outputNode=null,this.fragmentNode=null,this.vertexNode=null}customProgramCacheKey(){return this.type+getCacheKey(this)}build(e){this.setup(e)}setup(e){let t;if(e.addStack(),e.stack.outputNode=this.vertexNode||this.setupPosition(e),e.addFlow("vertex",e.removeStack()),e.addStack(),null===this.fragmentNode){!0===this.depthWrite&&this.setupDepth(e),!0===this.normals&&this.setupNormal(e),this.setupDiffuseColor(e),this.setupVariants(e);const o=this.setupLighting(e);t=this.setupOutput(e,vec4(o,diffuseColor.a)),output.assign(t),null!==this.outputNode&&(t=this.outputNode)}else t=this.setupOutput(e,this.fragmentNode);e.stack.outputNode=t,e.addFlow("fragment",e.removeStack())}setupDepth(e){const{renderer:t}=e;let o=this.depthNode;if(null===o&&!0===t.logarithmicDepthBuffer){o=modelViewProjection().w.add(1).log2().mul(cameraLogDepth).mul(.5)}null!==o&&depthPixel.assign(o).append()}setupPosition(e){const{object:t}=e,o=t.geometry;e.addStack(),(o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color)&&morph(t).append(),!0===t.isSkinnedMesh&&skinning(t).append(),t.instanceMatrix&&!0===t.instanceMatrix.isInstancedBufferAttribute&&!0===e.isAvailable("instance")&&instance(t).append(),null!==this.positionNode&&positionLocal.assign(this.positionNode);const i=modelViewProjection();return e.context.vertex=e.removeStack(),e.context.mvp=i,i}setupDiffuseColor({geometry:e}){let t=this.colorNode?vec4(this.colorNode):materialColor;!0===this.vertexColors&&e.hasAttribute("color")&&(t=vec4(t.xyz.mul(attribute("color","vec3")),t.a)),diffuseColor.assign(t);const o=this.opacityNode?float(this.opacityNode):materialOpacity;if(diffuseColor.a.assign(diffuseColor.a.mul(o)),null!==this.alphaTestNode||this.alphaTest>0){const e=null!==this.alphaTestNode?float(this.alphaTestNode):materialAlphaTest;diffuseColor.a.lessThanEqual(e).discard()}}setupVariants(){}setupNormal(){if(!0===this.flatShading){const e=positionView.dFdx().cross(positionView.dFdy()).normalize();transformedNormalView.assign(e)}else{const e=this.normalNode?vec3(this.normalNode):materialNormal;transformedNormalView.assign(e)}}getEnvNode(e){let t=null;return this.envNode?t=this.envNode:this.envMap?t=this.envMap.isCubeTexture?cubeTexture(this.envMap):texture(this.envMap):e.environmentNode&&(t=e.environmentNode),t}setupLights(e){const t=this.getEnvNode(e),o=[];t&&o.push(new EnvironmentNode(t)),e.material.aoMap&&o.push(new AONode(texture(e.material.aoMap)));let i=this.lightsNode||e.lightsNode;return o.length>0&&(i=lightNodes([...i.lightNodes,...o])),i}setupLightingModel(){}setupLighting(e){const{material:t}=e,{backdropNode:o,backdropAlphaNode:i,emissiveNode:s}=this,r=!0===this.lights||null!==this.lightsNode?this.setupLights(e):null;let a=diffuseColor.rgb;if(r&&!1!==r.hasLight){const t=this.setupLightingModel(e);a=lightingContext(r,t,o,i)}else null!==o&&(a=vec3(null!==i?mix(a,o,i):o));return(s&&!0===s.isNode||t.emissive&&!0===t.emissive.isColor)&&(a=a.add(vec3(s||materialEmissive))),a}setupOutput(e,t){const o=e.renderer,i=e.toneMappingNode;if(!0===this.toneMapped&&i&&(t=vec4(i.context({color:t.rgb}),t.a)),!0===this.fog){const o=e.fogNode;o&&(t=vec4(o.mixAssign(t.rgb),t.a))}if(!0===this.colorSpaced){const e=o.currentColorSpace;e!==LinearSRGBColorSpace&&e!==NoColorSpace&&(t=t.linearToColorSpace(e))}return t}setDefaultValues(e){for(const t in e){const o=e[t];void 0===this[t]&&(this[t]=o,o&&o.clone&&(this[t]=o.clone()))}Object.assign(this.defines,e.defines);const t=Object.getOwnPropertyDescriptors(e.constructor.prototype);for(const e in t)void 0===Object.getOwnPropertyDescriptor(this.constructor.prototype,e)&&void 0!==t[e].get&&Object.defineProperty(this.constructor.prototype,e,t[e])}toJSON(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{},nodes:{}});const o=Material.prototype.toJSON.call(this,e),i=getNodeChildren(this);o.inputNodes={};for(const{property:t,childNode:s}of i)o.inputNodes[t]=s.toJSON(e).uuid;function s(e){const t=[];for(const o in e){const i=e[o];delete i.metadata,t.push(i)}return t}if(t){const t=s(e.textures),i=s(e.images),r=s(e.nodes);t.length>0&&(o.textures=t),i.length>0&&(o.images=i),r.length>0&&(o.nodes=r)}return o}copy(e){return this.lightsNode=e.lightsNode,this.envNode=e.envNode,this.colorNode=e.colorNode,this.normalNode=e.normalNode,this.opacityNode=e.opacityNode,this.backdropNode=e.backdropNode,this.backdropAlphaNode=e.backdropAlphaNode,this.alphaTestNode=e.alphaTestNode,this.positionNode=e.positionNode,this.depthNode=e.depthNode,this.outputNode=e.outputNode,this.fragmentNode=e.fragmentNode,this.vertexNode=e.vertexNode,super.copy(e)}static fromMaterial(e){if(!0===e.isNodeMaterial)return e;const t=createNodeMaterialFromType(e.type.replace("Material","NodeMaterial"));if(void 0===t)throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);for(const o in e)t[o]=e[o];return t}}export default NodeMaterial;export function addNodeMaterial(e,t){if("function"!=typeof t||!e)throw new Error(`Node material ${e} is not a class`);NodeMaterials.has(e)?console.warn(`Redefinition of node material ${e}`):(NodeMaterials.set(e,t),t.type=e)}export function createNodeMaterialFromType(e){const t=NodeMaterials.get(e);if(void 0!==t)return new t}addNodeMaterial("NodeMaterial",NodeMaterial);
//# sourceMappingURL=/sm/633b52823ac275a98409316b0ad1614d14859bc0304b212c869b71e3292cdb3b.map