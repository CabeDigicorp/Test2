/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/nodes/core/NodeBuilder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import NodeUniform from"./NodeUniform.js";import NodeAttribute from"./NodeAttribute.js";import NodeVarying from"./NodeVarying.js";import NodeVar from"./NodeVar.js";import NodeCode from"./NodeCode.js";import NodeKeywords from"./NodeKeywords.js";import NodeCache from"./NodeCache.js";import ParameterNode from"./ParameterNode.js";import FunctionNode from"../code/FunctionNode.js";import{createNodeMaterialFromType}from"../materials/NodeMaterial.js";import{NodeUpdateType,defaultBuildStages,shaderStages}from"./constants.js";import{FloatNodeUniform,Vector2NodeUniform,Vector3NodeUniform,Vector4NodeUniform,ColorNodeUniform,Matrix3NodeUniform,Matrix4NodeUniform}from"../../renderers/common/nodes/NodeUniform.js";import{REVISION,RenderTarget,NoColorSpace,LinearEncoding,sRGBEncoding,SRGBColorSpace,Color,Vector2,Vector3,Vector4,Float16BufferAttribute}from"three";import{stack}from"./StackNode.js";import{getCurrentStack,setCurrentStack}from"../shadernode/ShaderNode.js";import CubeRenderTarget from"../../renderers/common/CubeRenderTarget.js";import ChainMap from"../../renderers/common/ChainMap.js";const uniformsGroupCache=new ChainMap,typeFromLength=new Map([[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]),typeFromArray=new Map([[Int8Array,"int"],[Int16Array,"int"],[Int32Array,"int"],[Uint8Array,"uint"],[Uint16Array,"uint"],[Uint32Array,"uint"],[Float32Array,"float"]]),toFloat=t=>(t=Number(t))+(t%1?"":".0");class NodeBuilder{constructor(t,e,r,o=null,n=null){this.object=t,this.material=n||t&&t.material||null,this.geometry=t&&t.geometry||null,this.renderer=e,this.parser=r,this.scene=o,this.nodes=[],this.updateNodes=[],this.updateBeforeNodes=[],this.hashNodes={},this.lightsNode=null,this.environmentNode=null,this.fogNode=null,this.toneMappingNode=null,this.vertexShader=null,this.fragmentShader=null,this.computeShader=null,this.flowNodes={vertex:[],fragment:[],compute:[]},this.flowCode={vertex:"",fragment:"",compute:[]},this.uniforms={vertex:[],fragment:[],compute:[],index:0},this.structs={vertex:[],fragment:[],compute:[],index:0},this.bindings={vertex:[],fragment:[],compute:[]},this.bindingsOffset={vertex:0,fragment:0,compute:0},this.bindingsArray=null,this.attributes=[],this.bufferAttributes=[],this.varyings=[],this.codes={},this.vars={},this.flow={code:""},this.chaining=[],this.stack=stack(),this.stacks=[],this.tab="\t",this.currentFunctionNode=null,this.context={keywords:new NodeKeywords,material:this.material},this.cache=new NodeCache,this.globalCache=this.cache,this.flowsData=new WeakMap,this.shaderStage=null,this.buildStage=null}getRenderTarget(t,e,r){return new RenderTarget(t,e,r)}getCubeRenderTarget(t,e){return new CubeRenderTarget(t,e)}includes(t){return this.nodes.includes(t)}_getSharedBindings(t){const e=[];for(const r of t)if(!0===r.shared){const t=r.getNodes();let o=uniformsGroupCache.get(t);void 0===o&&(uniformsGroupCache.set(t,r),o=r),e.push(o)}else e.push(r);return e}getBindings(){let t=this.bindingsArray;if(null===t){const e=this.bindings;this.bindingsArray=t=this._getSharedBindings(null!==this.material?[...e.vertex,...e.fragment]:e.compute)}return t}setHashNode(t,e){this.hashNodes[e]=t}addNode(t){!1===this.nodes.includes(t)&&(this.nodes.push(t),this.setHashNode(t,t.getHash(this)))}buildUpdateNodes(){for(const t of this.nodes){const e=t.getUpdateType(),r=t.getUpdateBeforeType();e!==NodeUpdateType.NONE&&this.updateNodes.push(t.getSelf()),r!==NodeUpdateType.NONE&&this.updateBeforeNodes.push(t)}}get currentNode(){return this.chaining[this.chaining.length-1]}addChain(t){this.chaining.push(t)}removeChain(t){if(this.chaining.pop()!==t)throw new Error("NodeBuilder: Invalid node chaining!")}getMethod(t){return t}getNodeFromHash(t){return this.hashNodes[t]}addFlow(t,e){return this.flowNodes[t].push(e),e}setContext(t){this.context=t}getContext(){return this.context}setCache(t){this.cache=t}getCache(){return this.cache}isAvailable(){return!1}getVertexIndex(){console.warn("Abstract function.")}getInstanceIndex(){console.warn("Abstract function.")}getFrontFacing(){console.warn("Abstract function.")}getFragCoord(){console.warn("Abstract function.")}isFlipY(){return!1}generateTexture(){console.warn("Abstract function.")}generateTextureLod(){console.warn("Abstract function.")}generateConst(t,e=null){if(null===e&&("float"===t||"int"===t||"uint"===t?e=0:"bool"===t?e=!1:"color"===t?e=new Color:"vec2"===t?e=new Vector2:"vec3"===t?e=new Vector3:"vec4"===t&&(e=new Vector4)),"float"===t)return toFloat(e);if("int"===t)return`${Math.round(e)}`;if("uint"===t)return e>=0?`${Math.round(e)}u`:"0u";if("bool"===t)return e?"true":"false";if("color"===t)return`${this.getType("vec3")}( ${toFloat(e.r)}, ${toFloat(e.g)}, ${toFloat(e.b)} )`;const r=this.getTypeLength(t),o=this.getComponentType(t),n=t=>this.generateConst(o,t);if(2===r)return`${this.getType(t)}( ${n(e.x)}, ${n(e.y)} )`;if(3===r)return`${this.getType(t)}( ${n(e.x)}, ${n(e.y)}, ${n(e.z)} )`;if(4===r)return`${this.getType(t)}( ${n(e.x)}, ${n(e.y)}, ${n(e.z)}, ${n(e.w)} )`;if(r>4&&e&&(e.isMatrix3||e.isMatrix4))return`${this.getType(t)}( ${e.elements.map(n).join(", ")} )`;if(r>4)return`${this.getType(t)}()`;throw new Error(`NodeBuilder: Type '${t}' not found in generate constant attempt.`)}getType(t){return"color"===t?"vec3":t}generateMethod(t){return t}hasGeometryAttribute(t){return this.geometry&&void 0!==this.geometry.getAttribute(t)}getAttribute(t,e){const r=this.attributes;for(const e of r)if(e.name===t)return e;const o=new NodeAttribute(t,e);return r.push(o),o}getPropertyName(t){return t.name}isVector(t){return/vec\d/.test(t)}isMatrix(t){return/mat\d/.test(t)}isReference(t){return"void"===t||"property"===t||"sampler"===t||"texture"===t||"cubeTexture"===t}needsColorSpaceToLinear(){return!1}getTextureEncodingFromMap(t){return console.warn("THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+."),this.getTextureColorSpaceFromMap(t)===SRGBColorSpace?sRGBEncoding:LinearEncoding}getTextureColorSpaceFromMap(t){let e;return e=t&&t.isTexture?t.colorSpace:t&&t.isWebGLRenderTarget?t.texture.colorSpace:NoColorSpace,e}getComponentType(t){if("float"===(t=this.getVectorType(t))||"bool"===t||"int"===t||"uint"===t)return t;const e=/(b|i|u|)(vec|mat)([2-4])/.exec(t);return null===e?null:"b"===e[1]?"bool":"i"===e[1]?"int":"u"===e[1]?"uint":"float"}getVectorType(t){return"color"===t?"vec3":"texture"===t?"vec4":t}getTypeFromLength(t,e="float"){if(1===t)return e;const r=typeFromLength.get(t);return("float"===e?"":e[0])+r}getTypeFromArray(t){return typeFromArray.get(t.constructor)}getTypeFromAttribute(t){let e=t;t.isInterleavedBufferAttribute&&(e=t.data);const r=e.array,o=t.itemSize,n=t.normalized;let i;return t instanceof Float16BufferAttribute||!0===n||(i=this.getTypeFromArray(r)),this.getTypeFromLength(o,i)}getTypeLength(t){const e=this.getVectorType(t),r=/vec([2-4])/.exec(e);return null!==r?Number(r[1]):"float"===e||"bool"===e||"int"===e||"uint"===e?1:!0===/mat3/.test(t)?9:!0===/mat4/.test(t)?16:0}getVectorFromMatrix(t){return t.replace("mat","vec")}changeComponentType(t,e){return this.getTypeFromLength(this.getTypeLength(t),e)}getIntegerType(t){const e=this.getComponentType(t);return"int"===e||"uint"===e?t:this.changeComponentType(t,"int")}addStack(){return this.stack=stack(this.stack),this.stacks.push(getCurrentStack()||this.stack),setCurrentStack(this.stack),this.stack}removeStack(){const t=this.stack;return this.stack=t.parent,setCurrentStack(this.stacks.pop()),t}getDataFromNode(t,e=this.shaderStage,r=null){let o=(r=null===r?t.isGlobal(this)?this.globalCache:this.cache:r).getNodeData(t);return void 0===o&&(o={},r.setNodeData(t,o)),void 0===o[e]&&(o[e]={}),o[e]}getNodeProperties(t,e="any"){const r=this.getDataFromNode(t,e);return r.properties||(r.properties={outputNode:null})}getBufferAttributeFromNode(t,e){const r=this.getDataFromNode(t);let o=r.bufferAttribute;if(void 0===o){const n=this.uniforms.index++;o=new NodeAttribute("nodeAttribute"+n,e,t),this.bufferAttributes.push(o),r.bufferAttribute=o}return o}getStructTypeFromNode(t,e=this.shaderStage){const r=this.getDataFromNode(t,e);if(void 0===r.structType){const o=this.structs.index++;t.name=`StructType${o}`,this.structs[e].push(t),r.structType=t}return t}getUniformFromNode(t,e,r=this.shaderStage,o=null){const n=this.getDataFromNode(t,r,this.globalCache);let i=n.uniform;if(void 0===i){const s=this.uniforms.index++;i=new NodeUniform(o||"nodeUniform"+s,e,t),this.uniforms[r].push(i),n.uniform=i}return i}getVarFromNode(t,e=null,r=t.getNodeType(this),o=this.shaderStage){const n=this.getDataFromNode(t,o);let i=n.variable;if(void 0===i){const t=this.vars[o]||(this.vars[o]=[]);null===e&&(e="nodeVar"+t.length),i=new NodeVar(e,r),t.push(i),n.variable=i}return i}getVaryingFromNode(t,e=null,r=t.getNodeType(this)){const o=this.getDataFromNode(t,"any");let n=o.varying;if(void 0===n){const t=this.varyings,i=t.length;null===e&&(e="nodeVarying"+i),n=new NodeVarying(e,r),t.push(n),o.varying=n}return n}getCodeFromNode(t,e,r=this.shaderStage){const o=this.getDataFromNode(t);let n=o.code;if(void 0===n){const t=this.codes[r]||(this.codes[r]=[]),i=t.length;n=new NodeCode("nodeCode"+i,e),t.push(n),o.code=n}return n}addLineFlowCode(t){return""===t||(t=this.tab+t,/;\s*$/.test(t)||(t+=";\n"),this.flow.code+=t),this}addFlowCode(t){return this.flow.code+=t,this}addFlowTab(){return this.tab+="\t",this}removeFlowTab(){return this.tab=this.tab.slice(0,-1),this}getFlowData(t){return this.flowsData.get(t)}flowNode(t){const e=t.getNodeType(this),r=this.flowChildNode(t,e);return this.flowsData.set(t,r),r}buildFunctionNode(t){const e=new FunctionNode,r=this.currentFunctionNode;return this.currentFunctionNode=e,e.code=this.buildFunctionCode(t),this.currentFunctionNode=r,e}flowShaderNode(t){const e=t.layout;let r;if(t.isArrayInput){r=[];for(const t of e.inputs)r.push(new ParameterNode(t.type,t.name))}else{r={};for(const t of e.inputs)r[t.name]=new ParameterNode(t.type,t.name)}t.layout=null;const o=t.call(r),n=this.flowStagesNode(o,e.type);return t.layout=e,n}flowStagesNode(t,e=null){const r=this.flow,o=this.vars,n=this.buildStage,i={code:""};this.flow=i,this.vars={};for(const r of defaultBuildStages)this.setBuildStage(r),i.result=t.build(this,e);return i.vars=this.getVars(this.shaderStage),this.flow=r,this.vars=o,this.setBuildStage(n),i}getFunctionOperator(){return null}flowChildNode(t,e=null){const r=this.flow,o={code:""};return this.flow=o,o.result=t.build(this,e),this.flow=r,o}flowNodeFromShaderStage(t,e,r=null,o=null){const n=this.shaderStage;this.setShaderStage(t);const i=this.flowChildNode(e,r);return null!==o&&(i.code+=`${this.tab+o} = ${i.result};\n`),this.flowCode[t]=this.flowCode[t]+i.code,this.setShaderStage(n),i}getAttributesArray(){return this.attributes.concat(this.bufferAttributes)}getAttributes(){console.warn("Abstract function.")}getVaryings(){console.warn("Abstract function.")}getVar(t,e){return`${this.getType(t)} ${e}`}getVars(t){let e="";const r=this.vars[t];if(void 0!==r)for(const t of r)e+=`${this.getVar(t.type,t.name)}; `;return e}getUniforms(){console.warn("Abstract function.")}getCodes(t){const e=this.codes[t];let r="";if(void 0!==e)for(const t of e)r+=t.code+"\n";return r}getHash(){return this.vertexShader+this.fragmentShader+this.computeShader}setShaderStage(t){this.shaderStage=t}getShaderStage(){return this.shaderStage}setBuildStage(t){this.buildStage=t}getBuildStage(){return this.buildStage}buildCode(){console.warn("Abstract function.")}build(){for(const t of defaultBuildStages){this.setBuildStage(t),this.context.vertex&&this.context.vertex.isNode&&this.flowNodeFromShaderStage("vertex",this.context.vertex);for(const e of shaderStages){this.setShaderStage(e);const r=this.flowNodes[e];for(const e of r)"generate"===t?this.flowNode(e):e.build(this)}}return this.setBuildStage(null),this.setShaderStage(null),this.buildCode(),this.buildUpdateNodes(),this}getNodeUniform(t,e){if("float"===e)return new FloatNodeUniform(t);if("vec2"===e)return new Vector2NodeUniform(t);if("vec3"===e)return new Vector3NodeUniform(t);if("vec4"===e)return new Vector4NodeUniform(t);if("color"===e)return new ColorNodeUniform(t);if("mat3"===e)return new Matrix3NodeUniform(t);if("mat4"===e)return new Matrix4NodeUniform(t);throw new Error(`Uniform "${e}" not declared.`)}createNodeMaterial(t){return createNodeMaterialFromType(t)}getPrimitiveType(t){let e;return e="i"===t[0]?"int":"u"===t[0]?"uint":"float",e}format(t,e,r){if((e=this.getVectorType(e))===(r=this.getVectorType(r))||null===r||this.isReference(r))return t;const o=this.getTypeLength(e),n=this.getTypeLength(r);return o>4||n>4||0===n?t:o===n?`${this.getType(r)}( ${t} )`:o>n?this.format(`${t}.${"xyz".slice(0,n)}`,this.getTypeFromLength(n,this.getComponentType(e)),r):4===n&&o>1?`${this.getType(r)}( ${this.format(t,e,"vec3")}, 1.0 )`:2===o?`${this.getType(r)}( ${this.format(t,e,"vec2")}, 0.0 )`:(1===o&&n>1&&e[0]!==r[0]&&(t=`${this.getType(this.getPrimitiveType(r))}( ${t} )`),`${this.getType(r)}( ${t} )`)}getSignature(){return`// Three.js r${REVISION} - NodeMaterial System\n`}}export default NodeBuilder;
//# sourceMappingURL=/sm/8c97241ef5eef79cbd0c1115b1bffb172a6813e8382b9fb345ac036885c2b829.map