/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/nodes/accessors/MorphNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Node,{addNodeClass}from"../core/Node.js";import{NodeUpdateType}from"../core/constants.js";import{nodeProxy,tslFn}from"../shadernode/ShaderNode.js";import{uniform}from"../core/UniformNode.js";import{referenceIndex}from"./ReferenceNode.js";import{positionLocal}from"./PositionNode.js";import{normalLocal}from"./NormalNode.js";import{textureLoad}from"./TextureNode.js";import{vertexIndex}from"../core/IndexNode.js";import{ivec2,int}from"../shadernode/ShaderNode.js";import{DataArrayTexture,Vector2,Vector4,FloatType}from"three";const morphTextures=new WeakMap,morphVec4=new Vector4,getMorph=tslFn((({bufferMap:e,influence:o,stride:t,width:r,depth:s,offset:i})=>{const n=int(vertexIndex).mul(t).add(i),p=n.div(r),m=n.sub(p.mul(r));return textureLoad(e,ivec2(m,p)).depth(s).mul(o)}));function getEntry(e){const o=void 0!==e.morphAttributes.position,t=void 0!==e.morphAttributes.normal,r=void 0!==e.morphAttributes.color,s=e.morphAttributes.position||e.morphAttributes.normal||e.morphAttributes.color,i=void 0!==s?s.length:0;let n=morphTextures.get(e);if(void 0===n||n.count!==i){void 0!==n&&n.texture.dispose();const s=e.morphAttributes.position||[],p=e.morphAttributes.normal||[],m=e.morphAttributes.color||[];let d=0;!0===o&&(d=1),!0===t&&(d=2),!0===r&&(d=3);let h=e.attributes.position.count*d,c=1;const u=4096;h>u&&(c=Math.ceil(h/u),h=u);const a=new Float32Array(h*c*4*i),l=new DataArrayTexture(a,h,c,i);l.type=FloatType,l.needsUpdate=!0;const f=4*d;for(let e=0;e<i;e++){const i=s[e],n=p[e],d=m[e],u=h*c*4*e;for(let e=0;e<i.count;e++){const s=e*f;!0===o&&(morphVec4.fromBufferAttribute(i,e),a[u+s+0]=morphVec4.x,a[u+s+1]=morphVec4.y,a[u+s+2]=morphVec4.z,a[u+s+3]=0),!0===t&&(morphVec4.fromBufferAttribute(n,e),a[u+s+4]=morphVec4.x,a[u+s+5]=morphVec4.y,a[u+s+6]=morphVec4.z,a[u+s+7]=0),!0===r&&(morphVec4.fromBufferAttribute(d,e),a[u+s+8]=morphVec4.x,a[u+s+9]=morphVec4.y,a[u+s+10]=morphVec4.z,a[u+s+11]=4===d.itemSize?morphVec4.w:1)}}n={count:i,texture:l,stride:d,size:new Vector2(h,c)},morphTextures.set(e,n),e.addEventListener("dispose",(function o(){l.dispose(),morphTextures.delete(e),e.removeEventListener("dispose",o)}))}return n}class MorphNode extends Node{constructor(e){super("void"),this.mesh=e,this.morphBaseInfluence=uniform(1),this.updateType=NodeUpdateType.OBJECT}setup(e){const{geometry:o}=e,t=void 0!==o.morphAttributes.position,r=void 0!==o.morphAttributes.normal,s=o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color,i=void 0!==s?s.length:0,{texture:n,stride:p,size:m}=getEntry(o);!0===t&&positionLocal.mulAssign(this.morphBaseInfluence),!0===r&&normalLocal.mulAssign(this.morphBaseInfluence);const d=int(m.width);for(let e=0;e<i;e++){const o=referenceIndex("morphTargetInfluences",e,"float"),s=int(e);!0===t&&positionLocal.addAssign(getMorph({bufferMap:n,influence:o,stride:p,width:d,depth:s,offset:int(0)})),!0===r&&normalLocal.addAssign(getMorph({bufferMap:n,influence:o,stride:p,width:d,depth:s,offset:int(1)}))}}update(){const e=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?e.value=1:e.value=1-this.mesh.morphTargetInfluences.reduce(((e,o)=>e+o),0)}}export default MorphNode;export const morph=nodeProxy(MorphNode);addNodeClass("MorphNode",MorphNode);
//# sourceMappingURL=/sm/f1dc3f0e23a3f150686174f8fe651a36d184b9cb22c38cb57cb9bbf2df5281dd.map