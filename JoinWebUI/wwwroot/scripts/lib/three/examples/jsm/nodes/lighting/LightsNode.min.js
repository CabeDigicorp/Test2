/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/nodes/lighting/LightsNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Node from"../core/Node.js";import AnalyticLightNode from"./AnalyticLightNode.js";import{nodeObject,nodeProxy,vec3}from"../shadernode/ShaderNode.js";const LightNodes=new WeakMap,sortLights=t=>t.sort(((t,e)=>t.id-e.id));class LightsNode extends Node{constructor(t=[]){super("vec3"),this.totalDiffuseNode=vec3().temp("totalDiffuse"),this.totalSpecularNode=vec3().temp("totalSpecular"),this.outgoingLightNode=vec3().temp("outgoingLight"),this.lightNodes=t,this._hash=null}get hasLight(){return this.lightNodes.length>0}getHash(){if(null===this._hash){const t=[];for(const e of this.lightNodes)t.push(e.getHash());this._hash="lights-"+t.join(",")}return this._hash}setup(t){const e=t.context,o=e.lightingModel;let i=this.outgoingLightNode;if(o){const{lightNodes:s,totalDiffuseNode:h,totalSpecularNode:n}=this;e.outgoingLight=i;const d=t.addStack();o.start(e,d,t);for(const e of s)e.build(t);o.indirectDiffuse(e,d,t),o.indirectSpecular(e,d,t),o.ambientOcclusion(e,d,t);const{backdrop:r,backdropAlpha:c}=e,{directDiffuse:g,directSpecular:l,indirectDiffuse:a,indirectSpecular:f}=e.reflectedLight;let u=g.add(a);null!==r&&(u=vec3(null!==c?c.mix(u,r):r)),h.assign(u),n.assign(l.add(f)),i.assign(h.add(n)),o.finish(e,d,t),i=i.bypass(t.removeStack())}return i}_getLightNodeById(t){for(const e of this.lightNodes)if(e.isAnalyticLightNode&&e.light.id===t)return e;return null}fromLights(t=[]){const e=[];t=sortLights(t);for(const o of t){let t=this._getLightNodeById(o.id);if(null===t){const e=o.constructor,i=LightNodes.has(e)?LightNodes.get(e):AnalyticLightNode;t=nodeObject(new i(o))}e.push(t)}return this.lightNodes=e,this._hash=null,this}}export default LightsNode;export const lights=t=>nodeObject((new LightsNode).fromLights(t));export const lightNodes=nodeProxy(LightsNode);export function addLightNode(t,e){if(LightNodes.has(t))console.warn(`Redefinition of light node ${e.type}`);else{if("function"!=typeof t)throw new Error(`Light ${t.name} is not a class`);if("function"!=typeof e||!e.type)throw new Error(`Light node ${e.type} is not a class`);LightNodes.set(t,e)}}
//# sourceMappingURL=/sm/8022a020172cc299e7c55442f40f244c94ab1941db7b0d1e76efa38376028ddb.map