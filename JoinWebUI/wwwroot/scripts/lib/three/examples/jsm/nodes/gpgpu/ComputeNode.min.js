/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/nodes/gpgpu/ComputeNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Node,{addNodeClass}from"../core/Node.js";import{NodeUpdateType}from"../core/constants.js";import{addNodeElement,nodeObject}from"../shadernode/ShaderNode.js";class ComputeNode extends Node{constructor(e,t,o=[64]){super("void"),this.isComputeNode=!0,this.computeNode=e,this.count=t,this.workgroupSize=o,this.dispatchCount=0,this.version=1,this.updateBeforeType=NodeUpdateType.OBJECT,this.updateDispatchCount()}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){!0===e&&this.version++}updateDispatchCount(){const{count:e,workgroupSize:t}=this;let o=t[0];for(let e=1;e<t.length;e++)o*=t[e];this.dispatchCount=Math.ceil(e/o)}onInit(){}updateBefore({renderer:e}){e.compute(this)}generate(e){const{shaderStage:t}=e;if("compute"===t){const t=this.computeNode.build(e,"void");""!==t&&e.addLineFlowCode(t)}}}export default ComputeNode;export const compute=(e,t,o)=>nodeObject(new ComputeNode(nodeObject(e),t,o));addNodeElement("compute",compute),addNodeClass("ComputeNode",ComputeNode);
//# sourceMappingURL=/sm/99957ab9aa722eb61b3eb182501280d39b988d9d5328e2798cc4d984e015b2f8.map