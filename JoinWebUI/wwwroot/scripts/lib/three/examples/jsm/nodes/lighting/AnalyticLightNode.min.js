/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/nodes/lighting/AnalyticLightNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import LightingNode from"./LightingNode.js";import{NodeUpdateType}from"../core/constants.js";import{uniform}from"../core/UniformNode.js";import{addNodeClass}from"../core/Node.js";import{vec3}from"../shadernode/ShaderNode.js";import{reference}from"../accessors/ReferenceNode.js";import{texture}from"../accessors/TextureNode.js";import{positionWorld}from"../accessors/PositionNode.js";import{normalWorld}from"../accessors/NormalNode.js";import{WebGPUCoordinateSystem}from"three";import{Color,DepthTexture,NearestFilter,LessCompare}from"three";let depthMaterial=null;class AnalyticLightNode extends LightingNode{constructor(e=null){super(),this.updateType=NodeUpdateType.FRAME,this.light=e,this.rtt=null,this.shadowNode=null,this.color=new Color,this._defaultColorNode=uniform(this.color),this.colorNode=this._defaultColorNode,this.isAnalyticLightNode=!0}getCacheKey(){return super.getCacheKey()+"-"+this.light.id+"-"+(this.light.castShadow?"1":"0")}getHash(){return this.light.uuid}setupShadow(e){let t=this.shadowNode;if(null===t){null===depthMaterial&&(depthMaterial=e.createNodeMaterial("MeshBasicNodeMaterial"));const o=this.light.shadow,r=e.getRenderTarget(o.mapSize.width,o.mapSize.height),i=new DepthTexture;i.minFilter=NearestFilter,i.magFilter=NearestFilter,i.image.width=o.mapSize.width,i.image.height=o.mapSize.height,i.compareFunction=LessCompare,r.depthTexture=i,o.camera.updateProjectionMatrix();const a=reference("bias","float",o),s=reference("normalBias","float",o);let d=uniform(o.matrix).mul(positionWorld.add(normalWorld.mul(s)));d=d.xyz.div(d.w);const h=d.x.greaterThanEqual(0).and(d.x.lessThanEqual(1)).and(d.y.greaterThanEqual(0)).and(d.y.lessThanEqual(1)).and(d.z.lessThanEqual(1));let l=d.z.add(a);e.renderer.coordinateSystem===WebGPUCoordinateSystem&&(l=l.mul(2).sub(1)),d=vec3(d.x,d.y.oneMinus(),l);const n=(e,t,o)=>texture(e,t).compare(o);t=n(i,d.xy,d.z),this.rtt=r,this.colorNode=this.colorNode.mul(h.mix(1,t)),this.shadowNode=t,this.updateBeforeType=NodeUpdateType.RENDER}}setup(e){this.light.castShadow?this.setupShadow(e):null!==this.shadowNode&&this.disposeShadow()}updateShadow(e){const{rtt:t,light:o}=this,{renderer:r,scene:i}=e,a=i.overrideMaterial;i.overrideMaterial=depthMaterial,t.setSize(o.shadow.mapSize.width,o.shadow.mapSize.height),o.shadow.updateMatrices(o);const s=r.getRenderTarget(),d=r.getRenderObjectFunction();r.setRenderObjectFunction(((e,...t)=>{!0===e.castShadow&&r.renderObject(e,...t)})),r.setRenderTarget(t),r.render(i,o.shadow.camera),r.setRenderTarget(s),r.setRenderObjectFunction(d),i.overrideMaterial=a}disposeShadow(){this.rtt.dispose(),this.shadowNode=null,this.rtt=null,this.colorNode=this._defaultColorNode}updateBefore(e){const{light:t}=this;t.castShadow&&this.updateShadow(e)}update(){const{light:e}=this;this.color.copy(e.color).multiplyScalar(e.intensity)}}export default AnalyticLightNode;addNodeClass("AnalyticLightNode",AnalyticLightNode);
//# sourceMappingURL=/sm/1801a5e2838f8de218ee8044ba980858fdee818c5c0af3834ef412c9f5e3edd3.map