/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/nodes/display/PassNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{addNodeClass}from"../core/Node.js";import TempNode from"../core/TempNode.js";import TextureNode from"../accessors/TextureNode.js";import{NodeUpdateType}from"../core/constants.js";import{nodeObject}from"../shadernode/ShaderNode.js";import{uniform}from"../core/UniformNode.js";import{viewZToOrthographicDepth,perspectiveDepthToViewZ}from"./ViewportDepthNode.js";import{RenderTarget,Vector2,HalfFloatType,DepthTexture,FloatType,NoToneMapping}from"three";class PassTextureNode extends TextureNode{constructor(e,t){super(t),this.passNode=e,this.setUpdateMatrix(!1)}setup(e){return this.passNode.build(e),super.setup(e)}clone(){return new this.constructor(this.passNode,this.value)}}class PassNode extends TempNode{constructor(e,t,s){super("vec4"),this.scope=e,this.scene=t,this.camera=s,this._pixelRatio=1,this._width=1,this._height=1;const o=new DepthTexture;o.isRenderTargetTexture=!0,o.type=FloatType,o.name="PostProcessingDepth";const r=new RenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:HalfFloatType});r.texture.name="PostProcessing",r.depthTexture=o,this.renderTarget=r,this.updateBeforeType=NodeUpdateType.FRAME,this._textureNode=nodeObject(new PassTextureNode(this,r.texture)),this._depthTextureNode=nodeObject(new PassTextureNode(this,o)),this._depthNode=null,this._cameraNear=uniform(0),this._cameraFar=uniform(0),this.isPassNode=!0}isGlobal(){return!0}getTextureNode(){return this._textureNode}getTextureDepthNode(){return this._depthTextureNode}getDepthNode(){if(null===this._depthNode){const e=this._cameraNear,t=this._cameraFar;this._depthNode=viewZToOrthographicDepth(perspectiveDepthToViewZ(this._depthTextureNode,e,t),e,t)}return this._depthNode}setup(){return this.scope===PassNode.COLOR?this.getTextureNode():this.getDepthNode()}updateBefore(e){const{renderer:t}=e,{scene:s,camera:o}=this;this._pixelRatio=t.getPixelRatio();const r=t.getSize(new Vector2);this.setSize(r.width,r.height);const i=t.toneMapping,a=t.toneMappingNode,h=t.getRenderTarget();this._cameraNear.value=o.near,this._cameraFar.value=o.far,t.toneMapping=NoToneMapping,t.toneMappingNode=null,t.setRenderTarget(this.renderTarget),t.render(s,o),t.toneMapping=i,t.toneMappingNode=a,t.setRenderTarget(h)}setSize(e,t){this._width=e,this._height=t;const s=this._width*this._pixelRatio,o=this._height*this._pixelRatio;this.renderTarget.setSize(s,o)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}PassNode.COLOR="color",PassNode.DEPTH="depth";export default PassNode;export const pass=(e,t)=>nodeObject(new PassNode(PassNode.COLOR,e,t));export const depthPass=(e,t)=>nodeObject(new PassNode(PassNode.DEPTH,e,t));addNodeClass("PassNode",PassNode);
//# sourceMappingURL=/sm/c72af324f676fba1c882d64912ef46541aa8a1bdc7d5e770e448f841510ae4fb.map