/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/nodes/core/Node.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{EventDispatcher}from"three";import{NodeUpdateType}from"./constants.js";import{getNodeChildren,getCacheKey}from"./NodeUtils.js";import{MathUtils}from"three";const NodeClasses=new Map;let _nodeId=0;class Node extends EventDispatcher{constructor(e=null){super(),this.nodeType=e,this.updateType=NodeUpdateType.NONE,this.updateBeforeType=NodeUpdateType.NONE,this.uuid=MathUtils.generateUUID(),this.isNode=!0,Object.defineProperty(this,"id",{value:_nodeId++})}get type(){return this.constructor.type}getSelf(){return this.self||this}updateReference(){return this}isGlobal(){return!1}*getChildren(){for(const{childNode:e}of getNodeChildren(this))yield e}dispose(){this.dispatchEvent({type:"dispose"})}traverse(e){e(this);for(const t of this.getChildren())t.traverse(e)}getCacheKey(){return getCacheKey(this)}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getNodeType(e){const t=e.getNodeProperties(this);return t.outputNode?t.outputNode.getNodeType(e):this.nodeType}getShared(e){const t=this.getHash(e);return e.getNodeFromHash(t)||this}setup(e){const t=e.getNodeProperties(this);for(const e of this.getChildren())t["_node"+e.id]=e;return null}construct(e){return console.warn("THREE.Node: construct() is deprecated. Use setup() instead."),this.setup(e)}analyze(e){const t=e.getDataFromNode(this);if(t.dependenciesCount=void 0===t.dependenciesCount?1:t.dependenciesCount+1,1===t.dependenciesCount){const t=e.getNodeProperties(this);for(const s of Object.values(t))s&&!0===s.isNode&&s.build(e)}}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);if(s&&!0===s.isNode)return s.build(e,t)}updateBefore(){console.warn("Abstract function.")}update(){console.warn("Abstract function.")}build(e,t=null){const s=this.getShared(e);if(this!==s)return s.build(e,t);e.addNode(this),e.addChain(this);let o=null;const i=e.getBuildStage();if("setup"===i){const t=e.getNodeProperties(this);if(!0!==t.initialized||!1===e.context.tempRead){const s=e.stack.nodes.length;t.initialized=!0,t.outputNode=this.setup(e),null!==t.outputNode&&e.stack.nodes.length!==s&&(t.outputNode=e.stack);for(const s of Object.values(t))s&&!0===s.isNode&&s.build(e)}}else if("analyze"===i)this.analyze(e);else if("generate"===i){if(1===this.generate.length){const s=this.getNodeType(e),i=e.getDataFromNode(this);o=i.snippet,void 0===o&&(o=this.generate(e)||"",i.snippet=o),o=e.format(o,s,t)}else o=this.generate(e,t)||""}return e.removeChain(this),o}getSerializeChildren(){return getNodeChildren(this)}serialize(e){const t=this.getSerializeChildren(),s={};for(const{property:o,index:i,childNode:n}of t)void 0!==i?(void 0===s[o]&&(s[o]=Number.isInteger(i)?[]:{}),s[o][i]=n.toJSON(e.meta).uuid):s[o]=n.toJSON(e.meta).uuid;Object.keys(s).length>0&&(e.inputNodes=s)}deserialize(e){if(void 0!==e.inputNodes){const t=e.meta.nodes;for(const s in e.inputNodes)if(Array.isArray(e.inputNodes[s])){const o=[];for(const i of e.inputNodes[s])o.push(t[i]);this[s]=o}else if("object"==typeof e.inputNodes[s]){const o={};for(const i in e.inputNodes[s]){const n=e.inputNodes[s][i];o[i]=t[n]}this[s]=o}else{const o=e.inputNodes[s];this[s]=t[o]}}}toJSON(e){const{uuid:t,type:s}=this,o=void 0===e||"string"==typeof e;o&&(e={textures:{},images:{},nodes:{}});let i=e.nodes[t];function n(e){const t=[];for(const s in e){const o=e[s];delete o.metadata,t.push(o)}return t}if(void 0===i&&(i={uuid:t,type:s,meta:e,metadata:{version:4.6,type:"Node",generator:"Node.toJSON"}},!0!==o&&(e.nodes[i.uuid]=i),this.serialize(i),delete i.meta),o){const t=n(e.textures),s=n(e.images),o=n(e.nodes);t.length>0&&(i.textures=t),s.length>0&&(i.images=s),o.length>0&&(i.nodes=o)}return i}}export default Node;export function addNodeClass(e,t){if("function"!=typeof t||!e)throw new Error(`Node class ${e} is not a class`);NodeClasses.has(e)?console.warn(`Redefinition of node class ${e}`):(NodeClasses.set(e,t),t.type=e)}export function createNodeFromType(e){const t=NodeClasses.get(e);if(void 0!==t)return new t}
//# sourceMappingURL=/sm/40540ca961bf8bf16d3dd4d5c0045dbdee2bc7ba996d59f50bb88a3a3a3065ff.map