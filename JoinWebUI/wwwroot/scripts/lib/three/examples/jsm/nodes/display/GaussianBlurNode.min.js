/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/nodes/display/GaussianBlurNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import TempNode from"../core/TempNode.js";import{nodeObject,addNodeElement,tslFn,float,vec2,vec3,vec4}from"../shadernode/ShaderNode.js";import{NodeUpdateType}from"../core/constants.js";import{mul}from"../math/OperatorNode.js";import{uv}from"../accessors/UVNode.js";import{texture}from"../accessors/TextureNode.js";import{uniform}from"../core/UniformNode.js";import{Vector2,RenderTarget}from"three";import QuadMesh from"../../objects/QuadMesh.js";const quadMesh=new QuadMesh;class GaussianBlurNode extends TempNode{constructor(e,t=2){super(e),this.textureNode=e,this.sigma=t,this.directionNode=vec2(1),this._invSize=uniform(new Vector2),this._passDirection=uniform(new Vector2),this._horizontalRT=new RenderTarget,this._verticalRT=new RenderTarget,this.updateBeforeType=NodeUpdateType.RENDER,this.resolution=new Vector2(1,1)}setSize(e,t){e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._invSize.value.set(1/e,1/t),this._horizontalRT.setSize(e,t),this._verticalRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e,r=this.textureNode,s=r.value,o=t.getRenderTarget(),i=r.value;quadMesh.material=this._material,this.setSize(s.image.width,s.image.height),t.setRenderTarget(this._horizontalRT),this._passDirection.value.set(1,0),quadMesh.render(t),r.value=this._horizontalRT.texture,t.setRenderTarget(this._verticalRT),this._passDirection.value.set(0,1),quadMesh.render(t),t.setRenderTarget(o),r.value=i}setup(e){const t=this.textureNode;if(!0!==t.isTextureNode)return console.error("GaussianBlurNode requires a TextureNode."),vec4();const r=t.uvNode||uv(),s=e=>t.cache().context({getUV:()=>e,forceUVContext:!0}),o=tslFn((()=>{const e=3+2*this.sigma,t=this._getCoefficients(e),o=this._invSize,i=vec2(this.directionNode).mul(this._passDirection),a=float(t[0]).toVar(),n=vec3(s(r).mul(a)).toVar();for(let d=1;d<e;d++){const e=float(d),u=float(t[d]),h=vec2(i.mul(o.mul(e))).toVar(),c=vec3(s(r.add(h))),l=vec3(s(r.sub(h)));n.addAssign(c.add(l).mul(u)),a.addAssign(mul(2,u))}return vec4(n.div(a),1)}));(this._material||(this._material=e.createNodeMaterial("MeshBasicNodeMaterial"))).fragmentNode=o();return e.getNodeProperties(this).textureNode=t,texture(this._verticalRT.texture)}_getCoefficients(e){const t=[];for(let r=0;r<e;r++)t.push(.39894*Math.exp(-.5*r*r/(e*e))/e);return t}}export const gaussianBlur=(e,t)=>nodeObject(new GaussianBlurNode(nodeObject(e),t));addNodeElement("gaussianBlur",gaussianBlur);export default GaussianBlurNode;
//# sourceMappingURL=/sm/b49b65dd6ae84ccbc085297342745edef150b77d922f658b52c74e46f0308663.map