/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/nodes/shadernode/ShaderNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Node,{addNodeClass}from"../core/Node.js";import ArrayElementNode from"../utils/ArrayElementNode.js";import ConvertNode from"../utils/ConvertNode.js";import JoinNode from"../utils/JoinNode.js";import SplitNode from"../utils/SplitNode.js";import SetNode from"../utils/SetNode.js";import ConstNode from"../core/ConstNode.js";import{getValueFromType,getValueType}from"../core/NodeUtils.js";let currentStack=null;const NodeElements=new Map;export function addNodeElement(e,t){if(NodeElements.has(e))console.warn(`Redefinition of node element ${e}`);else{if("function"!=typeof t)throw new Error(`Node element ${e} is not a function`);NodeElements.set(e,t)}}const parseSwizzle=e=>e.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),shaderNodeHandler={setup(e,t){const o=t.shift();return e(nodeObjects(o),...t)},get(e,t,o){if("string"==typeof t&&void 0===e[t]){if(!0!==e.isStackNode&&"assign"===t)return(...e)=>(currentStack.assign(o,...e),o);if(NodeElements.has(t)){const n=NodeElements.get(t);return e.isStackNode?(...e)=>o.add(n(...e)):(...e)=>n(o,...e)}if("self"===t)return e;if(t.endsWith("Assign")&&NodeElements.has(t.slice(0,t.length-6))){const n=NodeElements.get(t.slice(0,t.length-6));return e.isStackNode?(...e)=>o.assign(e[0],n(...e)):(...e)=>o.assign(n(o,...e))}if(!0===/^[xyzwrgbastpq]{1,4}$/.test(t))return t=parseSwizzle(t),nodeObject(new SplitNode(o,t));if(!0===/^set[XYZWRGBASTPQ]{1,4}$/.test(t))return t=(t=parseSwizzle(t.slice(3).toLowerCase())).split("").sort().join(""),o=>nodeObject(new SetNode(e,t,o));if("width"===t||"height"===t||"depth"===t)return"width"===t?t="x":"height"===t?t="y":"depth"===t&&(t="z"),nodeObject(new SplitNode(e,t));if(!0===/^\d+$/.test(t))return nodeObject(new ArrayElementNode(o,new ConstNode(Number(t),"uint")))}return Reflect.get(e,t,o)},set:(e,t,o,n)=>"string"!=typeof t||void 0!==e[t]||!0!==/^[xyzwrgbastpq]{1,4}$/.test(t)&&"width"!==t&&"height"!==t&&"depth"!==t&&!0!==/^\d+$/.test(t)?Reflect.set(e,t,o,n):(n[t].assign(o),!0)},nodeObjectsCacheMap=new WeakMap,nodeBuilderFunctionsCacheMap=new WeakMap,ShaderNodeObject=function(e,t=null){const o=getValueType(e);if("node"===o){let t=nodeObjectsCacheMap.get(e);return void 0===t&&(t=new Proxy(e,shaderNodeHandler),nodeObjectsCacheMap.set(e,t),nodeObjectsCacheMap.set(t,t)),t}return null===t&&("float"===o||"boolean"===o)||o&&"shader"!==o&&"string"!==o?nodeObject(getConstNode(e,t)):"shader"===o?tslFn(e):e},ShaderNodeObjects=function(e,t=null){for(const o in e)e[o]=nodeObject(e[o],t);return e},ShaderNodeArray=function(e,t=null){const o=e.length;for(let n=0;n<o;n++)e[n]=nodeObject(e[n],t);return e},ShaderNodeProxy=function(e,t=null,o=null,n=null){const r=e=>nodeObject(null!==n?Object.assign(e,n):e);return null===t?(...t)=>r(new e(...nodeArray(t))):null!==o?(o=nodeObject(o),(...n)=>r(new e(t,...nodeArray(n),o))):(...o)=>r(new e(t,...nodeArray(o)))},ShaderNodeImmutable=function(e,...t){return nodeObject(new e(...nodeArray(t)))};class ShaderCallNodeInternal extends Node{constructor(e,t){super(),this.shaderNode=e,this.inputNodes=t}getNodeType(e){const{outputNode:t}=e.getNodeProperties(this);return t?t.getNodeType(e):super.getNodeType(e)}call(e){const{shaderNode:t,inputNodes:o}=this;if(t.layout){let n=nodeBuilderFunctionsCacheMap.get(e.constructor);void 0===n&&(n=new WeakMap,nodeBuilderFunctionsCacheMap.set(e.constructor,n));let r=n.get(t);return void 0===r&&(r=nodeObject(e.buildFunctionNode(t)),n.set(t,r)),null!==e.currentFunctionNode&&e.currentFunctionNode.includes.push(r),nodeObject(r.call(o))}const n=t.jsFunc,r=null!==o?n(o,e.stack,e):n(e.stack,e);return nodeObject(r)}setup(e){return e.addStack(),e.stack.outputNode=this.call(e),e.removeStack()}generate(e,t){const{outputNode:o}=e.getNodeProperties(this);return null===o?this.call(e).build(e,t):super.generate(e,t)}}class ShaderNodeInternal extends Node{constructor(e){super(),this.jsFunc=e,this.layout=null}get isArrayInput(){return/^\(\s+?\[/.test(this.jsFunc.toString())}setLayout(e){return this.layout=e,this}call(e=null){return nodeObjects(e),nodeObject(new ShaderCallNodeInternal(this,e))}setup(){return this.call()}}const bools=[!1,!0],uints=[0,1,2,3],ints=[-1,-2],floats=[.5,1.5,1/3,1e-6,1e6,Math.PI,2*Math.PI,1/Math.PI,2/Math.PI,1/(2*Math.PI),Math.PI/2],boolsCacheMap=new Map;for(const e of bools)boolsCacheMap.set(e,new ConstNode(e));const uintsCacheMap=new Map;for(const t of uints)uintsCacheMap.set(t,new ConstNode(t,"uint"));const intsCacheMap=new Map([...uintsCacheMap].map((e=>new ConstNode(e.value,"int"))));for(const o of ints)intsCacheMap.set(o,new ConstNode(o,"int"));const floatsCacheMap=new Map([...intsCacheMap].map((e=>new ConstNode(e.value))));for(const n of floats)floatsCacheMap.set(n,new ConstNode(n));for(const r of floats)floatsCacheMap.set(-r,new ConstNode(-r));const cacheMaps={bool:boolsCacheMap,uint:uintsCacheMap,ints:intsCacheMap,float:floatsCacheMap},constNodesCacheMap=new Map([...boolsCacheMap,...floatsCacheMap]),getConstNode=(e,t)=>constNodesCacheMap.has(e)?constNodesCacheMap.get(e):!0===e.isNode?e:new ConstNode(e,t),safeGetNodeType=e=>{try{return e.getNodeType()}catch(e){return}},ConvertType=function(e,t=null){return(...o)=>{if((0===o.length||!["bool","float","int","uint"].includes(e)&&o.every((e=>"object"!=typeof e)))&&(o=[getValueFromType(e,...o)]),1===o.length&&null!==t&&t.has(o[0]))return nodeObject(t.get(o[0]));if(1===o.length){const t=getConstNode(o[0],e);return safeGetNodeType(t)===e?nodeObject(t):nodeObject(new ConvertNode(t,e))}const n=o.map((e=>getConstNode(e)));return nodeObject(new JoinNode(n,e))}};export const getConstNodeType=e=>null!=e?e.nodeType||e.convertTo||("string"==typeof e?e:null):null;export function ShaderNode(e){return new Proxy(new ShaderNodeInternal(e),shaderNodeHandler)}export const nodeObject=(e,t=null)=>ShaderNodeObject(e,t);export const nodeObjects=(e,t=null)=>new ShaderNodeObjects(e,t);export const nodeArray=(e,t=null)=>new ShaderNodeArray(e,t);export const nodeProxy=(...e)=>new ShaderNodeProxy(...e);export const nodeImmutable=(...e)=>new ShaderNodeImmutable(...e);export const shader=e=>(console.warn("TSL: shader() is deprecated. Use tslFn() instead."),new ShaderNode(e));export const tslFn=e=>{const t=new ShaderNode(e),o=(...e)=>{let o;return nodeObjects(e),o=e[0]&&e[0].isNode?[...e]:e[0],t.call(o)};return o.shaderNode=t,o.setLayout=e=>(t.setLayout(e),o),o};addNodeClass("ShaderNode",ShaderNode);export const setCurrentStack=e=>{currentStack=e};export const getCurrentStack=()=>currentStack;export const If=(...e)=>currentStack.if(...e);export function append(e){return currentStack&&currentStack.add(e),e}addNodeElement("append",append);export const color=new ConvertType("color");export const float=new ConvertType("float",cacheMaps.float);export const int=new ConvertType("int",cacheMaps.int);export const uint=new ConvertType("uint",cacheMaps.uint);export const bool=new ConvertType("bool",cacheMaps.bool);export const vec2=new ConvertType("vec2");export const ivec2=new ConvertType("ivec2");export const uvec2=new ConvertType("uvec2");export const bvec2=new ConvertType("bvec2");export const vec3=new ConvertType("vec3");export const ivec3=new ConvertType("ivec3");export const uvec3=new ConvertType("uvec3");export const bvec3=new ConvertType("bvec3");export const vec4=new ConvertType("vec4");export const ivec4=new ConvertType("ivec4");export const uvec4=new ConvertType("uvec4");export const bvec4=new ConvertType("bvec4");export const mat3=new ConvertType("mat3");export const imat3=new ConvertType("imat3");export const umat3=new ConvertType("umat3");export const bmat3=new ConvertType("bmat3");export const mat4=new ConvertType("mat4");export const imat4=new ConvertType("imat4");export const umat4=new ConvertType("umat4");export const bmat4=new ConvertType("bmat4");export const string=(e="")=>nodeObject(new ConstNode(e,"string"));export const arrayBuffer=e=>nodeObject(new ConstNode(e,"ArrayBuffer"));addNodeElement("color",color),addNodeElement("float",float),addNodeElement("int",int),addNodeElement("uint",uint),addNodeElement("bool",bool),addNodeElement("vec2",vec2),addNodeElement("ivec2",ivec2),addNodeElement("uvec2",uvec2),addNodeElement("bvec2",bvec2),addNodeElement("vec3",vec3),addNodeElement("ivec3",ivec3),addNodeElement("uvec3",uvec3),addNodeElement("bvec3",bvec3),addNodeElement("vec4",vec4),addNodeElement("ivec4",ivec4),addNodeElement("uvec4",uvec4),addNodeElement("bvec4",bvec4),addNodeElement("mat3",mat3),addNodeElement("imat3",imat3),addNodeElement("umat3",umat3),addNodeElement("bmat3",bmat3),addNodeElement("mat4",mat4),addNodeElement("imat4",imat4),addNodeElement("umat4",umat4),addNodeElement("bmat4",bmat4),addNodeElement("string",string),addNodeElement("arrayBuffer",arrayBuffer);export const element=nodeProxy(ArrayElementNode);export const convert=(e,t)=>nodeObject(new ConvertNode(nodeObject(e),t));export const split=(e,t)=>nodeObject(new SplitNode(nodeObject(e),t));addNodeElement("element",element),addNodeElement("convert",convert);
//# sourceMappingURL=/sm/078f60f17c957746a44a0202bf37c2392b9b22fcd5849bb8575aaecf7314ac88.map