/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/exporters/USDZExporter.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{NoColorSpace,DoubleSide,Color}from"three";import{strToU8,zipSync}from"../libs/fflate.module.js";class USDZExporter{constructor(){this.textureUtils=null}setTextureUtils(t){this.textureUtils=t}parse(t,e,n,o){this.parseAsync(t,o).then(e).catch(n)}async parseAsync(t,e={}){e=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}},includeAnchoringProperties:!0,quickLookCompatible:!1,maxTextureSize:1024},e);const n={},o="model.usda";n[o]=null;let r=buildHeader();r+=buildSceneStart(e);const i={},a={};t.traverseVisible((t=>{if(t.isMesh){const e=t.geometry,o=t.material;if(o.isMeshStandardMaterial){const a="geometries/Geometry_"+e.id+".usda";if(!(a in n)){const t=buildMeshObject(e);n[a]=buildUSDFileAsString(t)}o.uuid in i||(i[o.uuid]=o),r+=buildXform(t,e,o)}else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",t)}else t.isCamera&&(r+=buildCamera(t))})),r+=buildSceneEnd(),r+=buildMaterials(i,a,e.quickLookCompatible),n[o]=strToU8(r),r=null;for(const t in a){let o=a[t];if(!0===o.isCompressedTexture){if(null===this.textureUtils)throw new Error("THREE.USDZExporter: setTextureUtils() must be called to process compressed textures.");o=await this.textureUtils.decompress(o)}const r=imageToCanvas(o.image,o.flipY,e.maxTextureSize),i=await new Promise((t=>r.toBlob(t,"image/png",1)));n[`textures/Texture_${t}.png`]=new Uint8Array(await i.arrayBuffer())}let s=0;for(const t in n){const e=n[t];s+=34+t.length;const o=63&s;if(4!==o){const r=new Uint8Array(64-o);n[t]=[e,{extra:{12345:r}}]}s=e.length}return zipSync(n,{level:0})}}function imageToCanvas(t,e,n){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const o=n/Math.max(t.width,t.height),r=document.createElement("canvas");r.width=t.width*Math.min(1,o),r.height=t.height*Math.min(1,o);const i=r.getContext("2d");return!0===e&&(i.translate(0,r.height),i.scale(1,-1)),i.drawImage(t,0,0,r.width,r.height),r}throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")}const PRECISION=7;function buildHeader(){return'#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = "Three.js USDZExporter"\n\t}\n\tdefaultPrim = "Root"\n\tmetersPerUnit = 1\n\tupAxis = "Y"\n)\n\n'}function buildSceneStart(t){return`def Xform "Root"\n{\n\tdef Scope "Scenes" (\n\t\tkind = "sceneLibrary"\n\t)\n\t{\n\t\tdef Xform "Scene" (\n\t\t\tcustomData = {\n\t\t\t\tbool preliminary_collidesWithEnvironment = 0\n\t\t\t\tstring sceneName = "Scene"\n\t\t\t}\n\t\t\tsceneName = "Scene"\n\t\t)\n\t\t{${!0===t.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${t.ar.anchoring.type}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${t.ar.planeAnchoring.alignment}"\n\t`:""}\n`}function buildSceneEnd(){return"\n\t\t}\n\t}\n}\n\n"}function buildUSDFileAsString(t){let e=buildHeader();return e+=t,strToU8(e)}function buildXform(t,e,n){const o="Object_"+t.id,r=buildMatrix(t.matrixWorld);return t.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t),`def Xform "${o}" (\n\tprepend references = @./geometries/Geometry_${e.id}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${r}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\trel material:binding = </Materials/Material_${n.id}>\n}\n\n`}function buildMatrix(t){const e=t.elements;return`( ${buildMatrixRow(e,0)}, ${buildMatrixRow(e,4)}, ${buildMatrixRow(e,8)}, ${buildMatrixRow(e,12)} )`}function buildMatrixRow(t,e){return`(${t[e+0]}, ${t[e+1]}, ${t[e+2]}, ${t[e+3]})`}function buildMeshObject(t){return`\ndef "Geometry"\n{\n${buildMesh(t)}\n}\n`}function buildMesh(t){const e=t.attributes,n=e.position.count;return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${buildMeshVertexCount(t)}]\n\t\tint[] faceVertexIndices = [${buildMeshVertexIndices(t)}]\n\t\tnormal3f[] normals = [${buildVector3Array(e.normal,n)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${buildVector3Array(e.position,n)}]\n${buildPrimvars(e)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function buildMeshVertexCount(t){const e=null!==t.index?t.index.count:t.attributes.position.count;return Array(e/3).fill(3).join(", ")}function buildMeshVertexIndices(t){const e=t.index,n=[];if(null!==e)for(let t=0;t<e.count;t++)n.push(e.getX(t));else{const e=t.attributes.position.count;for(let t=0;t<e;t++)n.push(t)}return n.join(", ")}function buildVector3Array(t,e){if(void 0===t)return console.warn("USDZExporter: Normals missing."),Array(e).fill("(0, 0, 0)").join(", ");const n=[];for(let e=0;e<t.count;e++){const o=t.getX(e),r=t.getY(e),i=t.getZ(e);n.push(`(${o.toPrecision(PRECISION)}, ${r.toPrecision(PRECISION)}, ${i.toPrecision(PRECISION)})`)}return n.join(", ")}function buildVector2Array(t){const e=[];for(let n=0;n<t.count;n++){const o=t.getX(n),r=t.getY(n);e.push(`(${o.toPrecision(PRECISION)}, ${1-r.toPrecision(PRECISION)})`)}return e.join(", ")}function buildPrimvars(t){let e="";for(let n=0;n<4;n++){const o=n>0?n:"",r=t["uv"+o];void 0!==r&&(e+=`\n\t\ttexCoord2f[] primvars:st${o} = [${buildVector2Array(r)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const n=t.color;if(void 0!==n){e+=`\n\tcolor3f[] primvars:displayColor = [${buildVector3Array(n,n.count)}] (\n\t\tinterpolation = "vertex"\n\t\t)`}return e}function buildMaterials(t,e,n=!1){const o=[];for(const r in t){const i=t[r];o.push(buildMaterial(i,e,n))}return`def "Materials"\n{\n${o.join("")}\n}\n\n`}function buildMaterial(t,e,n=!1){const o="\t\t\t",r=[],i=[];function a(o,r,i){const a=o.source.id+"_"+o.flipY;e[a]=o;const s=o.channel>0?"st"+o.channel:"st",l={1e3:"repeat",1001:"clamp",1002:"mirror"},u=o.repeat.clone(),c=o.offset.clone(),p=o.rotation,d=Math.sin(p),f=Math.cos(p);return c.y=1-c.y-u.y,n?(c.x=c.x/u.x,c.y=c.y/u.y,c.x+=d/u.x,c.y+=f-1):(c.x+=d*u.x,c.y+=(1-f)*u.y),`\n\t\tdef Shader "PrimvarReader_${r}"\n\t\t{\n\t\t\tuniform token info:id = "UsdPrimvarReader_float2"\n\t\t\tfloat2 inputs:fallback = (0.0, 0.0)\n\t\t\ttoken inputs:varname = "${s}"\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader "Transform2d_${r}"\n\t\t{\n\t\t\tuniform token info:id = "UsdTransform2d"\n\t\t\ttoken inputs:in.connect = </Materials/Material_${t.id}/PrimvarReader_${r}.outputs:result>\n\t\t\tfloat inputs:rotation = ${(p*(180/Math.PI)).toFixed(PRECISION)}\n\t\t\tfloat2 inputs:scale = ${buildVector2(u)}\n\t\t\tfloat2 inputs:translation = ${buildVector2(c)}\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader "Texture_${o.id}_${r}"\n\t\t{\n\t\t\tuniform token info:id = "UsdUVTexture"\n\t\t\tasset inputs:file = @textures/Texture_${a}.png@\n\t\t\tfloat2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${r}.outputs:result>\n\t\t\t${void 0!==i?"float4 inputs:scale = "+buildColor4(i):""}\n\t\t\ttoken inputs:sourceColorSpace = "${o.colorSpace===NoColorSpace?"raw":"sRGB"}"\n\t\t\ttoken inputs:wrapS = "${l[o.wrapS]}"\n\t\t\ttoken inputs:wrapT = "${l[o.wrapT]}"\n\t\t\tfloat outputs:r\n\t\t\tfloat outputs:g\n\t\t\tfloat outputs:b\n\t\t\tfloat3 outputs:rgb\n\t\t\t${t.transparent||t.alphaTest>0?"float outputs:a":""}\n\t\t}`}return t.side===DoubleSide&&console.warn("THREE.USDZExporter: USDZ does not support double sided materials",t),null!==t.map?(r.push(`${o}color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`),t.transparent?r.push(`${o}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`):t.alphaTest>0&&(r.push(`${o}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),r.push(`${o}float inputs:opacityThreshold = ${t.alphaTest}`)),i.push(a(t.map,"diffuse",t.color))):r.push(`${o}color3f inputs:diffuseColor = ${buildColor(t.color)}`),null!==t.emissiveMap?(r.push(`${o}color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`),i.push(a(t.emissiveMap,"emissive",new Color(t.emissive.r*t.emissiveIntensity,t.emissive.g*t.emissiveIntensity,t.emissive.b*t.emissiveIntensity)))):t.emissive.getHex()>0&&r.push(`${o}color3f inputs:emissiveColor = ${buildColor(t.emissive)}`),null!==t.normalMap&&(r.push(`${o}normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`),i.push(a(t.normalMap,"normal"))),null!==t.aoMap&&(r.push(`${o}float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`),i.push(a(t.aoMap,"occlusion",new Color(t.aoMapIntensity,t.aoMapIntensity,t.aoMapIntensity)))),null!==t.roughnessMap?(r.push(`${o}float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`),i.push(a(t.roughnessMap,"roughness",new Color(t.roughness,t.roughness,t.roughness)))):r.push(`${o}float inputs:roughness = ${t.roughness}`),null!==t.metalnessMap?(r.push(`${o}float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`),i.push(a(t.metalnessMap,"metallic",new Color(t.metalness,t.metalness,t.metalness)))):r.push(`${o}float inputs:metallic = ${t.metalness}`),null!==t.alphaMap?(r.push(`${o}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`),r.push(`${o}float inputs:opacityThreshold = 0.0001`),i.push(a(t.alphaMap,"opacity"))):r.push(`${o}float inputs:opacity = ${t.opacity}`),t.isMeshPhysicalMaterial&&(null!==t.clearcoatMap?(r.push(`${o}float inputs:clearcoat.connect = </Materials/Material_${t.id}/Texture_${t.clearcoatMap.id}_clearcoat.outputs:r>`),i.push(a(t.clearcoatMap,"clearcoat",new Color(t.clearcoat,t.clearcoat,t.clearcoat)))):r.push(`${o}float inputs:clearcoat = ${t.clearcoat}`),null!==t.clearcoatRoughnessMap?(r.push(`${o}float inputs:clearcoatRoughness.connect = </Materials/Material_${t.id}/Texture_${t.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>`),i.push(a(t.clearcoatRoughnessMap,"clearcoatRoughness",new Color(t.clearcoatRoughness,t.clearcoatRoughness,t.clearcoatRoughness)))):r.push(`${o}float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`),r.push(`${o}float inputs:ior = ${t.ior}`)),`\n\tdef Material "Material_${t.id}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${r.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n\n${i.join("\n")}\n\n\t}\n`}function buildColor(t){return`(${t.r}, ${t.g}, ${t.b})`}function buildColor4(t){return`(${t.r}, ${t.g}, ${t.b}, 1.0)`}function buildVector2(t){return`(${t.x}, ${t.y})`}function buildCamera(t){const e=t.name?t.name:"Camera_"+t.id,n=buildMatrix(t.matrixWorld);return t.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t),t.isOrthographicCamera?`def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${n}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(PRECISION)}, ${t.far.toPrecision(PRECISION)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(t.left)+Math.abs(t.right))).toPrecision(PRECISION)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(t.top)+Math.abs(t.bottom))).toPrecision(PRECISION)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`:`def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${n}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(PRECISION)}, ${t.far.toPrecision(PRECISION)})\n\t\t\tfloat focalLength = ${t.getFocalLength().toPrecision(PRECISION)}\n\t\t\tfloat focusDistance = ${t.focus.toPrecision(PRECISION)}\n\t\t\tfloat horizontalAperture = ${t.getFilmWidth().toPrecision(PRECISION)}\n\t\t\ttoken projection = "perspective"\n\t\t\tfloat verticalAperture = ${t.getFilmHeight().toPrecision(PRECISION)}\n\t\t}\n\t\n\t`}export{USDZExporter};
//# sourceMappingURL=/sm/dee39e54652a8c3c9e670c9e18d5f07640d0b518066edd6c90acf79f1c6671af.map