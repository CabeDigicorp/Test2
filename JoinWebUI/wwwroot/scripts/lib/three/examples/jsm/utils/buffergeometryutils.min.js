/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/utils/BufferGeometryUtils.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{BufferAttribute,BufferGeometry,Float32BufferAttribute,InstancedBufferAttribute,InterleavedBuffer,InterleavedBufferAttribute,TriangleFanDrawMode,TriangleStripDrawMode,TrianglesDrawMode,Vector3}from"three";function computeMikkTSpaceTangents(t,e,r=!0){if(!e||!e.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!t.hasAttribute("position")||!t.hasAttribute("normal")||!t.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function o(t){if(t.normalized||t.isInterleavedBufferAttribute){const e=new Float32Array(t.count*t.itemSize);for(let r=0,o=0;r<t.count;r++)e[o++]=t.getX(r),e[o++]=t.getY(r),t.itemSize>2&&(e[o++]=t.getZ(r));return e}return t.array instanceof Float32Array?t.array:new Float32Array(t.array)}const n=t.index?t.toNonIndexed():t,i=e.generateTangents(o(n.attributes.position),o(n.attributes.normal),o(n.attributes.uv));if(r)for(let t=3;t<i.length;t+=4)i[t]*=-1;return n.setAttribute("tangent",new BufferAttribute(i,4)),t!==n&&t.copy(n),t}function mergeGeometries(t,e=!1){const r=null!==t[0].index,o=new Set(Object.keys(t[0].attributes)),n=new Set(Object.keys(t[0].morphAttributes)),i={},s={},u=t[0].morphTargetsRelative,a=new BufferGeometry;let l=0;for(let f=0;f<t.length;++f){const c=t[f];let m=0;if(r!==(null!==c.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+f+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const t in c.attributes){if(!o.has(t))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+f+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.'),null;void 0===i[t]&&(i[t]=[]),i[t].push(c.attributes[t]),m++}if(m!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+f+". Make sure all geometries have the same number of attributes."),null;if(u!==c.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+f+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const t in c.morphAttributes){if(!n.has(t))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+f+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===s[t]&&(s[t]=[]),s[t].push(c.morphAttributes[t])}if(e){let t;if(r)t=c.index.count;else{if(void 0===c.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+f+". The geometry must have either an index or a position attribute"),null;t=c.attributes.position.count}a.addGroup(l,t,f),l+=t}}if(r){let e=0;const r=[];for(let o=0;o<t.length;++o){const n=t[o].index;for(let t=0;t<n.count;++t)r.push(n.getX(t)+e);e+=t[o].attributes.position.count}a.setIndex(r)}for(const t in i){const e=mergeAttributes(i[t]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" attribute."),null;a.setAttribute(t,e)}for(const t in s){const e=s[t][0].length;if(0===e)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[t]=[];for(let r=0;r<e;++r){const e=[];for(let o=0;o<s[t].length;++o)e.push(s[t][o][r]);const o=mergeAttributes(e);if(!o)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" morphAttribute."),null;a.morphAttributes[t].push(o)}}return a}function mergeAttributes(t){let e,r,o,n=-1,i=0;for(let s=0;s<t.length;++s){const u=t[s];if(void 0===e&&(e=u.array.constructor),e!==u.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=u.itemSize),r!==u.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=u.normalized),o!==u.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(-1===n&&(n=u.gpuType),n!==u.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;i+=u.count*r}const s=new e(i),u=new BufferAttribute(s,r,o);let a=0;for(let e=0;e<t.length;++e){const o=t[e];if(o.isInterleavedBufferAttribute){const t=a/r;for(let e=0,n=o.count;e<n;e++)for(let n=0;n<r;n++){const r=o.getComponent(e,n);u.setComponent(e+t,n,r)}}else s.set(o.array,a);a+=o.count*r}return void 0!==n&&(u.gpuType=n),u}export function deepCloneAttribute(t){return t.isInstancedInterleavedBufferAttribute||t.isInterleavedBufferAttribute?deinterleaveAttribute(t):t.isInstancedBufferAttribute?(new InstancedBufferAttribute).copy(t):(new BufferAttribute).copy(t)}function interleaveAttributes(t){let e,r=0,o=0;for(let n=0,i=t.length;n<i;++n){const i=t[n];if(void 0===e&&(e=i.array.constructor),e!==i.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;r+=i.array.length,o+=i.itemSize}const n=new InterleavedBuffer(new e(r),o);let i=0;const s=[],u=["getX","getY","getZ","getW"],a=["setX","setY","setZ","setW"];for(let e=0,r=t.length;e<r;e++){const r=t[e],o=r.itemSize,l=r.count,f=new InterleavedBufferAttribute(n,o,i,r.normalized);s.push(f),i+=o;for(let t=0;t<l;t++)for(let e=0;e<o;e++)f[a[e]](t,r[u[e]](t))}return s}export function deinterleaveAttribute(t){const e=t.data.array.constructor,r=t.count,o=t.itemSize,n=t.normalized,i=new e(r*o);let s;s=t.isInstancedInterleavedBufferAttribute?new InstancedBufferAttribute(i,o,n,t.meshPerAttribute):new BufferAttribute(i,o,n);for(let e=0;e<r;e++)s.setX(e,t.getX(e)),o>=2&&s.setY(e,t.getY(e)),o>=3&&s.setZ(e,t.getZ(e)),o>=4&&s.setW(e,t.getW(e));return s}export function deinterleaveGeometry(t){const e=t.attributes,r=t.morphTargets,o=new Map;for(const t in e){const r=e[t];r.isInterleavedBufferAttribute&&(o.has(r)||o.set(r,deinterleaveAttribute(r)),e[t]=o.get(r))}for(const t in r){const e=r[t];e.isInterleavedBufferAttribute&&(o.has(e)||o.set(e,deinterleaveAttribute(e)),r[t]=o.get(e))}}function estimateBytesUsed(t){let e=0;for(const r in t.attributes){const o=t.getAttribute(r);e+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}const r=t.getIndex();return e+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,e}function mergeVertices(t,e=1e-4){e=Math.max(e,Number.EPSILON);const r={},o=t.getIndex(),n=t.getAttribute("position"),i=o?o.count:n.count;let s=0;const u=Object.keys(t.attributes),a={},l={},f=[],c=["getX","getY","getZ","getW"],m=["setX","setY","setZ","setW"];for(let e=0,r=u.length;e<r;e++){const r=u[e],o=t.attributes[r];a[r]=new o.constructor(new o.array.constructor(o.count*o.itemSize),o.itemSize,o.normalized);const n=t.morphAttributes[r];n&&(l[r]||(l[r]=[]),n.forEach(((t,e)=>{const o=new t.array.constructor(t.count*t.itemSize);l[r][e]=new t.constructor(o,t.itemSize,t.normalized)})))}const g=.5*e,d=Math.log10(1/e),b=Math.pow(10,d),h=g*b;for(let e=0;e<i;e++){const n=o?o.getX(e):e;let i="";for(let e=0,r=u.length;e<r;e++){const r=u[e],o=t.getAttribute(r),s=o.itemSize;for(let t=0;t<s;t++)i+=~~(o[c[t]](n)*b+h)+","}if(i in r)f.push(r[i]);else{for(let e=0,r=u.length;e<r;e++){const r=u[e],o=t.getAttribute(r),i=t.morphAttributes[r],f=o.itemSize,g=a[r],d=l[r];for(let t=0;t<f;t++){const e=c[t],r=m[t];if(g[r](s,o[e](n)),i)for(let t=0,o=i.length;t<o;t++)d[t][r](s,i[t][e](n))}}r[i]=s,f.push(s),s++}}const p=t.clone();for(const e in t.attributes){const t=a[e];if(p.setAttribute(e,new t.constructor(t.array.slice(0,s*t.itemSize),t.itemSize,t.normalized)),e in l)for(let t=0;t<l[e].length;t++){const r=l[e][t];p.morphAttributes[e][t]=new r.constructor(r.array.slice(0,s*r.itemSize),r.itemSize,r.normalized)}}return p.setIndex(f),p}function toTrianglesDrawMode(t,e){if(e===TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(e===TriangleFanDrawMode||e===TriangleStripDrawMode){let r=t.getIndex();if(null===r){const e=[],o=t.getAttribute("position");if(void 0===o)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t;for(let t=0;t<o.count;t++)e.push(t);t.setIndex(e),r=t.getIndex()}const o=r.count-2,n=[];if(e===TriangleFanDrawMode)for(let t=1;t<=o;t++)n.push(r.getX(0)),n.push(r.getX(t)),n.push(r.getX(t+1));else for(let t=0;t<o;t++)t%2==0?(n.push(r.getX(t)),n.push(r.getX(t+1)),n.push(r.getX(t+2))):(n.push(r.getX(t+2)),n.push(r.getX(t+1)),n.push(r.getX(t)));n.length/3!==o&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=t.clone();return i.setIndex(n),i.clearGroups(),i}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),t}function computeMorphedAttributes(t){const e=new Vector3,r=new Vector3,o=new Vector3,n=new Vector3,i=new Vector3,s=new Vector3,u=new Vector3,a=new Vector3,l=new Vector3;function f(t,f,c,m,g,d,b,h){e.fromBufferAttribute(f,g),r.fromBufferAttribute(f,d),o.fromBufferAttribute(f,b);const p=t.morphTargetInfluences;if(c&&p){u.set(0,0,0),a.set(0,0,0),l.set(0,0,0);for(let t=0,f=c.length;t<f;t++){const f=p[t],h=c[t];0!==f&&(n.fromBufferAttribute(h,g),i.fromBufferAttribute(h,d),s.fromBufferAttribute(h,b),m?(u.addScaledVector(n,f),a.addScaledVector(i,f),l.addScaledVector(s,f)):(u.addScaledVector(n.sub(e),f),a.addScaledVector(i.sub(r),f),l.addScaledVector(s.sub(o),f)))}e.add(u),r.add(a),o.add(l)}t.isSkinnedMesh&&(t.applyBoneTransform(g,e),t.applyBoneTransform(d,r),t.applyBoneTransform(b,o)),h[3*g+0]=e.x,h[3*g+1]=e.y,h[3*g+2]=e.z,h[3*d+0]=r.x,h[3*d+1]=r.y,h[3*d+2]=r.z,h[3*b+0]=o.x,h[3*b+1]=o.y,h[3*b+2]=o.z}const c=t.geometry,m=t.material;let g,d,b;const h=c.index,p=c.attributes.position,A=c.morphAttributes.position,y=c.morphTargetsRelative,w=c.attributes.normal,B=c.morphAttributes.position,T=c.groups,x=c.drawRange;let E,z,I,v,S,G,M;const V=new Float32Array(p.count*p.itemSize),X=new Float32Array(w.count*w.itemSize);if(null!==h)if(Array.isArray(m))for(E=0,I=T.length;E<I;E++)for(S=T[E],G=Math.max(S.start,x.start),M=Math.min(S.start+S.count,x.start+x.count),z=G,v=M;z<v;z+=3)g=h.getX(z),d=h.getX(z+1),b=h.getX(z+2),f(t,p,A,y,g,d,b,V),f(t,w,B,y,g,d,b,X);else for(G=Math.max(0,x.start),M=Math.min(h.count,x.start+x.count),E=G,I=M;E<I;E+=3)g=h.getX(E),d=h.getX(E+1),b=h.getX(E+2),f(t,p,A,y,g,d,b,V),f(t,w,B,y,g,d,b,X);else if(Array.isArray(m))for(E=0,I=T.length;E<I;E++)for(S=T[E],G=Math.max(S.start,x.start),M=Math.min(S.start+S.count,x.start+x.count),z=G,v=M;z<v;z+=3)g=z,d=z+1,b=z+2,f(t,p,A,y,g,d,b,V),f(t,w,B,y,g,d,b,X);else for(G=Math.max(0,x.start),M=Math.min(p.count,x.start+x.count),E=G,I=M;E<I;E+=3)g=E,d=E+1,b=E+2,f(t,p,A,y,g,d,b,V),f(t,w,B,y,g,d,b,X);return{positionAttribute:p,normalAttribute:w,morphedPositionAttribute:new Float32BufferAttribute(V,3),morphedNormalAttribute:new Float32BufferAttribute(X,3)}}function mergeGroups(t){if(0===t.groups.length)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),t;let e=t.groups;if(e=e.sort(((t,e)=>t.materialIndex!==e.materialIndex?t.materialIndex-e.materialIndex:t.start-e.start)),null===t.getIndex()){const e=t.getAttribute("position"),r=[];for(let t=0;t<e.count;t+=3)r.push(t,t+1,t+2);t.setIndex(r)}const r=t.getIndex(),o=[];for(let t=0;t<e.length;t++){const n=e[t],i=n.start,s=i+n.count;for(let t=i;t<s;t++)o.push(r.getX(t))}t.dispose(),t.setIndex(o);let n=0;for(let t=0;t<e.length;t++){const r=e[t];r.start=n,n+=r.count}let i=e[0];t.groups=[i];for(let r=1;r<e.length;r++){const o=e[r];i.materialIndex===o.materialIndex?i.count+=o.count:(i=o,t.groups.push(i))}return t}function toCreasedNormals(t,e=Math.PI/3){const r=Math.cos(e),o=100*(1+1e-10),n=[new Vector3,new Vector3,new Vector3],i=new Vector3,s=new Vector3,u=new Vector3,a=new Vector3;function l(t){return`${~~(t.x*o)},${~~(t.y*o)},${~~(t.z*o)}`}const f=t.index?t.toNonIndexed():t,c=f.attributes.position,m={};for(let t=0,e=c.count/3;t<e;t++){const e=3*t,r=n[0].fromBufferAttribute(c,e+0),o=n[1].fromBufferAttribute(c,e+1),u=n[2].fromBufferAttribute(c,e+2);i.subVectors(u,o),s.subVectors(r,o);const a=(new Vector3).crossVectors(i,s).normalize();for(let t=0;t<3;t++){const e=l(n[t]);e in m||(m[e]=[]),m[e].push(a)}}const g=new Float32Array(3*c.count),d=new BufferAttribute(g,3,!1);for(let t=0,e=c.count/3;t<e;t++){const e=3*t,o=n[0].fromBufferAttribute(c,e+0),f=n[1].fromBufferAttribute(c,e+1),g=n[2].fromBufferAttribute(c,e+2);i.subVectors(g,f),s.subVectors(o,f),u.crossVectors(i,s).normalize();for(let t=0;t<3;t++){const o=m[l(n[t])];a.set(0,0,0);for(let t=0,e=o.length;t<e;t++){const e=o[t];u.dot(e)>r&&a.add(e)}a.normalize(),d.setXYZ(e+t,a.x,a.y,a.z)}}return f.setAttribute("normal",d),f}export{computeMikkTSpaceTangents,mergeGeometries,mergeAttributes,interleaveAttributes,estimateBytesUsed,mergeVertices,toTrianglesDrawMode,computeMorphedAttributes,mergeGroups,toCreasedNormals};
//# sourceMappingURL=/sm/a0e00669e735db0263b2fdae28ae12f73f5601b4dfe554339b6033ab68b25650.map