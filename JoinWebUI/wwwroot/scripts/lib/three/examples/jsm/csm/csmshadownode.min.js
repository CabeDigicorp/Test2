/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/csm/CSMShadowNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Vector2,Vector3,MathUtils,Matrix4,Box3,Object3D,WebGLCoordinateSystem}from"three";import{CSMFrustum}from"./CSMFrustum.js";import{viewZToOrthographicDepth,reference,uniform,float,vec4,vec2,If,Fn,min,renderGroup,positionView,Node,NodeUpdateType,shadow}from"three/tsl";const _cameraToLightMatrix=new Matrix4,_lightSpaceFrustum=new CSMFrustum,_center=new Vector3,_bbox=new Box3,_uniformArray=[],_logArray=[],_lightDirection=new Vector3,_lightOrientationMatrix=new Matrix4,_lightOrientationMatrixInverse=new Matrix4,_up=new Vector3(0,1,0);class LwLight extends Object3D{constructor(){super(),this.target=new Object3D}}class CSMShadowNode extends Node{constructor(t,e={}){super(),this.light=t,this.camera=null,this.cascades=e.cascades||3,this.maxFar=e.maxFar||1e5,this.mode=e.mode||"practical",this.lightMargin=e.lightMargin||200,this.customSplitsCallback=e.customSplitsCallback,this.fade=!1,this.breaks=[],this._cascades=[],this.mainFrustum=null,this.frustums=[],this.updateBeforeType=NodeUpdateType.FRAME,this.lights=[],this._shadowNodes=[]}init({camera:t,renderer:e}){this.camera=t;const a={webGL:e.coordinateSystem===WebGLCoordinateSystem};this.mainFrustum=new CSMFrustum(a);const s=this.light,r=s.parent;for(let t=0;t<this.cascades;t++){const e=new LwLight,a=s.shadow.clone();a.bias=a.bias*(t+1),this.lights.push(e),r.add(e),r.add(e.target),e.shadow=a,this._shadowNodes.push(shadow(e,a)),this._cascades.push(new Vector2)}this.updateFrustums()}initCascades(){const t=this.camera;t.updateProjectionMatrix(),this.mainFrustum.setFromProjectionMatrix(t.projectionMatrix,this.maxFar),this.mainFrustum.split(this.breaks,this.frustums)}getBreaks(){const t=this.camera,e=Math.min(t.far,this.maxFar);switch(this.breaks.length=0,this.mode){case"uniform":a(this.cascades,t.near,e,this.breaks);break;case"logarithmic":s(this.cascades,t.near,e,this.breaks);break;case"practical":!function(t,e,r,i,o){_uniformArray.length=0,_logArray.length=0,s(t,e,r,_logArray),a(t,e,r,_uniformArray);for(let e=1;e<t;e++)o.push(MathUtils.lerp(_uniformArray[e-1],_logArray[e-1],i));o.push(1)}(this.cascades,t.near,e,.5,this.breaks);break;case"custom":void 0===this.customSplitsCallback&&console.error("CSM: Custom split scheme callback not defined."),this.customSplitsCallback(this.cascades,t.near,e,this.breaks)}function a(t,e,a,s){for(let r=1;r<t;r++)s.push((e+(a-e)*r/t)/a);s.push(1)}function s(t,e,a,s){for(let r=1;r<t;r++)s.push(e*(a/e)**(r/t)/a);s.push(1)}}setLightBreaks(){for(let t=0,e=this.cascades;t<e;t++){const e=this.breaks[t],a=this.breaks[t-1]||0;this._cascades[t].set(a,e)}}updateShadowBounds(){const t=this.frustums;for(let e=0;e<t.length;e++){const t=this.lights[e].shadow.camera,a=this.frustums[e],s=a.vertices.near,r=a.vertices.far,i=r[0];let o;o=i.distanceTo(r[2])>i.distanceTo(s[2])?r[2]:s[2];let n=i.distanceTo(o);if(this.fade){const t=this.camera,e=Math.max(t.far,this.maxFar),s=a.vertices.far[0].z/(e-t.near);n+=.25*Math.pow(s,2)*(e-t.near)}t.left=-n/2,t.right=n/2,t.top=n/2,t.bottom=-n/2,t.updateProjectionMatrix()}}updateFrustums(){this.getBreaks(),this.initCascades(),this.updateShadowBounds(),this.setLightBreaks()}setupFade(){const t=reference("camera.near","float",this).setGroup(renderGroup).label("cameraNear"),e=reference("_cascades","vec2",this).setGroup(renderGroup).label("cacades"),a=uniform("float").setGroup(renderGroup).label("shadowFar").onRenderUpdate((()=>Math.min(this.maxFar,this.camera.far))),s=viewZToOrthographicDepth(positionView.z,t,a).toVar("linearDepth"),r=this.cascades-1;return Fn((()=>{const t=vec4(1,1,1,1).toVar("shadowValue"),a=vec2().toVar("cascade"),i=float().toVar("cascadeCenter"),o=float().toVar("margin"),n=float().toVar("csmX"),h=float().toVar("csmY");for(let c=0;c<this.cascades;c++){const l=c===r;a.assign(e.element(c)),i.assign(a.x.add(a.y).div(2));const u=s.lessThan(i).select(a.x,a.y);o.assign(float(.25).mul(u.pow(2))),n.assign(a.x.sub(o.div(2))),l?h.assign(a.y):h.assign(a.y.add(o.div(2)));const d=s.greaterThanEqual(n).and(s.lessThanEqual(h));If(d,(()=>{let e=min(s.sub(n),h.sub(s)).toVar().div(o).clamp(0,1);0===c&&(e=s.greaterThan(i).select(e,1)),t.subAssign(this._shadowNodes[c].oneMinus().mul(e))}))}return t}))()}setupStandard(){const t=reference("camera.near","float",this).setGroup(renderGroup).label("cameraNear"),e=reference("_cascades","vec2",this).setGroup(renderGroup).label("cacades"),a=uniform("float").setGroup(renderGroup).label("shadowFar").onRenderUpdate((()=>Math.min(this.maxFar,this.camera.far))),s=viewZToOrthographicDepth(positionView.z,t,a).toVar("linearDepth");return Fn((()=>{const t=vec4(1,1,1,1).toVar("shadowValue"),a=vec2().toVar("cascade");for(let r=0;r<this.cascades;r++)a.assign(e.element(r)),If(s.greaterThanEqual(a.x).and(s.lessThanEqual(a.y)),(()=>{t.assign(this._shadowNodes[r])}));return t}))()}setup(t){return null===this.camera&&this.init(t),!0===this.fade?this.setupFade():this.setupStandard()}updateBefore(){const t=this.light,e=this.camera,a=this.frustums;_lightDirection.subVectors(t.target.position,t.position).normalize(),_lightOrientationMatrix.lookAt(t.position,t.target.position,_up),_lightOrientationMatrixInverse.copy(_lightOrientationMatrix).invert();for(let t=0;t<a.length;t++){const s=this.lights[t],r=s.shadow,i=r.camera,o=(i.right-i.left)/r.mapSize.width,n=(i.top-i.bottom)/r.mapSize.height;_cameraToLightMatrix.multiplyMatrices(_lightOrientationMatrixInverse,e.matrixWorld),a[t].toSpace(_cameraToLightMatrix,_lightSpaceFrustum);const h=_lightSpaceFrustum.vertices.near,c=_lightSpaceFrustum.vertices.far;_bbox.makeEmpty();for(let t=0;t<4;t++)_bbox.expandByPoint(h[t]),_bbox.expandByPoint(c[t]);_bbox.getCenter(_center),_center.z=_bbox.max.z+this.lightMargin,_center.x=Math.floor(_center.x/o)*o,_center.y=Math.floor(_center.y/n)*n,_center.applyMatrix4(_lightOrientationMatrix),s.position.copy(_center),s.target.position.copy(_center),s.target.position.add(_lightDirection)}}dispose(){for(let t=0;t<this.lights.length;t++){const e=this.lights[t],a=e.parent;a.remove(e.target),a.remove(e)}}}export{CSMShadowNode};
//# sourceMappingURL=/sm/7a9772659794d7ad1a08ec8e776f3acf2308d7684ecf7ade97a187690f0935d7.map