/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/examples/jsm/modifiers/CurveModifierGPU.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const CHANNELS=4,TEXTURE_WIDTH=1024,TEXTURE_HEIGHT=4;import{DataTexture,DataUtils,RGBAFormat,HalfFloatType,RepeatWrapping,Mesh,InstancedMesh,LinearFilter}from"three";import{modelWorldMatrix,normalLocal,vec2,vec3,vec4,mat3,varyingProperty,texture,reference,Fn,select,positionLocal}from"three/tsl";export function initSplineTexture(e=1){const t=new Uint16Array(4*TEXTURE_WIDTH*e*CHANNELS),r=new DataTexture(t,TEXTURE_WIDTH,4*e,RGBAFormat,HalfFloatType);return r.wrapS=RepeatWrapping,r.wrapY=RepeatWrapping,r.magFilter=LinearFilter,r.minFilter=LinearFilter,r.needsUpdate=!0,r}export function updateSplineTexture(e,t,r=0){const a=Math.floor(1*TEXTURE_WIDTH);t.arcLengthDivisions=a/2,t.updateArcLengths();const o=t.getSpacedPoints(a),n=t.computeFrenetFrames(a,!0);for(let t=0;t<a;t++){const a=Math.floor(t/TEXTURE_WIDTH),i=t%TEXTURE_WIDTH;let s=o[t];setTextureValue(e,i,s.x,s.y,s.z,0+a+4*r),s=n.tangents[t],setTextureValue(e,i,s.x,s.y,s.z,1+a+4*r),s=n.normals[t],setTextureValue(e,i,s.x,s.y,s.z,2+a+4*r),s=n.binormals[t],setTextureValue(e,i,s.x,s.y,s.z,3+a+4*r)}e.needsUpdate=!0}function setTextureValue(e,t,r,a,o,n){const i=e.image,{data:s}=i,l=CHANNELS*TEXTURE_WIDTH*n;s[t*CHANNELS+l+0]=DataUtils.toHalfFloat(r),s[t*CHANNELS+l+1]=DataUtils.toHalfFloat(a),s[t*CHANNELS+l+2]=DataUtils.toHalfFloat(o),s[t*CHANNELS+l+3]=DataUtils.toHalfFloat(1)}export function getUniforms(e){return{spineTexture:e,pathOffset:0,pathSegment:1,spineOffset:161,spineLength:400,flow:1}}export function modifyShader(e,t,r){const a=t.spineTexture,o=reference("pathOffset","float",t),n=reference("pathSegment","float",t),i=reference("spineOffset","float",t),s=reference("spineLength","float",t),l=reference("flow","float",t);e.positionNode=Fn((()=>{const e=4*r,t=modelWorldMatrix.mul(vec4(positionLocal,1)).toVar(),c=l.greaterThan(0).toVar(),u=select(c,0,1).toVar(),f=select(c,t.x.add(i).div(s),0).mul(n).add(o).mul(1).toVar();f.assign(f.mod(1));const p=f.floor().toVar(),m=texture(a,vec2(f,p.add(.5).div(e))).xyz,d=texture(a,vec2(f,p.add(1.5).div(e))).xyz,T=texture(a,vec2(f,p.add(2.5).div(e))).xyz,h=texture(a,vec2(f,p.add(3.5).div(e))).xyz,x=mat3(d,T,h).toVar();return varyingProperty("vec3","curveNormal").assign(x.mul(normalLocal)),x.mul(vec3(t.x.mul(u),t.y,t.z)).add(m)}))(),e.normalNode=varyingProperty("vec3","curveNormal")}export class Flow{constructor(e,t=1){const r=e.clone(),a=initSplineTexture(t),o=getUniforms(a);r.traverse((function(e){if(e instanceof Mesh||e instanceof InstancedMesh)if(Array.isArray(e.material)){const r=[];for(const a of e.material){const e=a.clone();modifyShader(e,o,t),r.push(e)}e.material=r}else e.material=e.material.clone(),modifyShader(e.material,o,t)})),this.curveArray=new Array(t),this.curveLengthArray=new Array(t),this.object3D=r,this.splineTexure=a,this.uniforms=o}updateCurve(e,t){if(e>=this.curveArray.length)throw Error("Index out of range for Flow");const r=t.getLength();this.uniforms.spineLength=r,this.curveLengthArray[e]=r,this.curveArray[e]=t,updateSplineTexture(this.splineTexure,t,e)}moveAlongCurve(e){this.uniforms.pathOffset+=e}}
//# sourceMappingURL=/sm/51c2d92b7862012a4d056847f7f6b1ab26606194359dce1a0686a00e651e6f9e.map