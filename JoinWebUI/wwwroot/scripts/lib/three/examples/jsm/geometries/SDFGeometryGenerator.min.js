/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.168.0/examples/jsm/geometries/SDFGeometryGenerator.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{BufferAttribute,BufferGeometry,FloatType,Mesh,OrthographicCamera,PlaneGeometry,Scene,ShaderMaterial,Vector2,WebGLRenderTarget}from"three";import{surfaceNet}from"./../libs/surfaceNet.js";class SDFGeometryGenerator{constructor(e){this.renderer=e}generate(e=64,t="float dist( vec3 p ){ return length(p) - 0.5; }",r=1){let o,n;if(8==e)[o,n]=[32,16];else if(16==e)[o,n]=[64,64];else if(32==e)[o,n]=[256,128];else if(64==e)[o,n]=[512,512];else if(128==e)[o,n]=[2048,1024];else if(256==e)[o,n]=[4096,4096];else if(512==e)[o,n]=[16384,8096];else{if(1024!=e)throw new Error("THREE.SDFGeometryGenerator: Resolution must be in range 8 < res < 1024 and must be ^2");[o,n]=[32768,32768]}const i=this.renderer.capabilities.maxTextureSize;if(o>i||n>i)throw new Error("THREE.SDFGeometryGenerator: Your device does not support this resolution ( "+e+" ), decrease [res] param.");const[s,a]=[o/e,n/e],l="\n\t\t\tvarying vec2 vUv;\n\t\t\tuniform float tileNum;\n\t\t\tuniform float bounds;\n\t\t\t[#dist#]\n\t\t\tvoid main()\t{ gl_FragColor=vec4( ( dist( vec3( vUv, tileNum ) * 2.0 * bounds - vec3( bounds ) ) < 0.00001 ) ? 1.0 : 0.0 ); }\n\t\t",u=this.computeSDF(o,n,s,a,r,l.replace("[#dist#]",t)),d=new Float32Array(o*n*4);this.renderer.readRenderTargetPixels(u,0,0,o,n,d),u.dispose();const c=surfaceNet([e,e,e],((t,n,i)=>{let a=(t=(t+r)*(e/(2*r)))+(i=(i+r)*(e/(2*r)))%s*e+(n=(n+r)*(e/(2*r)))*o+Math.floor(i/s)*e*o;return a*=4,d[a+3]>0?-1e-9:1}),[[-r,-r,-r],[r,r,r]]),f=[],m=[],p=new BufferGeometry;return c.positions.forEach((e=>{f.push(e[0],e[1],e[2])})),c.cells.forEach((e=>m.push(e[0],e[1],e[2]))),p.setAttribute("position",new BufferAttribute(new Float32Array(f),3)),p.setIndex(m),p}computeSDF(e,t,r,o,n,i){const s=new WebGLRenderTarget(e,t,{type:FloatType}),a=new Scene,l=new OrthographicCamera,u=r*o;let d=0;Object.assign(l,{left:e/-2,right:e/2,top:t/2,bottom:t/-2}).updateProjectionMatrix(),l.position.z=2;const c=e/r,f=new PlaneGeometry(c,c);for(;d++<u;){const s=d-1,[l,u]=[c/2+s%r*c-e/2,c/2+Math.floor(s/r)*c-t/2],m=new Mesh(f,new ShaderMaterial({uniforms:{res:{value:new Vector2(e,t)},tileNum:{value:s/(r*o-1)},bounds:{value:n}},vertexShader:"varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}",fragmentShader:i}));m.position.set(l,u,0),a.add(m)}return this.renderer.setRenderTarget(s),this.renderer.render(a,l),this.renderer.setRenderTarget(null),f.dispose(),a.traverse((function(e){void 0!==e.material&&e.material.dispose()})),s}}export{SDFGeometryGenerator};
//# sourceMappingURL=/sm/7635ac4c76c26744b530041dfae013be01ee1b535d539898c0e4e24d438a3c20.map