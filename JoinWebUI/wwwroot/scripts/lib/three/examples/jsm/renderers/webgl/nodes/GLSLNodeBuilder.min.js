/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/renderers/webgl/nodes/GLSLNodeBuilder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{MathNode,GLSLNodeParser,NodeBuilder,NodeMaterial}from"../../../nodes/Nodes.js";import UniformBuffer from"../../common/UniformBuffer.js";import NodeUniformsGroup from"../../common/nodes/NodeUniformsGroup.js";import{NodeSampledTexture,NodeSampledCubeTexture}from"../../common/nodes/NodeSampledTexture.js";import{IntType}from"three";const glslMethods={[MathNode.ATAN2]:"atan",textureDimensions:"textureSize"},precisionLib={low:"lowp",medium:"mediump",high:"highp"},supports={instance:!0},defaultPrecisions="\nprecision highp float;\nprecision highp int;\nprecision mediump sampler2DArray;\nprecision lowp sampler2DShadow;\n";class GLSLNodeBuilder extends NodeBuilder{constructor(e,t,n=null){super(e,t,new GLSLNodeParser,n),this.uniformGroups={}}getMethod(e){return glslMethods[e]||e}getPropertyName(e,t){return e.isOutputStructVar?"":super.getPropertyName(e,t)}buildFunctionCode(e){const t=e.layout,n=this.flowShaderNode(e),r=[];for(const e of t.inputs)r.push(this.getType(e.type)+" "+e.name);return`${this.getType(t.type)} ${t.name}( ${r.join(", ")} ) {\n\n\t${n.vars}\n\n${n.code}\n\treturn ${n.result};\n\n}`}generateTextureLoad(e,t,n,r,o="0"){return r?`texelFetch( ${t}, ivec3( ${n}, ${r} ), ${o} )`:`texelFetch( ${t}, ${n}, ${o} )`}generateTexture(e,t,n,r){return e.isTextureCube?`textureCube( ${t}, ${n} )`:e.isDepthTexture?`texture( ${t}, ${n} ).x`:(r&&(n=`vec3( ${n}, ${r} )`),`texture( ${t}, ${n} )`)}generateTextureLevel(e,t,n,r){return`textureLod( ${t}, ${n}, ${r} )`}generateTextureCompare(e,t,n,r,o,s=this.shaderStage){if("fragment"===s)return`texture( ${t}, vec3( ${n}, ${r} ) )`;console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${s} shader.`)}getVars(e){const t=[],n=this.vars[e];if(void 0!==n)for(const e of n)e.isOutputStructVar||t.push(`${this.getVar(e.type,e.name)};`);return t.join("\n\t")}getUniforms(e){const t=this.uniforms[e],n=[],r={};for(const e of t){let t=null,o=!1;if("texture"===e.type){const n=e.node.value;t=n.compareFunction?`sampler2DShadow ${e.name};`:!0===n.isDataArrayTexture?`sampler2DArray ${e.name};`:`sampler2D ${e.name};`}else if("cubeTexture"===e.type)t=`samplerCube ${e.name};`;else if("buffer"===e.type){const n=e.node,r=this.getType(n.bufferType),o=n.bufferCount,s=o>0?o:"";t=`${n.name} {\n\t${r} ${e.name}[${s}];\n};\n`}else{t=`${this.getVectorType(e.type)} ${e.name};`,o=!0}const s=e.node.precision;if(null!==s&&(t=precisionLib[s]+" "+t),o){t="\t"+t;const n=e.groupNode.name;(r[n]||(r[n]=[])).push(t)}else t="uniform "+t,n.push(t)}let o="";for(const t in r){const n=r[t];o+=this._getGLSLUniformStruct(e+"_"+t,n.join("\n"))+"\n"}return o+=n.join("\n"),o}getTypeFromAttribute(e){let t=super.getTypeFromAttribute(e);if(/^[iu]/.test(t)&&e.gpuType!==IntType){let n=e;e.isInterleavedBufferAttribute&&(n=e.data);const r=n.array;!1==(r instanceof Uint32Array||r instanceof Int32Array)&&(t=t.slice(1))}return t}getAttributes(e){let t="";if("vertex"===e){const e=this.getAttributesArray();let n=0;for(const r of e)t+=`layout( location = ${n++} ) in ${r.type} ${r.name};\n`}return t}getStructMembers(e){const t=[],n=e.getMemberTypes();for(let e=0;e<n.length;e++){const r=n[e];t.push(`layout( location = ${e} ) out ${r} m${e};`)}return t.join("\n")}getStructs(e){const t=[],n=this.structs[e];if(0===n.length)return"layout( location = 0 ) out vec4 fragColor;\n";for(let e=0,r=n.length;e<r;e++){const r=n[e];let o="\n";o+=this.getStructMembers(r),o+="\n",t.push(o)}return t.join("\n\n")}getVaryings(e){let t="";const n=this.varyings;if("vertex"===e)for(const e of n){const n=e.type;t+=`${"int"===n||"uint"===n?"flat ":""}${e.needsInterpolation?"out":"/*out*/"} ${n} ${e.name};\n`}else if("fragment"===e)for(const e of n)if(e.needsInterpolation){const n=e.type;t+=`${"int"===n||"uint"===n?"flat ":""}in ${n} ${e.name};\n`}return t}getVertexIndex(){return"uint( gl_VertexID )"}getInstanceIndex(){return"uint( gl_InstanceID )"}getFrontFacing(){return"gl_FrontFacing"}getFragCoord(){return"gl_FragCoord"}getFragDepth(){return"gl_FragDepth"}isAvailable(e){return!0===supports[e]}isFlipY(){return!0}_getGLSLUniformStruct(e,t){return`\nlayout( std140 ) uniform ${e} {\n${t}\n};`}_getGLSLVertexCode(e){return`#version 300 es\n\n${this.getSignature()}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\n\n// attributes\n${e.attributes}\n\n// codes\n${e.codes}\n\nvoid main() {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`}_getGLSLFragmentCode(e){return`#version 300 es\n\n${this.getSignature()}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\n\n// codes\n${e.codes}\n\n${e.structs}\n\nvoid main() {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}buildCode(){const e=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};for(const t in e){let n="// code\n\n";n+=this.flowCode[t];const r=this.flowNodes[t],o=r[r.length-1];for(const e of r){const r=this.getFlowData(e),s=e.name;s&&(n.length>0&&(n+="\n"),n+=`\t// flow -> ${s}\n\t`),n+=`${r.code}\n\t`,e===o&&"compute"!==t&&(n+="// result\n\t","vertex"===t?(n+="gl_Position = ",n+=`${r.result};`):"fragment"===t&&(e.outputNode.isOutputStructNode||(n+="fragColor = ",n+=`${r.result};`)))}const s=e[t];s.uniforms=this.getUniforms(t),s.attributes=this.getAttributes(t),s.varyings=this.getVaryings(t),s.vars=this.getVars(t),s.structs=this.getStructs(t),s.codes=this.getCodes(t),s.flow=n}null!==this.material?(this.vertexShader=this._getGLSLVertexCode(e.vertex),this.fragmentShader=this._getGLSLFragmentCode(e.fragment)):console.warn("GLSLNodeBuilder: compute shaders are not supported.")}getUniformFromNode(e,t,n,r=null){const o=super.getUniformFromNode(e,t,n,r),s=this.getDataFromNode(e,n,this.globalCache);let i=s.uniformGPU;if(void 0===i){if("texture"===t)i=new NodeSampledTexture(o.name,o.node),this.bindings[n].push(i);else if("cubeTexture"===t)i=new NodeSampledCubeTexture(o.name,o.node),this.bindings[n].push(i);else if("buffer"===t){e.name=`NodeBuffer_${e.id}`;const t=new UniformBuffer(e.name,e.value);o.name=`buffer${e.id}`,this.bindings[n].push(t),i=t}else{const r=e.groupNode,s=r.name,u=this.uniformGroups[n]||(this.uniformGroups[n]={});let a=u[s];void 0===a&&(a=new NodeUniformsGroup(n+"_"+s,r),u[s]=a,this.bindings[n].push(a)),i=this.getNodeUniform(o,t),a.addUniform(i)}s.uniformGPU=i}return o}build(){const{object:e,material:t}=this;return null!==t?NodeMaterial.fromMaterial(t).build(this):this.addFlow("compute",e),super.build()}}export default GLSLNodeBuilder;
//# sourceMappingURL=/sm/b43ae419be070467d52c5a111c694a15fe885ea6d05c3856db6c5a317feb9b02.map