/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/renderers/common/Renderer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Animation from"./Animation.js";import RenderObjects from"./RenderObjects.js";import Attributes from"./Attributes.js";import Geometries from"./Geometries.js";import Info from"./Info.js";import Pipelines from"./Pipelines.js";import Bindings from"./Bindings.js";import RenderLists from"./RenderLists.js";import RenderContexts from"./RenderContexts.js";import Textures from"./Textures.js";import Background from"./Background.js";import Nodes from"./nodes/Nodes.js";import Color4 from"./Color4.js";import{Scene,Frustum,Matrix4,Vector2,Vector3,Vector4,DoubleSide,BackSide,FrontSide,SRGBColorSpace,NoToneMapping}from"three";const _scene=new Scene,_drawingBufferSize=new Vector2,_screen=new Vector4,_frustum=new Frustum,_projScreenMatrix=new Matrix4,_vector3=new Vector3;class Renderer{constructor(e,t={}){this.isRenderer=!0;const{logarithmicDepthBuffer:i=!1}=t;this.domElement=e.getDomElement(),this.backend=e,this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.logarithmicDepthBuffer=i,this.outputColorSpace=SRGBColorSpace,this.toneMapping=NoToneMapping,this.toneMappingExposure=1,this.sortObjects=!0,this.depth=!0,this.stencil=!0,this.info=new Info,this._pixelRatio=1,this._width=this.domElement.width,this._height=this.domElement.height,this._viewport=new Vector4(0,0,this._width,this._height),this._scissor=new Vector4(0,0,this._width,this._height),this._scissorTest=!1,this._properties=null,this._attributes=null,this._geometries=null,this._nodes=null,this._animation=null,this._bindings=null,this._objects=null,this._pipelines=null,this._renderLists=null,this._renderContexts=null,this._textures=null,this._background=null,this._currentRenderContext=null,this._opaqueSort=null,this._transparentSort=null,this._clearColor=new Color4(0),this._clearDepth=1,this._clearStencil=0,this._renderTarget=null,this._activeCubeFace=0,this._activeMipmapLevel=0,this._renderObjectFunction=null,this._currentRenderObjectFunction=null,this._initialized=!1,this._initPromise=null,this.shadowMap={enabled:!1,type:null},this.xr={enabled:!1}}async init(){if(this._initialized)throw new Error("Renderer: Backend has already been initialized.");return null!==this._initPromise||(this._initPromise=new Promise((async(e,t)=>{const i=this.backend;try{await i.init(this)}catch(e){return void t(e)}this._nodes=new Nodes(this,i),this._animation=new Animation(this._nodes,this.info),this._attributes=new Attributes(i),this._background=new Background(this,this._nodes),this._geometries=new Geometries(this._attributes,this.info),this._textures=new Textures(i,this.info),this._pipelines=new Pipelines(i,this._nodes),this._bindings=new Bindings(i,this._nodes,this._textures,this._attributes,this._pipelines,this.info),this._objects=new RenderObjects(this,this._nodes,this._geometries,this._pipelines,this._bindings,this.info),this._renderLists=new RenderLists,this._renderContexts=new RenderContexts,this._initialized=!0,e()}))),this._initPromise}get coordinateSystem(){return this.backend.coordinateSystem}async compile(){console.warn("THREE.Renderer: .compile() is not implemented yet.")}async render(e,t){!1===this._initialized&&await this.init();const i=this._nodes.nodeFrame,r=i.renderId,s=this._currentRenderContext,n=this._currentRenderObjectFunction,o=!0===e.isScene?e:_scene,h=this._renderTarget,a=this._renderContexts.get(e,t,h),l=this._activeCubeFace,c=this._activeMipmapLevel;this._currentRenderContext=a,this._currentRenderObjectFunction=this._renderObjectFunction||this.renderObject,this.info.calls++,this.info.render.calls++,i.renderId=this.info.calls;const d=this.coordinateSystem;t.coordinateSystem!==d&&(t.coordinateSystem=d,t.updateProjectionMatrix()),!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),null===t.parent&&!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),!0===this.info.autoReset&&this.info.reset();let u=this._viewport,p=this._scissor,_=this._pixelRatio;null!==h&&(u=h.viewport,p=h.scissor,_=1),this.getDrawingBufferSize(_drawingBufferSize),_screen.set(0,0,_drawingBufferSize.width,_drawingBufferSize.height);const m=void 0===u.minDepth?0:u.minDepth,g=void 0===u.maxDepth?1:u.maxDepth;a.viewportValue.copy(u).multiplyScalar(_).floor(),a.viewportValue.width>>=c,a.viewportValue.height>>=c,a.viewportValue.minDepth=m,a.viewportValue.maxDepth=g,a.viewport=!1===a.viewportValue.equals(_screen),a.scissorValue.copy(p).multiplyScalar(_).floor(),a.scissor=this._scissorTest&&!1===a.scissorValue.equals(_screen),a.scissorValue.width>>=c,a.scissorValue.height>>=c,a.depth=this.depth,a.stencil=this.stencil,o.onBeforeRender(this,e,t,h),_projScreenMatrix.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),_frustum.setFromProjectionMatrix(_projScreenMatrix,d);const f=this._renderLists.get(e,t);if(f.begin(),this._projectObject(e,t,0,f),f.finish(),!0===this.sortObjects&&f.sort(this._opaqueSort,this._transparentSort),null!==h){this._textures.updateRenderTarget(h,c);const e=this._textures.get(h);a.textures=e.textures,a.depthTexture=e.depthTexture,a.width=e.width,a.height=e.height,a.renderTarget=h}else a.textures=null,a.depthTexture=null,a.width=this.domElement.width,a.height=this.domElement.height;a.width>>=c,a.height>>=c,a.activeCubeFace=l,a.activeMipmapLevel=c,a.occlusionQueryCount=f.occlusionQueryCount,this._nodes.updateScene(o),this._background.update(o,f,a),this.backend.beginRender(a);const x=f.opaque,b=f.transparent,w=f.lightsNode;x.length>0&&this._renderObjects(x,t,o,w),b.length>0&&this._renderObjects(b,t,o,w),this.backend.finishRender(a),i.renderId=r,this._currentRenderContext=s,this._currentRenderObjectFunction=n,o.onAfterRender(this,e,t,h)}getMaxAnisotropy(){return this.backend.getMaxAnisotropy()}getActiveCubeFace(){return this._activeCubeFace}getActiveMipmapLevel(){return this._activeMipmapLevel}async setAnimationLoop(e){!1===this._initialized&&await this.init(),this._animation.setAnimationLoop(e)}getArrayBuffer(e){return console.warn("THREE.Renderer: getArrayBuffer() is deprecated. Use getArrayBufferAsync() instead."),this.getArrayBufferAsync(e)}async getArrayBufferAsync(e){return await this.backend.getArrayBufferAsync(e)}getContext(){return this._context}getPixelRatio(){return this._pixelRatio}getDrawingBufferSize(e){return e.set(this._width*this._pixelRatio,this._height*this._pixelRatio).floor()}getSize(e){return e.set(this._width,this._height)}setPixelRatio(e=1){this._pixelRatio=e,this.setSize(this._width,this._height,!1)}setDrawingBufferSize(e,t,i){this._width=e,this._height=t,this._pixelRatio=i,this.domElement.width=Math.floor(e*i),this.domElement.height=Math.floor(t*i),this.setViewport(0,0,e,t),this._initialized&&this.backend.updateSize()}setSize(e,t,i=!0){this._width=e,this._height=t,this.domElement.width=Math.floor(e*this._pixelRatio),this.domElement.height=Math.floor(t*this._pixelRatio),!0===i&&(this.domElement.style.width=e+"px",this.domElement.style.height=t+"px"),this.setViewport(0,0,e,t),this._initialized&&this.backend.updateSize()}setOpaqueSort(e){this._opaqueSort=e}setTransparentSort(e){this._transparentSort=e}getScissor(e){const t=this._scissor;return e.x=t.x,e.y=t.y,e.width=t.width,e.height=t.height,e}setScissor(e,t,i,r){const s=this._scissor;e.isVector4?s.copy(e):s.set(e,t,i,r)}getScissorTest(){return this._scissorTest}setScissorTest(e){this._scissorTest=e}getViewport(e){return e.copy(this._viewport)}setViewport(e,t,i,r,s=0,n=1){const o=this._viewport;e.isVector4?o.copy(e):o.set(e,t,i,r),o.minDepth=s,o.maxDepth=n}getClearColor(e){return e.copy(this._clearColor)}setClearColor(e,t=1){this._clearColor.set(e),this._clearColor.a=t}getClearAlpha(){return this._clearColor.a}setClearAlpha(e){this._clearColor.a=e}getClearDepth(){return this._clearDepth}setClearDepth(e){this._clearDepth=e}getClearStencil(){return this._clearStencil}setClearStencil(e){this._clearStencil=e}isOccluded(e){const t=this._currentRenderContext;return t&&this.backend.isOccluded(t,e)}clear(e=!0,t=!0,i=!0){let r=null;const s=this._renderTarget;null!==s&&(this._textures.updateRenderTarget(s),r=this._textures.get(s)),this.backend.clear(e,t,i,r)}clearColor(){this.clear(!0,!1,!1)}clearDepth(){this.clear(!1,!0,!1)}clearStencil(){this.clear(!1,!1,!0)}get currentColorSpace(){const e=this._renderTarget;if(null!==e){const t=e.texture;return(Array.isArray(t)?t[0]:t).colorSpace}return this.outputColorSpace}dispose(){this.info.dispose(),this._animation.dispose(),this._objects.dispose(),this._properties.dispose(),this._pipelines.dispose(),this._nodes.dispose(),this._bindings.dispose(),this._renderLists.dispose(),this._renderContexts.dispose(),this._textures.dispose(),this.setRenderTarget(null),this.setAnimationLoop(null)}setRenderTarget(e,t=0,i=0){this._renderTarget=e,this._activeCubeFace=t,this._activeMipmapLevel=i}getRenderTarget(){return this._renderTarget}setRenderObjectFunction(e){this._renderObjectFunction=e}getRenderObjectFunction(){return this._renderObjectFunction}async compute(e){!1===this._initialized&&await this.init();const t=this._nodes.nodeFrame,i=t.renderId;this.info.calls++,this.info.compute.calls++,t.renderId=this.info.calls;const r=this.backend,s=this._pipelines,n=this._bindings,o=this._nodes,h=Array.isArray(e)?e:[e];if(void 0===h[0]||!0!==h[0].isComputeNode)throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");r.beginCompute(e);for(const t of h){if(!1===s.has(t)){const e=()=>{t.removeEventListener("dispose",e),s.delete(t),n.delete(t),o.delete(t)};t.addEventListener("dispose",e),t.onInit({renderer:this})}o.updateForCompute(t),n.updateForCompute(t);const i=n.getForCompute(t),h=s.getForCompute(t,i);r.compute(e,t,i,h)}r.finishCompute(e),t.renderId=i}hasFeature(e){return this.backend.hasFeature(e)}copyFramebufferToTexture(e){const t=this._currentRenderContext;this._textures.updateTexture(e),this.backend.copyFramebufferToTexture(e,t)}readRenderTargetPixelsAsync(e,t,i,r,s){return this.backend.copyTextureToBuffer(e.texture,t,i,r,s)}_projectObject(e,t,i,r){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)i=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)r.pushLight(e);else if(e.isSprite){if(!e.frustumCulled||_frustum.intersectsSprite(e)){!0===this.sortObjects&&_vector3.setFromMatrixPosition(e.matrixWorld).applyMatrix4(_projScreenMatrix);const t=e.geometry,s=e.material;s.visible&&r.push(e,t,s,i,_vector3.z,null)}}else if(e.isLineLoop)console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");else if((e.isMesh||e.isLine||e.isPoints)&&(!e.frustumCulled||_frustum.intersectsObject(e))){const t=e.geometry,s=e.material;if(!0===this.sortObjects&&(null===t.boundingSphere&&t.computeBoundingSphere(),_vector3.copy(t.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(_projScreenMatrix)),Array.isArray(s)){const n=t.groups;for(let o=0,h=n.length;o<h;o++){const h=n[o],a=s[h.materialIndex];a&&a.visible&&r.push(e,t,a,i,_vector3.z,h)}}else s.visible&&r.push(e,t,s,i,_vector3.z,null)}const s=e.children;for(let e=0,n=s.length;e<n;e++)this._projectObject(s[e],t,i,r)}_renderObjects(e,t,i,r){for(let s=0,n=e.length;s<n;s++){const n=e[s],{object:o,geometry:h,material:a,group:l}=n;if(t.isArrayCamera){const e=t.cameras;for(let t=0,s=e.length;t<s;t++){const s=e[t];if(o.layers.test(s.layers)){const e=s.viewport,t=void 0===e.minDepth?0:e.minDepth,n=void 0===e.maxDepth?1:e.maxDepth,c=this._currentRenderContext.viewportValue;c.copy(e).multiplyScalar(this._pixelRatio).floor(),c.minDepth=t,c.maxDepth=n,this.backend.updateViewport(this._currentRenderContext),this._currentRenderObjectFunction(o,i,s,h,a,l,r)}}}else this._currentRenderObjectFunction(o,i,t,h,a,l,r)}}renderObject(e,t,i,r,s,n,o){let h;if(e.onBeforeRender(this,t,i,r,s,n),s.onBeforeRender(this,t,i,r,s,n),null!==t.overrideMaterial){const e=t.overrideMaterial;s.positionNode&&s.positionNode.isNode&&(h=e.positionNode,e.positionNode=s.positionNode),s=e}!0===s.transparent&&s.side===DoubleSide&&!1===s.forceSinglePass?(s.side=BackSide,this._renderObjectDirect(e,s,t,i,o,"backSide"),s.side=FrontSide,this._renderObjectDirect(e,s,t,i,o),s.side=DoubleSide):this._renderObjectDirect(e,s,t,i,o),void 0!==h&&(t.overrideMaterial.positionNode=h),e.onAfterRender(this,t,i,r,s,n)}_renderObjectDirect(e,t,i,r,s,n){const o=this._objects.get(e,t,i,r,s,this._currentRenderContext,n);this._nodes.updateBefore(o),e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),this._nodes.updateForRender(o),this._geometries.updateForRender(o),this._bindings.updateForRender(o),this._pipelines.updateForRender(o),this.backend.draw(o,this.info)}}export default Renderer;
//# sourceMappingURL=/sm/5a6e53855f3bb4d02ace9d1b87e1100405b4a786c5097e4b37025e0eb0c85334.map