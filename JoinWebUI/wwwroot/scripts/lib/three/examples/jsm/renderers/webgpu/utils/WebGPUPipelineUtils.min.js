/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/renderers/webgpu/utils/WebGPUPipelineUtils.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{BlendColorFactor,OneMinusBlendColorFactor}from"../../common/Constants.js";import{GPUFrontFace,GPUCullMode,GPUColorWriteFlags,GPUCompareFunction,GPUBlendFactor,GPUBlendOperation,GPUIndexFormat,GPUStencilOperation}from"./WebGPUConstants.js";import{FrontSide,BackSide,DoubleSide,NeverDepth,AlwaysDepth,LessDepth,LessEqualDepth,EqualDepth,GreaterEqualDepth,GreaterDepth,NotEqualDepth,NoBlending,NormalBlending,AdditiveBlending,SubtractiveBlending,MultiplyBlending,CustomBlending,ZeroFactor,OneFactor,SrcColorFactor,OneMinusSrcColorFactor,SrcAlphaFactor,OneMinusSrcAlphaFactor,DstColorFactor,OneMinusDstColorFactor,DstAlphaFactor,OneMinusDstAlphaFactor,SrcAlphaSaturateFactor,AddEquation,SubtractEquation,ReverseSubtractEquation,MinEquation,MaxEquation,KeepStencilOp,ZeroStencilOp,ReplaceStencilOp,InvertStencilOp,IncrementStencilOp,DecrementStencilOp,IncrementWrapStencilOp,DecrementWrapStencilOp,NeverStencilFunc,AlwaysStencilFunc,LessStencilFunc,LessEqualStencilFunc,EqualStencilFunc,GreaterEqualStencilFunc,GreaterStencilFunc,NotEqualStencilFunc}from"three";class WebGPUPipelineUtils{constructor(e){this.backend=e}createRenderPipeline(e){const{object:t,material:n,geometry:r,pipeline:a}=e,{vertexProgram:o,fragmentProgram:c}=a,l=this.backend,i=l.device,s=l.utils,d=l.get(a),p=l.get(e.getBindings()),u=l.attributeUtils.createShaderVertexBuffers(e);let F;!0===n.transparent&&n.blending!==NoBlending&&(F=this._getBlending(n));let P={};!0===n.stencilWrite&&(P={compare:this._getStencilCompare(n),failOp:this._getStencilOperation(n.stencilFail),depthFailOp:this._getStencilOperation(n.stencilZFail),passOp:this._getStencilOperation(n.stencilZPass)});const G=this._getColorWriteMask(n),U=[];if(null!==e.context.textures){const t=e.context.textures;for(let e=0;e<t.length;e++){const n=s.getTextureFormatGPU(t[e]);U.push({format:n,blend:F,writeMask:G})}}else{const t=s.getCurrentColorFormat(e.context);U.push({format:t,blend:F,writeMask:G})}const S=l.get(o).module,b=l.get(c).module,B=this._getPrimitiveState(t,r,n),h=this._getDepthCompare(n),m=s.getCurrentDepthStencilFormat(e.context),O=s.getSampleCount(e.context);d.pipeline=i.createRenderPipeline({vertex:Object.assign({},S,{buffers:u}),fragment:Object.assign({},b,{targets:U}),primitive:B,depthStencil:{format:m,depthWriteEnabled:n.depthWrite,depthCompare:h,stencilFront:P,stencilBack:{},stencilReadMask:n.stencilFuncMask,stencilWriteMask:n.stencilWriteMask},multisample:{count:O,alphaToCoverageEnabled:n.alphaToCoverage},layout:i.createPipelineLayout({bindGroupLayouts:[p.layout]})})}createComputePipeline(e,t){const n=this.backend,r=n.device,a=n.get(e.computeProgram).module,o=n.get(e),c=n.get(t);o.pipeline=r.createComputePipeline({compute:a,layout:r.createPipelineLayout({bindGroupLayouts:[c.layout]})})}_getBlending(e){let t,n;const r=e.blending;if(r===CustomBlending){const r=null!==e.blendSrcAlpha?e.blendSrcAlpha:GPUBlendFactor.One,a=null!==e.blendDstAlpha?e.blendDstAlpha:GPUBlendFactor.Zero,o=null!==e.blendEquationAlpha?e.blendEquationAlpha:GPUBlendFactor.Add;t={srcFactor:this._getBlendFactor(e.blendSrc),dstFactor:this._getBlendFactor(e.blendDst),operation:this._getBlendOperation(e.blendEquation)},n={srcFactor:this._getBlendFactor(r),dstFactor:this._getBlendFactor(a),operation:this._getBlendOperation(o)}}else{const a=(e,r,a,o)=>{t={srcFactor:e,dstFactor:r,operation:GPUBlendOperation.Add},n={srcFactor:a,dstFactor:o,operation:GPUBlendOperation.Add}};if(e.premultipliedAlpha)switch(r){case NormalBlending:a(GPUBlendFactor.SrcAlpha,GPUBlendFactor.OneMinusSrcAlpha,GPUBlendFactor.One,GPUBlendFactor.OneMinusSrcAlpha);break;case AdditiveBlending:a(GPUBlendFactor.SrcAlpha,GPUBlendFactor.One,GPUBlendFactor.One,GPUBlendFactor.One);break;case SubtractiveBlending:a(GPUBlendFactor.Zero,GPUBlendFactor.OneMinusSrc,GPUBlendFactor.Zero,GPUBlendFactor.One);break;case MultiplyBlending:a(GPUBlendFactor.Zero,GPUBlendFactor.Src,GPUBlendFactor.Zero,GPUBlendFactor.SrcAlpha)}else switch(r){case NormalBlending:a(GPUBlendFactor.SrcAlpha,GPUBlendFactor.OneMinusSrcAlpha,GPUBlendFactor.One,GPUBlendFactor.OneMinusSrcAlpha);break;case AdditiveBlending:a(GPUBlendFactor.SrcAlpha,GPUBlendFactor.One,GPUBlendFactor.SrcAlpha,GPUBlendFactor.One);break;case SubtractiveBlending:a(GPUBlendFactor.Zero,GPUBlendFactor.OneMinusSrc,GPUBlendFactor.Zero,GPUBlendFactor.One);break;case MultiplyBlending:a(GPUBlendFactor.Zero,GPUBlendFactor.Src,GPUBlendFactor.Zero,GPUBlendFactor.Src)}}if(void 0!==t&&void 0!==n)return{color:t,alpha:n};console.error("THREE.WebGPURenderer: Invalid blending: ",r)}_getBlendFactor(e){let t;switch(e){case ZeroFactor:t=GPUBlendFactor.Zero;break;case OneFactor:t=GPUBlendFactor.One;break;case SrcColorFactor:t=GPUBlendFactor.Src;break;case OneMinusSrcColorFactor:t=GPUBlendFactor.OneMinusSrc;break;case SrcAlphaFactor:t=GPUBlendFactor.SrcAlpha;break;case OneMinusSrcAlphaFactor:t=GPUBlendFactor.OneMinusSrcAlpha;break;case DstColorFactor:t=GPUBlendFactor.Dst;break;case OneMinusDstColorFactor:t=GPUBlendFactor.OneMinusDstColor;break;case DstAlphaFactor:t=GPUBlendFactor.DstAlpha;break;case OneMinusDstAlphaFactor:t=GPUBlendFactor.OneMinusDstAlpha;break;case SrcAlphaSaturateFactor:t=GPUBlendFactor.SrcAlphaSaturated;break;case BlendColorFactor:t=GPUBlendFactor.Constant;break;case OneMinusBlendColorFactor:t=GPUBlendFactor.OneMinusConstant;break;default:console.error("THREE.WebGPURenderer: Blend factor not supported.",e)}return t}_getStencilCompare(e){let t;const n=e.stencilFunc;switch(n){case NeverStencilFunc:t=GPUCompareFunction.Never;break;case AlwaysStencilFunc:t=GPUCompareFunction.Always;break;case LessStencilFunc:t=GPUCompareFunction.Less;break;case LessEqualStencilFunc:t=GPUCompareFunction.LessEqual;break;case EqualStencilFunc:t=GPUCompareFunction.Equal;break;case GreaterEqualStencilFunc:t=GPUCompareFunction.GreaterEqual;break;case GreaterStencilFunc:t=GPUCompareFunction.Greater;break;case NotEqualStencilFunc:t=GPUCompareFunction.NotEqual;break;default:console.error("THREE.WebGPURenderer: Invalid stencil function.",n)}return t}_getStencilOperation(e){let t;switch(e){case KeepStencilOp:t=GPUStencilOperation.Keep;break;case ZeroStencilOp:t=GPUStencilOperation.Zero;break;case ReplaceStencilOp:t=GPUStencilOperation.Replace;break;case InvertStencilOp:t=GPUStencilOperation.Invert;break;case IncrementStencilOp:t=GPUStencilOperation.IncrementClamp;break;case DecrementStencilOp:t=GPUStencilOperation.DecrementClamp;break;case IncrementWrapStencilOp:t=GPUStencilOperation.IncrementWrap;break;case DecrementWrapStencilOp:t=GPUStencilOperation.DecrementWrap;break;default:console.error("THREE.WebGPURenderer: Invalid stencil operation.",t)}return t}_getBlendOperation(e){let t;switch(e){case AddEquation:t=GPUBlendOperation.Add;break;case SubtractEquation:t=GPUBlendOperation.Subtract;break;case ReverseSubtractEquation:t=GPUBlendOperation.ReverseSubtract;break;case MinEquation:t=GPUBlendOperation.Min;break;case MaxEquation:t=GPUBlendOperation.Max;break;default:console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.",e)}return t}_getPrimitiveState(e,t,n){const r={},a=this.backend.utils;switch(r.topology=a.getPrimitiveTopology(e,n),null!==t.index&&!0===e.isLine&&!0!==e.isLineSegments&&(r.stripIndexFormat=t.index.array instanceof Uint16Array?GPUIndexFormat.Uint16:GPUIndexFormat.Uint32),n.side){case FrontSide:r.frontFace=GPUFrontFace.CCW,r.cullMode=GPUCullMode.Back;break;case BackSide:r.frontFace=GPUFrontFace.CCW,r.cullMode=GPUCullMode.Front;break;case DoubleSide:r.frontFace=GPUFrontFace.CCW,r.cullMode=GPUCullMode.None;break;default:console.error("THREE.WebGPUPipelineUtils: Unknown material.side value.",n.side)}return r}_getColorWriteMask(e){return!0===e.colorWrite?GPUColorWriteFlags.All:GPUColorWriteFlags.None}_getDepthCompare(e){let t;if(!1===e.depthTest)t=GPUCompareFunction.Always;else{const n=e.depthFunc;switch(n){case NeverDepth:t=GPUCompareFunction.Never;break;case AlwaysDepth:t=GPUCompareFunction.Always;break;case LessDepth:t=GPUCompareFunction.Less;break;case LessEqualDepth:t=GPUCompareFunction.LessEqual;break;case EqualDepth:t=GPUCompareFunction.Equal;break;case GreaterEqualDepth:t=GPUCompareFunction.GreaterEqual;break;case GreaterDepth:t=GPUCompareFunction.Greater;break;case NotEqualDepth:t=GPUCompareFunction.NotEqual;break;default:console.error("THREE.WebGPUPipelineUtils: Invalid depth function.",n)}}return t}}export default WebGPUPipelineUtils;
//# sourceMappingURL=/sm/0d1b19421bb0d7703741b4afbe759c859069f87ff5b55d4d03d9481ffe277a7a.map