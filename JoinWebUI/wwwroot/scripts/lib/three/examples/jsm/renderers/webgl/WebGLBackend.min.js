/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/renderers/webgl/WebGLBackend.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{WebGLCoordinateSystem}from"three";import GLSLNodeBuilder from"./nodes/GLSLNodeBuilder.js";import Backend from"../common/Backend.js";import WebGLAttributeUtils from"./utils/WebGLAttributeUtils.js";import WebGLState from"./utils/WebGLState.js";import WebGLUtils from"./utils/WebGLUtils.js";import WebGLTextureUtils from"./utils/WebGLTextureUtils.js";import WebGLExtensions from"./utils/WebGLExtensions.js";import WebGLCapabilities from"./utils/WebGLCapabilities.js";class WebGLBackend extends Backend{constructor(e={}){super(e),this.isWebGLBackend=!0}async init(e){await super.init(e);const t=this.parameters,r=void 0!==t.context?t.context:e.domElement.getContext("webgl2");this.gl=r,this.extensions=new WebGLExtensions(this),this.capabilities=new WebGLCapabilities(this),this.attributeUtils=new WebGLAttributeUtils(this),this.textureUtils=new WebGLTextureUtils(this),this.state=new WebGLState(this),this.utils=new WebGLUtils(this),this.defaultTextures={},this.extensions.get("EXT_color_buffer_float"),this._currentContext=null}get coordinateSystem(){return WebGLCoordinateSystem}async getArrayBufferAsync(e){return await this.attributeUtils.getArrayBufferAsync(e)}beginRender(e){const{gl:t}=this,r=this.get(e);r.previousContext=this._currentContext,this._currentContext=e,this._setFramebuffer(e),this.clear(e.clearColor,e.clearDepth,e.clearStencil,e),e.viewport?this.updateViewport(e):t.viewport(0,0,t.drawingBufferWidth,t.drawingBufferHeight);const i=e.occlusionQueryCount;i>0&&(r.currentOcclusionQueries=r.occlusionQueries,r.currentOcclusionQueryObjects=r.occlusionQueryObjects,r.lastOcclusionObject=null,r.occlusionQueries=new Array(i),r.occlusionQueryObjects=new Array(i),r.occlusionQueryIndex=0)}finishRender(e){const t=this.get(e).previousContext;if(this._currentContext=t,null!==t)if(this._setFramebuffer(t),t.viewport)this.updateViewport(t);else{const e=this.gl;e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight)}const r=e.occlusionQueryCount;if(r>0){if(r>this.get(e).occlusionQueryIndex){const{gl:e}=this;e.endQuery(e.ANY_SAMPLES_PASSED)}this.resolveOccludedAsync(e)}}resolveOccludedAsync(e){const t=this.get(e),{currentOcclusionQueries:r,currentOcclusionQueryObjects:i}=t;if(r&&i){const e=new WeakSet,{gl:s}=this;t.currentOcclusionQueryObjects=null,t.currentOcclusionQueries=null;const n=()=>{let a=0;for(let t=0;t<r.length;t++){const n=r[t];null!==n&&(s.getQueryParameter(n,s.QUERY_RESULT_AVAILABLE)&&(s.getQueryParameter(n,s.QUERY_RESULT)>0&&e.add(i[t]),r[t]=null,s.deleteQuery(n),a++))}a<r.length?requestAnimationFrame(n):t.occluded=e};n()}}isOccluded(e,t){const r=this.get(e);return r.occluded&&r.occluded.has(t)}updateViewport(e){const t=this.gl,{x:r,y:i,width:s,height:n}=e.viewportValue;t.viewport(r,i,s,n)}clear(e,t,r,i=null){const{gl:s}=this;null===i&&(i={textures:null,clearColorValue:this.getClearColor()});let n=0;if(e&&(n|=s.COLOR_BUFFER_BIT),t&&(n|=s.DEPTH_BUFFER_BIT),r&&(n|=s.STENCIL_BUFFER_BIT),0!==n){const a=i.clearColorValue;if(t&&this.state.setDepthMask(!0),null===i.textures)s.clearColor(a.r,a.g,a.b,a.a),s.clear(n);else{if(e)for(let e=0;e<i.textures.length;e++)s.clearBufferfv(s.COLOR,e,[a.r,a.g,a.b,a.a]);t&&r?s.clearBufferfi(s.DEPTH_STENCIL,0,1,0):t?s.clearBufferfv(s.DEPTH,0,[1]):r&&s.clearBufferiv(s.STENCIL,0,[0])}}}beginCompute(){console.warn("Abstract class.")}compute(){console.warn("Abstract class.")}finishCompute(){console.warn("Abstract class.")}draw(e,t){const{pipeline:r,material:i,context:s}=e,{programGPU:n,vaoGPU:a}=this.get(r),{gl:o,state:u}=this,l=this.get(s),c=e.getBindings();for(const e of c){const t=this.get(e),r=t.index;e.isUniformsGroup||e.isUniformBuffer?o.bindBufferBase(o.UNIFORM_BUFFER,r,t.bufferGPU):e.isSampledTexture&&(o.activeTexture(o.TEXTURE0+r),o.bindTexture(t.glTextureType,t.textureGPU))}u.setMaterial(i),o.useProgram(n),o.bindVertexArray(a);const f=e.getIndex(),d=e.object,g=e.geometry,b=g.drawRange,h=b.start,T=l.lastOcclusionObject;if(T!==d&&void 0!==T){if(null!==T&&!0===T.occlusionTest&&(o.endQuery(o.ANY_SAMPLES_PASSED),l.occlusionQueryIndex++),!0===d.occlusionTest){const e=o.createQuery();o.beginQuery(o.ANY_SAMPLES_PASSED,e),l.occlusionQueries[l.occlusionQueryIndex]=e,l.occlusionQueryObjects[l.occlusionQueryIndex]=d}l.lastOcclusionObject=d}let m;m=d.isPoints?o.POINTS:d.isLineSegments?o.LINES:d.isLine?o.LINE_STRIP:d.isLineLoop?o.LINE_LOOP:o.TRIANGLES;const x=this.getInstanceCount(e);if(null!==f){const e=this.get(f),r=b.count!==1/0?b.count:f.count;x>1?o.drawElementsInstanced(m,f.count,e.type,h,x):o.drawElements(m,f.count,e.type,h),t.update(d,r,1)}else{const e=g.attributes.position,r=b.count!==1/0?b.count:e.count;x>1?o.drawArraysInstanced(m,0,r,x):o.drawArrays(m,0,r),t.update(d,r,1)}o.bindVertexArray(null)}needsRenderUpdate(e){return!1}getRenderCacheKey(e){return e.id}createSampler(){}createDefaultTexture(e){const{gl:t,textureUtils:r,defaultTextures:i}=this,s=r.getGLTextureType(e);let n=i[s];void 0===n&&(n=t.createTexture(),t.bindTexture(s,n),t.texParameteri(s,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(s,t.TEXTURE_MAG_FILTER,t.NEAREST),i[s]=n),this.set(e,{textureGPU:n,glTextureType:s,isDefault:!0})}createTexture(e,t){const{gl:r,utils:i,textureUtils:s}=this,{levels:n,width:a,height:o,depth:u}=t,l=i.convert(e.format,e.colorSpace),c=i.convert(e.type),f=s.getInternalFormat(e.internalFormat,l,c,e.colorSpace,e.isVideoTexture),d=r.createTexture(),g=s.getGLTextureType(e);r.bindTexture(g,d),r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,e.flipY),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.premultiplyAlpha),r.pixelStorei(r.UNPACK_ALIGNMENT,e.unpackAlignment),r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL,r.NONE),s.setTextureParameters(g,e),r.bindTexture(g,d),e.isDataArrayTexture?r.texStorage3D(r.TEXTURE_2D_ARRAY,n,f,a,o,u):e.isVideoTexture||r.texStorage2D(g,n,f,a,o),this.set(e,{textureGPU:d,glTextureType:g,glFormat:l,glType:c,glInternalFormat:f})}updateTexture(e,t){const{gl:r}=this,{width:i,height:s}=t,{textureGPU:n,glTextureType:a,glFormat:o,glType:u,glInternalFormat:l}=this.get(e),c=e=>e.isDataTexture?e.image.data:e instanceof ImageBitmap||e instanceof OffscreenCanvas||e instanceof HTMLImageElement||e instanceof HTMLCanvasElement?e:e.data;if(r.bindTexture(a,n),e.isCubeTexture){const e=t.images;for(let t=0;t<6;t++){const n=c(e[t]);r.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,0,0,i,s,o,u,n)}}else if(e.isDataArrayTexture){const e=t.image;r.texSubImage3D(r.TEXTURE_2D_ARRAY,0,0,0,0,e.width,e.height,e.depth,o,u,e.data)}else if(e.isVideoTexture)e.update(),r.texImage2D(a,0,l,o,u,t.image);else{const e=c(t.image);r.texSubImage2D(a,0,0,0,i,s,o,u,e)}}generateMipmaps(e){const{gl:t}=this,{textureGPU:r,glTextureType:i}=this.get(e);t.bindTexture(i,r),t.generateMipmap(i)}destroyTexture(e){const{gl:t}=this,{textureGPU:r}=this.get(e);t.deleteTexture(r),this.delete(e)}destroySampler(){}copyTextureToBuffer(e,t,r,i,s){return this.textureUtils.copyTextureToBuffer(e,t,r,i,s)}createNodeBuilder(e,t,r=null){return new GLSLNodeBuilder(e,t,r)}createProgram(e){const t=this.gl,{stage:r,code:i}=e,s="vertex"===r?t.createShader(t.VERTEX_SHADER):t.createShader(t.FRAGMENT_SHADER);t.shaderSource(s,i),t.compileShader(s),this.set(e,{shaderGPU:s})}destroyProgram(){console.warn("Abstract class.")}createRenderPipeline(e){const t=this.gl,r=e.pipeline,{fragmentProgram:i,vertexProgram:s}=r,n=t.createProgram(),a=this.get(i).shaderGPU,o=this.get(s).shaderGPU;t.attachShader(n,a),t.attachShader(n,o),t.linkProgram(n),!1===t.getProgramParameter(n,t.LINK_STATUS)&&(console.error("THREE.WebGLBackend:",t.getProgramInfoLog(n)),console.error("THREE.WebGLBackend:",t.getShaderInfoLog(a)),console.error("THREE.WebGLBackend:",t.getShaderInfoLog(o))),t.useProgram(n);const u=e.getBindings();for(const e of u){const r=this.get(e).index;if(e.isUniformsGroup||e.isUniformBuffer){const i=t.getUniformBlockIndex(n,e.name);t.uniformBlockBinding(n,i,r)}else if(e.isSampledTexture){const i=t.getUniformLocation(n,e.name);t.uniform1i(i,r)}}const l=t.createVertexArray(),c=e.getIndex(),f=e.getAttributes();if(t.bindVertexArray(l),null!==c){const e=this.get(c);t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e.bufferGPU)}for(let e=0;e<f.length;e++){const r=f[e],i=this.get(r);let s,n;t.bindBuffer(t.ARRAY_BUFFER,i.bufferGPU),t.enableVertexAttribArray(e),!0===r.isInterleavedBufferAttribute?(s=r.data.stride*i.bytesPerElement,n=r.offset*i.bytesPerElement):(s=0,n=0),i.isInteger?t.vertexAttribIPointer(e,r.itemSize,i.type,s,n):t.vertexAttribPointer(e,r.itemSize,i.type,r.normalized,s,n),r.isInstancedBufferAttribute&&!r.isInterleavedBufferAttribute?t.vertexAttribDivisor(e,r.meshPerAttribute):r.isInterleavedBufferAttribute&&r.data.isInstancedInterleavedBuffer&&t.vertexAttribDivisor(e,r.data.meshPerAttribute)}t.bindVertexArray(null),this.set(r,{programGPU:n,vaoGPU:l})}createComputePipeline(){console.warn("Abstract class.")}createBindings(e){this.updateBindings(e)}updateBindings(e){const{gl:t}=this;let r=0,i=0;for(const s of e)if(s.isUniformsGroup||s.isUniformBuffer){const e=t.createBuffer(),i=s.buffer;t.bindBuffer(t.UNIFORM_BUFFER,e),t.bufferData(t.UNIFORM_BUFFER,i,t.DYNAMIC_DRAW),t.bindBufferBase(t.UNIFORM_BUFFER,r,e),this.set(s,{index:r++,bufferGPU:e})}else if(s.isSampledTexture){const{textureGPU:e,glTextureType:t}=this.get(s.texture);this.set(s,{index:i++,textureGPU:e,glTextureType:t})}}updateBinding(e){const t=this.gl;if(e.isUniformsGroup||e.isUniformBuffer){const r=this.get(e).bufferGPU,i=e.buffer;t.bindBuffer(t.UNIFORM_BUFFER,r),t.bufferData(t.UNIFORM_BUFFER,i,t.DYNAMIC_DRAW)}}createIndexAttribute(e){const t=this.gl;this.attributeUtils.createAttribute(e,t.ELEMENT_ARRAY_BUFFER)}createAttribute(e){const t=this.gl;this.attributeUtils.createAttribute(e,t.ARRAY_BUFFER)}createStorageAttribute(){console.warn("Abstract class.")}updateAttribute(e){this.attributeUtils.updateAttribute(e)}destroyAttribute(){console.warn("Abstract class.")}updateSize(){}hasFeature(){return!0}getMaxAnisotropy(){return this.capabilities.getMaxAnisotropy()}copyFramebufferToTexture(e,t){const{gl:r}=this,{textureGPU:i}=this.get(e),s=e.image.width,n=e.image.height;if(r.bindFramebuffer(r.READ_FRAMEBUFFER,null),e.isDepthTexture){const e=r.createFramebuffer();r.bindFramebuffer(r.DRAW_FRAMEBUFFER,e),r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.TEXTURE_2D,i,0),r.blitFramebuffer(0,0,s,n,0,0,s,n,r.DEPTH_BUFFER_BIT,r.NEAREST),r.deleteFramebuffer(e)}else r.bindTexture(r.TEXTURE_2D,i),r.copyTexSubImage2D(r.TEXTURE_2D,0,0,0,0,0,s,n),r.bindTexture(r.TEXTURE_2D,null);e.generateMipmaps&&this.generateMipmaps(e),this._setFramebuffer(t)}_setFramebuffer(e){const{gl:t}=this;if(null!==e.textures){const r=this.get(e.renderTarget);let i=r.framebuffer;if(void 0===i){i=t.createFramebuffer(),t.bindFramebuffer(t.FRAMEBUFFER,i);const s=e.textures,n=[];for(let e=0;e<s.length;e++){const r=s[e],{textureGPU:i}=this.get(r),a=t.COLOR_ATTACHMENT0+e;t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,i,0),n.push(a)}if(t.drawBuffers(n),null!==e.depthTexture){const{textureGPU:r}=this.get(e.depthTexture);t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,r,0)}r.framebuffer=i}else t.bindFramebuffer(t.FRAMEBUFFER,i)}else t.bindFramebuffer(t.FRAMEBUFFER,null)}}export default WebGLBackend;
//# sourceMappingURL=/sm/020ae7a0f7643c2086dbf20e02b8643fa0f0c696a26b9444b4a808059194ef6b.map