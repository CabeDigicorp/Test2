/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/renderers/webgpu/nodes/WGSLNodeBuilder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{NoColorSpace,FloatType}from"three";import NodeUniformsGroup from"../../common/nodes/NodeUniformsGroup.js";import NodeSampler from"../../common/nodes/NodeSampler.js";import{NodeSampledTexture,NodeSampledCubeTexture}from"../../common/nodes/NodeSampledTexture.js";import UniformBuffer from"../../common/UniformBuffer.js";import StorageBuffer from"../../common/StorageBuffer.js";import{getVectorLength,getStrideLength}from"../../common/BufferUtils.js";import{NodeBuilder,CodeNode,NodeMaterial}from"../../../nodes/Nodes.js";import{getFormat}from"../utils/WebGPUTextureUtils.js";import WGSLNodeParser from"./WGSLNodeParser.js";const gpuShaderStageLib={vertex:GPUShaderStage.VERTEX,fragment:GPUShaderStage.FRAGMENT,compute:GPUShaderStage.COMPUTE},supports={instance:!0},wgslFnOpLib={"^^":"threejs_xor"},wgslTypeLib={float:"f32",int:"i32",uint:"u32",bool:"bool",color:"vec3<f32>",vec2:"vec2<f32>",ivec2:"vec2<i32>",uvec2:"vec2<u32>",bvec2:"vec2<bool>",vec3:"vec3<f32>",ivec3:"vec3<i32>",uvec3:"vec3<u32>",bvec3:"vec3<bool>",vec4:"vec4<f32>",ivec4:"vec4<i32>",uvec4:"vec4<u32>",bvec4:"vec4<bool>",mat3:"mat3x3<f32>",imat3:"mat3x3<i32>",umat3:"mat3x3<u32>",bmat3:"mat3x3<bool>",mat4:"mat4x4<f32>",imat4:"mat4x4<i32>",umat4:"mat4x4<u32>",bmat4:"mat4x4<bool>"},wgslMethods={dFdx:"dpdx",dFdy:"- dpdy",mod:"threejs_mod",lessThanEqual:"threejs_lessThanEqual",greaterThan:"threejs_greaterThan",inversesqrt:"inverseSqrt",bitcast:"bitcast<f32>"},wgslPolyfill={threejs_xor:new CodeNode("\nfn threejs_xor( a : bool, b : bool ) -> bool {\n\n\treturn ( a || b ) && !( a && b );\n\n}\n"),lessThanEqual:new CodeNode("\nfn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {\n\n\treturn vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );\n\n}\n"),greaterThan:new CodeNode("\nfn threejs_greaterThan( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {\n\n\treturn vec3<bool>( a.x > b.x, a.y > b.y, a.z > b.z );\n\n}\n"),mod:new CodeNode("\nfn threejs_mod( x : f32, y : f32 ) -> f32 {\n\n\treturn x - y * floor( x / y );\n\n}\n"),repeatWrapping:new CodeNode("\nfn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {\n\n\tlet uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );\n\n\treturn ( ( uvScaled % dimension ) + dimension ) % dimension;\n\n}\n")};class WGSLNodeBuilder extends NodeBuilder{constructor(e,t,r=null){super(e,t,new WGSLNodeParser,r),this.uniformGroups={},this.builtins={}}build(){const{object:e,material:t}=this;return null!==t?NodeMaterial.fromMaterial(t).build(this):this.addFlow("compute",e),super.build()}needsColorSpaceToLinear(e){return!0===e.isVideoTexture&&e.colorSpace!==NoColorSpace}_generateTextureSample(e,t,r,n,o=this.shaderStage){return"fragment"===o?n?`textureSample( ${t}, ${t}_sampler, ${r}, ${n} )`:`textureSample( ${t}, ${t}_sampler, ${r} )`:this.generateTextureLod(e,t,r)}_generateVideoSample(e,t,r=this.shaderStage){if("fragment"===r)return`textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${t}.x, 1.0 - ${t}.y ) )`;console.error(`WebGPURenderer: THREE.VideoTexture does not support ${r} shader.`)}_generateTextureSampleLevel(e,t,r,n,o,i=this.shaderStage){return"fragment"===i&&!1===this.isUnfilterable(e)?`textureSampleLevel( ${t}, ${t}_sampler, ${r}, ${n} )`:this.generateTextureLod(e,t,r,n)}generateTextureLod(e,t,r,n="0"){this._include("repeatWrapping");return`textureLoad( ${t}, threejs_repeatWrapping( ${r}, ${`textureDimensions( ${t}, 0 )`} ), i32( ${n} ) )`}generateTextureLoad(e,t,r,n,o="0u"){return n?`textureLoad( ${t}, ${r}, ${n}, ${o} )`:`textureLoad( ${t}, ${r}, ${o} )`}isUnfilterable(e){return!0===e.isDataTexture&&e.type===FloatType}generateTexture(e,t,r,n,o=this.shaderStage){let i=null;return i=!0===e.isVideoTexture?this._generateVideoSample(t,r,o):this.isUnfilterable(e)?this.generateTextureLod(e,t,r,"0",n,o):this._generateTextureSample(e,t,r,n,o),i}generateTextureCompare(e,t,r,n,o,i=this.shaderStage){if("fragment"===i)return`textureSampleCompare( ${t}, ${t}_sampler, ${r}, ${n} )`;console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${i} shader.`)}generateTextureLevel(e,t,r,n,o,i=this.shaderStage){let s=null;return s=!0===e.isVideoTexture?this._generateVideoSample(t,r,i):this._generateTextureSampleLevel(e,t,r,n,o,i),s}getPropertyName(e,t=this.shaderStage){if(!0===e.isNodeVarying&&!0===e.needsInterpolation){if("vertex"===t)return`varyings.${e.name}`}else if(!0===e.isNodeUniform){const t=e.name,r=e.type;return"texture"===r||"cubeTexture"===r?t:"buffer"===r||"storageBuffer"===r?`NodeBuffer_${e.id}.${t}`:e.groupNode.name+"."+t}return super.getPropertyName(e)}_getUniformGroupCount(e){return Object.keys(this.uniforms[e]).length}getFunctionOperator(e){const t=wgslFnOpLib[e];return void 0!==t?(this._include(t),t):null}getUniformFromNode(e,t,r,n=null){const o=super.getUniformFromNode(e,t,r,n),i=this.getDataFromNode(e,r,this.globalCache);if(void 0===i.uniformGPU){let n;const s=this.bindings[r];if("texture"===t||"cubeTexture"===t){let i=null;if("texture"===t?i=new NodeSampledTexture(o.name,o.node):"cubeTexture"===t&&(i=new NodeSampledCubeTexture(o.name,o.node)),i.store=!0===e.isStoreTextureNode,i.setVisibility(gpuShaderStageLib[r]),"fragment"===r&&!1===this.isUnfilterable(e.value)&&!1===i.store){const e=new NodeSampler(`${o.name}_sampler`,o.node);e.setVisibility(gpuShaderStageLib[r]),s.push(e,i),n=[e,i]}else s.push(i),n=[i]}else if("buffer"===t||"storageBuffer"===t){const o=new("storageBuffer"===t?StorageBuffer:UniformBuffer)("NodeBuffer_"+e.id,e.value);o.setVisibility(gpuShaderStageLib[r]),s.push(o),n=o}else{const i=e.groupNode,u=i.name,a=this.uniformGroups[r]||(this.uniformGroups[r]={});let l=a[u];if(void 0===l&&(l=new NodeUniformsGroup(u,i),l.setVisibility(gpuShaderStageLib[r]),a[u]=l,s.push(l)),!0===e.isArrayUniformNode){n=[];for(const r of e.nodes){const e=this.getNodeUniform(r,t);e.boundary=getVectorLength(e.itemSize),e.itemSize=getStrideLength(e.itemSize),l.addUniform(e),n.push(e)}}else n=this.getNodeUniform(o,t),l.addUniform(n)}i.uniformGPU=n,"vertex"===r&&(this.bindingsOffset.fragment=s.length)}return o}isReference(e){return super.isReference(e)||"texture_2d"===e||"texture_cube"===e||"texture_depth_2d"===e||"texture_storage_2d"===e}getBuiltin(e,t,r,n=this.shaderStage){const o=this.builtins[n]||(this.builtins[n]=new Map);return!1===o.has(e)&&o.set(e,{name:e,property:t,type:r}),t}getVertexIndex(){return"vertex"===this.shaderStage?this.getBuiltin("vertex_index","vertexIndex","u32","attribute"):"vertexIndex"}buildFunctionCode(e){const t=e.layout,r=this.flowShaderNode(e),n=[];for(const e of t.inputs)n.push(e.name+" : "+this.getType(e.type));return`fn ${t.name}( ${n.join(", ")} ) -> ${this.getType(t.type)} {\n${r.vars}\n${r.code}\n\treturn ${r.result};\n\n}`}getInstanceIndex(){return"vertex"===this.shaderStage?this.getBuiltin("instance_index","instanceIndex","u32","attribute"):"instanceIndex"}getFrontFacing(){return this.getBuiltin("front_facing","isFront","bool")}getFragCoord(){return this.getBuiltin("position","fragCoord","vec4<f32>")+".xy"}getFragDepth(){return"output."+this.getBuiltin("frag_depth","depth","f32","output")}isFlipY(){return!1}getBuiltins(e){const t=[],r=this.builtins[e];if(void 0!==r)for(const{name:e,property:n,type:o}of r.values())t.push(`@builtin( ${e} ) ${n} : ${o}`);return t.join(",\n\t")}getAttributes(e){const t=[];if("compute"===e&&this.getBuiltin("global_invocation_id","id","vec3<u32>","attribute"),"vertex"===e||"compute"===e){const e=this.getBuiltins("attribute");e&&t.push(e);const r=this.getAttributesArray();for(let e=0,n=r.length;e<n;e++){const n=r[e],o=n.name,i=this.getType(n.type);t.push(`@location( ${e} ) ${o} : ${i}`)}}return t.join(",\n\t")}getStructMembers(e){const t=[],r=e.getMemberTypes();for(let e=0;e<r.length;e++){const n=r[e];t.push(`\t@location( ${e} ) m${e} : ${n}<f32>`)}return t.join(",\n")}getStructs(e){const t=[],r=this.structs[e];for(let e=0,n=r.length;e<n;e++){const n=r[e];let o=`struct ${n.name} {\n`;o+=this.getStructMembers(n),o+="\n}",t.push(o)}return t.join("\n\n")}getVar(e,t){return`var ${t} : ${this.getType(e)}`}getVars(e){const t=[],r=this.vars[e];if(void 0!==r)for(const e of r)t.push(`\t${this.getVar(e.type,e.name)};`);return`\n${t.join("\n")}\n`}getVaryings(e){const t=[];if("vertex"===e&&this.getBuiltin("position","Vertex","vec4<f32>","vertex"),"vertex"===e||"fragment"===e){const r=this.varyings,n=this.vars[e];for(let o=0;o<r.length;o++){const i=r[o];if(i.needsInterpolation){let e=`@location( ${o} )`;/^(int|uint|ivec|uvec)/.test(i.type)&&(e+=" @interpolate( flat )"),t.push(`${e} ${i.name} : ${this.getType(i.type)}`)}else"vertex"===e&&!1===n.includes(i)&&n.push(i)}}const r=this.getBuiltins(e);r&&t.push(r);const n=t.join(",\n\t");return"vertex"===e?this._getWGSLStruct("VaryingsStruct","\t"+n):n}getUniforms(e){const t=this.uniforms[e],r=[],n=[],o=[],i={};let s=this.bindingsOffset[e];for(const o of t)if("texture"===o.type||"cubeTexture"===o.type){const t=o.node.value;let n;if("fragment"===e&&!1===this.isUnfilterable(t)&&!0!==o.node.isStoreTextureNode&&(!0===t.isDepthTexture&&null!==t.compareFunction?r.push(`@binding( ${s++} ) @group( 0 ) var ${o.name}_sampler : sampler_comparison;`):r.push(`@binding( ${s++} ) @group( 0 ) var ${o.name}_sampler : sampler;`)),!0===t.isCubeTexture)n="texture_cube<f32>";else if(!0===t.isDataArrayTexture)n="texture_2d_array<f32>";else if(!0===t.isDepthTexture)n="texture_depth_2d";else if(!0===t.isVideoTexture)n="texture_external";else if(!0===o.node.isStoreTextureNode){n="texture_storage_2d<"+getFormat(t)+", write>"}else n="texture_2d<f32>";r.push(`@binding( ${s++} ) @group( 0 ) var ${o.name} : ${n};`)}else if("buffer"===o.type||"storageBuffer"===o.type){const e=o.node,t=this.getType(e.bufferType),r=e.bufferCount,i=r>0?", "+r:"",u=`\t${o.name} : array< ${t}${i} >\n`,a=e.isStorageBufferNode?"storage,read_write":"uniform";n.push(this._getWGSLStructBinding("NodeBuffer_"+e.id,u,a,s++))}else{const e=this.getType(this.getVectorType(o.type)),t=o.groupNode.name,r=i[t]||(i[t]={index:s++,snippets:[]});if(!0===Array.isArray(o.value)){const t=o.value.length;r.snippets.push(`uniform ${e}[ ${t} ] ${o.name}`)}else r.snippets.push(`\t${o.name} : ${e}`)}for(const e in i){const t=i[e];o.push(this._getWGSLStructBinding(e,t.snippets.join(",\n"),"uniform",t.index))}let u=r.join("\n");return u+=n.join("\n"),u+=o.join("\n"),u}buildCode(){const e=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};for(const t in e){const r=e[t];r.uniforms=this.getUniforms(t),r.attributes=this.getAttributes(t),r.varyings=this.getVaryings(t),r.structs=this.getStructs(t),r.vars=this.getVars(t),r.codes=this.getCodes(t);let n="// code\n\n";n+=this.flowCode[t];const o=this.flowNodes[t],i=o[o.length-1],s=i.outputNode,u=void 0!==s&&!0===s.isOutputStructNode;for(const e of o){const o=this.getFlowData(e),a=e.name;if(a&&(n.length>0&&(n+="\n"),n+=`\t// flow -> ${a}\n\t`),n+=`${o.code}\n\t`,e===i&&"compute"!==t)if(n+="// result\n\n\t","vertex"===t)n+=`varyings.Vertex = ${o.result};`;else if("fragment"===t)if(u)r.returnType=s.nodeType,n+=`return ${o.result};`;else{let e="\t@location(0) color: vec4<f32>";const t=this.getBuiltins("output");t&&(e+=",\n\t"+t),r.returnType="OutputStruct",r.structs+=this._getWGSLStruct("OutputStruct",e),r.structs+="\nvar<private> output : OutputStruct;\n\n",n+=`output.color = ${o.result};\n\n\treturn output;`}}r.flow=n}null!==this.material?(this.vertexShader=this._getWGSLVertexCode(e.vertex),this.fragmentShader=this._getWGSLFragmentCode(e.fragment)):this.computeShader=this._getWGSLComputeCode(e.compute,(this.object.workgroupSize||[64]).join(", "))}getMethod(e){return void 0!==wgslPolyfill[e]&&this._include(e),wgslMethods[e]||e}getType(e){return wgslTypeLib[e]||e}isAvailable(e){return!0===supports[e]}_include(e){const t=wgslPolyfill[e];return t.build(this),null!==this.currentFunctionNode&&this.currentFunctionNode.includes.push(t),t}_getWGSLVertexCode(e){return`${this.getSignature()}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${e.codes}\n\n@vertex\nfn main( ${e.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n\treturn varyings;\n\n}\n`}_getWGSLFragmentCode(e){return`${this.getSignature()}\n\n// uniforms\n${e.uniforms}\n\n// structs\n${e.structs}\n\n// codes\n${e.codes}\n\n@fragment\nfn main( ${e.varyings} ) -> ${e.returnType} {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getWGSLComputeCode(e,t){return`${this.getSignature()}\n// system\nvar<private> instanceIndex : u32;\n\n// uniforms\n${e.uniforms}\n\n// codes\n${e.codes}\n\n@compute @workgroup_size( ${t} )\nfn main( ${e.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x;\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getWGSLStruct(e,t){return`\nstruct ${e} {\n${t}\n};`}_getWGSLStructBinding(e,t,r,n=0,o=0){const i=e+"Struct";return`${this._getWGSLStruct(i,t)}\n@binding( ${n} ) @group( ${o} )\nvar<${r}> ${e} : ${i};`}}export default WGSLNodeBuilder;
//# sourceMappingURL=/sm/a4bfbec126c06ebe713b6a30b8e2873cc3dbffd5fa520c420fdf90ccad229629.map