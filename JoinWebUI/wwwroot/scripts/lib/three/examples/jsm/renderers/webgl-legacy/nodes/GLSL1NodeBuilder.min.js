/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/renderers/webgl-legacy/nodes/GLSL1NodeBuilder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{MathNode,GLSLNodeParser,NodeBuilder,NodeMaterial}from"../../../nodes/Nodes.js";const glslMethods={[MathNode.ATAN2]:"atan"},precisionLib={low:"lowp",medium:"mediump",high:"highp"};class GLSL1NodeBuilder extends NodeBuilder{constructor(e,t,n=null){super(e,t,new GLSLNodeParser,n)}getMethod(e){return glslMethods[e]||e}getTexture(e,t,n){return e.isTextureCube?`textureCube( ${t}, ${n} )`:`texture2D( ${t}, ${n} )`}getTextureBias(e,t,n,r){return void 0!==this.material.extensions&&(this.material.extensions.shaderTextureLOD=!0),`textureLod( ${t}, ${n}, ${r} )`}getVars(e){const t=[],n=this.vars[e];for(const e of n)t.push(`${this.getVar(e.type,e.name)};`);return t.join("\n\t")}getUniforms(e){const t=this.uniforms[e];let n="";for(const e of t){let t=null;if("texture"===e.type)t=`sampler2D ${e.name};\n`;else if("cubeTexture"===e.type)t=`samplerCube ${e.name};\n`;else{t=`${this.getVectorType(e.type)} ${e.name};\n`}const r=e.node.precision;t=null!==r?"uniform "+precisionLib[r]+" "+t:"uniform "+t,n+=t}return n}getAttributes(e){let t="";if("vertex"===e){const e=this.attributes;for(const n of e)t+=`attribute ${n.type} ${n.name};\n`}return t}getVaryings(e){let t="";const n=this.varyings;if("vertex"===e)for(const e of n)t+=`${e.needsInterpolation?"varying":"/*varying*/"} ${e.type} ${e.name};\n`;else if("fragment"===e)for(const e of n)e.needsInterpolation&&(t+=`varying ${e.type} ${e.name};\n`);return t}getVertexIndex(){return"gl_VertexID"}getFrontFacing(){return"gl_FrontFacing"}getFragCoord(){return"gl_FragCoord"}isFlipY(){return!0}_getGLSLVertexCode(e){return`${this.getSignature()}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\n\n// attributes\n${e.attributes}\n\n// codes\n${e.codes}\n\nvoid main() {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getGLSLFragmentCode(e){return`${this.getSignature()}\n\n// precision\nprecision highp float;\nprecision highp int;\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\n\n// codes\n${e.codes}\n\nvoid main() {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}buildCode(){const e=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};for(const t in e){let n="// code\n\n";n+=this.flowCode[t];const r=this.flowNodes[t],o=r[r.length-1];for(const e of r){const r=this.getFlowData(e),s=e.name;s&&(n.length>0&&(n+="\n"),n+=`\t// flow -> ${s}\n\t`),n+=`${r.code}\n\t`,e===o&&"compute"!==t&&(n+="// result\n\t","vertex"===t?n+="gl_Position = ":"fragment"===t&&(n+="gl_FragColor = "),n+=`${r.result};`)}const s=e[t];s.uniforms=this.getUniforms(t),s.attributes=this.getAttributes(t),s.varyings=this.getVaryings(t),s.vars=this.getVars(t),s.codes=this.getCodes(t),s.flow=n}null!==this.material?(this.vertexShader=this._getGLSLVertexCode(e.vertex),this.fragmentShader=this._getGLSLFragmentCode(e.fragment)):console.warn("GLSLNodeBuilder: compute shaders are not supported.")}build(){const{object:e,material:t}=this;return null!==t?NodeMaterial.fromMaterial(t).build(this):this.addFlow("compute",e),super.build()}}export default GLSL1NodeBuilder;
//# sourceMappingURL=/sm/5daf34456cd42befb8464a5fdeb4ddb830f774f4763b3c6986fe2e2977becbfb.map