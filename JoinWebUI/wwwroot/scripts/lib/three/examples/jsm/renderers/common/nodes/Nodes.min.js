/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/renderers/common/nodes/Nodes.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import DataMap from"../DataMap.js";import ChainMap from"../ChainMap.js";import NodeBuilderState from"./NodeBuilderState.js";import{NoToneMapping,EquirectangularReflectionMapping,EquirectangularRefractionMapping}from"three";import{NodeFrame,objectGroup,renderGroup,frameGroup,cubeTexture,texture,rangeFog,densityFog,reference,toneMapping,equirectUV,viewportBottomLeft,normalWorld}from"../../../nodes/Nodes.js";class Nodes extends DataMap{constructor(e,t){super(),this.renderer=e,this.backend=t,this.nodeFrame=new NodeFrame,this.nodeBuilderCache=new Map,this.callHashCache=new ChainMap,this.groupsData=new ChainMap}updateGroup(e){const t=e.groupNode,r=t.name;if(r===objectGroup.name)return!0;if(r===renderGroup.name){const t=this.get(e),r=this.nodeFrame.renderId;return t.renderId!==r&&(t.renderId=r,!0)}if(r===frameGroup.name){const t=this.get(e),r=this.nodeFrame.frameId;return t.frameId!==r&&(t.frameId=r,!0)}const o=[t,e];let n=this.groupsData.get(o);return void 0===n&&this.groupsData.set(o,n={}),n.version!==t.version&&(n.version=t.version,!0)}getForRenderCacheKey(e){return e.initialCacheKey}getForRender(e){const t=this.get(e);let r=t.nodeBuilderState;if(void 0===r){const{nodeBuilderCache:o}=this,n=this.getForRenderCacheKey(e);if(r=o.get(n),void 0===r){const t=this.backend.createNodeBuilder(e.object,this.renderer,e.scene);t.material=e.material,t.context.material=e.material,t.lightsNode=e.lightsNode,t.environmentNode=this.getEnvironmentNode(e.scene),t.fogNode=this.getFogNode(e.scene),t.toneMappingNode=this.getToneMappingNode(),t.build(),r=this._createNodeBuilderState(t),o.set(n,r)}r.usedTimes++,t.nodeBuilderState=r}return r}delete(e){if(e.isRenderObject){const t=this.get(e).nodeBuilderState;t.usedTimes--,0===t.usedTimes&&this.nodeBuilderCache.delete(this.getForRenderCacheKey(e))}return super.delete(e)}getForCompute(e){const t=this.get(e);let r=t.nodeBuilderState;if(void 0===r){const o=this.backend.createNodeBuilder(e,this.renderer);o.build(),r=this._createNodeBuilderState(o),t.nodeBuilderState=o}return r}_createNodeBuilderState(e){return new NodeBuilderState(e.vertexShader,e.fragmentShader,e.computeShader,e.getAttributesArray(),e.getBindings(),e.updateNodes,e.updateBeforeNodes)}getEnvironmentNode(e){return e.environmentNode||this.get(e).environmentNode||null}getBackgroundNode(e){return e.backgroundNode||this.get(e).backgroundNode||null}getFogNode(e){return e.fogNode||this.get(e).fogNode||null}getToneMappingNode(){return!1===this.isToneMappingState?null:this.renderer.toneMappingNode||this.get(this.renderer).toneMappingNode||null}getCacheKey(e,t){const r=[e,t],o=this.renderer.info.calls;let n=this.callHashCache.get(r);if(void 0===n||n.callId!==o){const i=this.getEnvironmentNode(e),a=this.getFogNode(e),d=this.getToneMappingNode(),s=[];t&&s.push(t.getCacheKey()),i&&s.push(i.getCacheKey()),a&&s.push(a.getCacheKey()),d&&s.push(d.getCacheKey()),n={callId:o,cacheKey:s.join(",")},this.callHashCache.set(r,n)}return n.cacheKey}updateScene(e){this.updateEnvironment(e),this.updateFog(e),this.updateBackground(e),this.updateToneMapping()}get isToneMappingState(){const e=this.renderer.getRenderTarget();return!e||!e.isCubeRenderTarget}updateToneMapping(){const e=this.renderer,t=this.get(e),r=e.toneMapping;if(this.isToneMappingState&&r!==NoToneMapping){if(t.toneMapping!==r){const o=t.rendererToneMappingNode||toneMapping(r,reference("toneMappingExposure","float",e));o.toneMapping=r,t.rendererToneMappingNode=o,t.toneMappingNode=o,t.toneMapping=r}}else delete t.toneMappingNode,delete t.toneMapping}updateBackground(e){const t=this.get(e),r=e.background;if(r){if(t.background!==r){let e=null;if(!0===r.isCubeTexture)e=cubeTexture(r,normalWorld);else if(!0===r.isTexture){let t=null;t=r.mapping===EquirectangularReflectionMapping||r.mapping===EquirectangularRefractionMapping?equirectUV():viewportBottomLeft,e=texture(r,t).setUpdateMatrix(!0)}else!0!==r.isColor&&console.error("WebGPUNodes: Unsupported background configuration.",r);t.backgroundNode=e,t.background=r}}else t.backgroundNode&&(delete t.backgroundNode,delete t.background)}updateFog(e){const t=this.get(e),r=e.fog;if(r){if(t.fog!==r){let e=null;r.isFogExp2?e=densityFog(reference("color","color",r),reference("density","float",r)):r.isFog?e=rangeFog(reference("color","color",r),reference("near","float",r),reference("far","float",r)):console.error("WebGPUNodes: Unsupported fog configuration.",r),t.fogNode=e,t.fog=r}}else delete t.fogNode,delete t.fog}updateEnvironment(e){const t=this.get(e),r=e.environment;if(r){if(t.environment!==r){let e=null;!0===r.isCubeTexture?e=cubeTexture(r):!0===r.isTexture?e=texture(r):console.error("Nodes: Unsupported environment configuration.",r),t.environmentNode=e,t.environment=r}}else t.environmentNode&&(delete t.environmentNode,delete t.environment)}getNodeFrame(e=this.renderer,t=null,r=null,o=null,n=null){const i=this.nodeFrame;return i.renderer=e,i.scene=t,i.object=r,i.camera=o,i.material=n,i}getNodeFrameForRender(e){return this.getNodeFrame(e.renderer,e.scene,e.object,e.camera,e.material)}updateBefore(e){const t=this.getNodeFrameForRender(e),r=e.getNodeBuilderState();for(const e of r.updateBeforeNodes)t.updateBeforeNode(e)}updateForCompute(e){const t=this.getNodeFrame(),r=this.getForCompute(e);for(const e of r.updateNodes)t.updateNode(e)}updateForRender(e){const t=this.getNodeFrameForRender(e),r=e.getNodeBuilderState();for(const e of r.updateNodes)t.updateNode(e)}dispose(){super.dispose(),this.nodeFrame=new NodeFrame,this.nodeBuilderCache=new Map}}export default Nodes;
//# sourceMappingURL=/sm/4bb96f868d0024f481493d60dc92dc4d41d66f4b3e0bb72bfa736223d75c6fb9.map