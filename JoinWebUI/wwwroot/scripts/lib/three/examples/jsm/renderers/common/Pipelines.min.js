/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/renderers/common/Pipelines.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import DataMap from"./DataMap.js";import RenderPipeline from"./RenderPipeline.js";import ComputePipeline from"./ComputePipeline.js";import ProgrammableStage from"./ProgrammableStage.js";class Pipelines extends DataMap{constructor(e,t){super(),this.backend=e,this.nodes=t,this.bindings=null,this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}getForCompute(e,t){const{backend:r}=this,s=this.get(e);if(this._needsComputeUpdate(e)){const i=s.pipeline;i&&(i.usedTimes--,i.computeProgram.usedTimes--);const a=this.nodes.getForCompute(e);let m=this.programs.compute.get(a.computeShader);void 0===m&&(i&&0===i.computeProgram.usedTimes&&this._releaseProgram(i.computeProgram),m=new ProgrammableStage(a.computeShader,"compute"),this.programs.compute.set(a.computeShader,m),r.createProgram(m));const o=this._getComputeCacheKey(e,m);let n=this.caches.get(o);void 0===n&&(i&&0===i.usedTimes&&this._releasePipeline(e),n=this._getComputePipeline(e,m,o,t)),n.usedTimes++,m.usedTimes++,s.version=e.version,s.pipeline=n}return s.pipeline}getForRender(e){const{backend:t}=this,r=this.get(e);if(this._needsRenderUpdate(e)){const s=r.pipeline;s&&(s.usedTimes--,s.vertexProgram.usedTimes--,s.fragmentProgram.usedTimes--);const i=e.getNodeBuilderState();let a=this.programs.vertex.get(i.vertexShader);void 0===a&&(s&&0===s.vertexProgram.usedTimes&&this._releaseProgram(s.vertexProgram),a=new ProgrammableStage(i.vertexShader,"vertex"),this.programs.vertex.set(i.vertexShader,a),t.createProgram(a));let m=this.programs.fragment.get(i.fragmentShader);void 0===m&&(s&&0===s.fragmentProgram.usedTimes&&this._releaseProgram(s.fragmentProgram),m=new ProgrammableStage(i.fragmentShader,"fragment"),this.programs.fragment.set(i.fragmentShader,m),t.createProgram(m));const o=this._getRenderCacheKey(e,a,m);let n=this.caches.get(o);void 0===n?(s&&0===s.usedTimes&&this._releasePipeline(s),n=this._getRenderPipeline(e,a,m,o)):e.pipeline=n,n.usedTimes++,a.usedTimes++,m.usedTimes++,r.pipeline=n}return r.pipeline}delete(e){const t=this.get(e).pipeline;t&&(t.usedTimes--,0===t.usedTimes&&this._releasePipeline(t),t.isComputePipeline?(t.computeProgram.usedTimes--,0===t.computeProgram.usedTimes&&this._releaseProgram(t.computeProgram)):(t.fragmentProgram.usedTimes--,t.vertexProgram.usedTimes--,0===t.vertexProgram.usedTimes&&this._releaseProgram(t.vertexProgram),0===t.fragmentProgram.usedTimes&&this._releaseProgram(t.fragmentProgram))),super.delete(e)}dispose(){super.dispose(),this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}updateForRender(e){this.getForRender(e)}_getComputePipeline(e,t,r,s){r=r||this._getComputeCacheKey(e,t);let i=this.caches.get(r);return void 0===i&&(i=new ComputePipeline(r,t),this.caches.set(r,i),this.backend.createComputePipeline(i,s)),i}_getRenderPipeline(e,t,r,s){s=s||this._getRenderCacheKey(e,t,r);let i=this.caches.get(s);return void 0===i&&(i=new RenderPipeline(s,t,r),this.caches.set(s,i),e.pipeline=i,this.backend.createRenderPipeline(e)),i}_getComputeCacheKey(e,t){return e.id+","+t.id}_getRenderCacheKey(e,t,r){return t.id+","+r.id+","+this.backend.getRenderCacheKey(e)}_releasePipeline(e){this.caches.delete(e.cacheKey)}_releaseProgram(e){const t=e.code,r=e.stage;this.programs[r].delete(t)}_needsComputeUpdate(e){const t=this.get(e);return void 0===t.pipeline||t.version!==e.version}_needsRenderUpdate(e){return void 0===this.get(e).pipeline||this.backend.needsRenderUpdate(e)}}export default Pipelines;
//# sourceMappingURL=/sm/d7185905e4177ef08f13617bde4b31690b9f1c98b19b9254a1293b8c94cbba19.map