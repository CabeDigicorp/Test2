/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.160.1/examples/jsm/renderers/webgl-legacy/nodes/WebGLNodeBuilder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{defaultShaderStages,NodeFrame,MathNode,GLSLNodeParser,NodeBuilder,normalView}from"../../../nodes/Nodes.js";import SlotNode from"./SlotNode.js";import{PerspectiveCamera,ShaderChunk,ShaderLib,UniformsUtils,UniformsLib}from"three";const nodeFrame=new NodeFrame;nodeFrame.camera=new PerspectiveCamera;const nodeShaderLib={LineBasicNodeMaterial:ShaderLib.basic,MeshBasicNodeMaterial:ShaderLib.basic,PointsNodeMaterial:ShaderLib.points,MeshStandardNodeMaterial:ShaderLib.standard,MeshPhysicalNodeMaterial:ShaderLib.physical,MeshPhongNodeMaterial:ShaderLib.phong},glslMethods={[MathNode.ATAN2]:"atan"},precisionLib={low:"lowp",medium:"mediump",high:"highp"};function getIncludeSnippet(e){return`#include <${e}>`}function getShaderStageProperty(e){return`${e}Shader`}class WebGLNodeBuilder extends NodeBuilder{constructor(e,t,o,n=null){super(e,t,new GLSLNodeParser,null,n),this.shader=o,this.slots={vertex:[],fragment:[]},this._parseShaderLib(),this._parseInclude("fragment","lights_physical_fragment","clearcoat_normal_fragment_begin","transmission_fragment"),this._parseObject(),this._sortSlotsToFlow()}getMethod(e){return glslMethods[e]||e}addSlot(e,t){this.slots[e].push(t)}_parseShaderLib(){const e=this.material;let t=e.type;if(e.isMeshPhysicalNodeMaterial?t="MeshPhysicalNodeMaterial":e.isMeshStandardNodeMaterial?t="MeshStandardNodeMaterial":e.isMeshPhongNodeMaterial?t="MeshPhongNodeMaterial":e.isMeshBasicNodeMaterial?t="MeshBasicNodeMaterial":e.isPointsNodeMaterial?t="PointsNodeMaterial":e.isLineBasicNodeMaterial&&(t="LineBasicNodeMaterial"),void 0!==nodeShaderLib[t]){const e=nodeShaderLib[t],o=this.shader;o.vertexShader=e.vertexShader,o.fragmentShader=e.fragmentShader,o.uniforms=UniformsUtils.merge([e.uniforms,UniformsLib.lights])}}_parseObject(){const{material:e,renderer:t}=this;this.addSlot("fragment",new SlotNode({node:normalView,nodeType:"vec3",source:getIncludeSnippet("clipping_planes_fragment"),target:"vec3 TransformedNormalView = %RESULT%;",inclusionType:"append"})),t.toneMappingNode&&!0===t.toneMappingNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.colorNode,nodeType:"vec4",source:getIncludeSnippet("tonemapping_fragment"),target:""})),e.colorNode&&e.colorNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.colorNode,nodeType:"vec4",source:"vec4 diffuseColor = vec4( diffuse, opacity );",target:"vec4 diffuseColor = %RESULT%; diffuseColor.a *= opacity;"})),e.opacityNode&&e.opacityNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.opacityNode,nodeType:"float",source:getIncludeSnippet("alphatest_fragment"),target:"diffuseColor.a = %RESULT%;",inclusionType:"append"})),e.normalNode&&e.normalNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.normalNode,nodeType:"vec3",source:getIncludeSnippet("normal_fragment_begin"),target:"normal = %RESULT%;",inclusionType:"append"})),e.emissiveNode&&e.emissiveNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.emissiveNode,nodeType:"vec3",source:getIncludeSnippet("emissivemap_fragment"),target:"totalEmissiveRadiance = %RESULT%;",inclusionType:"append"})),e.isMeshStandardNodeMaterial&&(e.metalnessNode&&e.metalnessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.metalnessNode,nodeType:"float",source:getIncludeSnippet("metalnessmap_fragment"),target:"metalnessFactor = %RESULT%;",inclusionType:"append"})),e.roughnessNode&&e.roughnessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.roughnessNode,nodeType:"float",source:getIncludeSnippet("roughnessmap_fragment"),target:"roughnessFactor = %RESULT%;",inclusionType:"append"})),e.isMeshPhysicalNodeMaterial&&(e.clearcoatNode&&e.clearcoatNode.isNode?(this.addSlot("fragment",new SlotNode({node:e.clearcoatNode,nodeType:"float",source:"material.clearcoat = clearcoat;",target:"material.clearcoat = %RESULT%;"})),e.clearcoatRoughnessNode&&e.clearcoatRoughnessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.clearcoatRoughnessNode,nodeType:"float",source:"material.clearcoatRoughness = clearcoatRoughness;",target:"material.clearcoatRoughness = %RESULT%;"})),e.clearcoatNormalNode&&e.clearcoatNormalNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.clearcoatNormalNode,nodeType:"vec3",source:"vec3 clearcoatNormal = nonPerturbedNormal;",target:"vec3 clearcoatNormal = %RESULT%;"})),e.defines.USE_CLEARCOAT=""):delete e.defines.USE_CLEARCOAT,e.sheenNode&&e.sheenNode.isNode?(this.addSlot("fragment",new SlotNode({node:e.sheenNode,nodeType:"vec3",source:"material.sheenColor = sheenColor;",target:"material.sheenColor = %RESULT%;"})),e.sheenRoughnessNode&&e.sheenRoughnessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.sheenRoughnessNode,nodeType:"float",source:"material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );",target:"material.sheenRoughness = clamp( %RESULT%, 0.07, 1.0 );"})),e.defines.USE_SHEEN=""):delete e.defines.USE_SHEEN,e.iridescenceNode&&e.iridescenceNode.isNode?(this.addSlot("fragment",new SlotNode({node:e.iridescenceNode,nodeType:"float",source:"material.iridescence = iridescence;",target:"material.iridescence = %RESULT%;"})),e.iridescenceIORNode&&e.iridescenceIORNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.iridescenceIORNode,nodeType:"float",source:"material.iridescenceIOR = iridescenceIOR;",target:"material.iridescenceIOR = %RESULT%;"})),e.iridescenceThicknessNode&&e.iridescenceThicknessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.iridescenceThicknessNode,nodeType:"float",source:"material.iridescenceThickness = iridescenceThicknessMaximum;",target:"material.iridescenceThickness = %RESULT%;"})),e.defines.USE_IRIDESCENCE=""):delete e.defines.USE_IRIDESCENCE,e.iorNode&&e.iorNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.iorNode,nodeType:"float",source:"material.ior = ior;",target:"material.ior = %RESULT%;"})),e.specularColorNode&&e.specularColorNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.specularColorNode,nodeType:"vec3",source:"vec3 specularColorFactor = specularColor;",target:"vec3 specularColorFactor = %RESULT%;"})),e.specularIntensityNode&&e.specularIntensityNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.specularIntensityNode,nodeType:"float",source:"float specularIntensityFactor = specularIntensity;",target:"float specularIntensityFactor = %RESULT%;"})),e.transmissionNode&&e.transmissionNode.isNode?(this.addSlot("fragment",new SlotNode({node:e.transmissionNode,nodeType:"float",source:"material.transmission = transmission;",target:"material.transmission = %RESULT%;"})),e.thicknessNode&&e.thicknessNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.thicknessNode,nodeType:"float",source:"material.thickness = thickness;",target:"material.thickness = %RESULT%;"})),e.attenuationDistanceNode&&e.attenuationDistanceNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.attenuationDistanceNode,nodeType:"float",source:"material.attenuationDistance = attenuationDistance;",target:"material.attenuationDistance = %RESULT%;"})),e.attenuationColorNode&&e.attenuationColorNode.isNode&&this.addSlot("fragment",new SlotNode({node:e.attenuationColorNode,nodeType:"vec3",source:"material.attenuationColor = attenuationColor;",target:"material.attenuationColor = %RESULT%;"})),e.transmission=1,e.defines.USE_TRANSMISSION=""):(e.transmission=0,delete e.defines.USE_TRANSMISSION))),e.positionNode&&e.positionNode.isNode&&this.addSlot("vertex",new SlotNode({node:e.positionNode,nodeType:"vec3",source:getIncludeSnippet("begin_vertex"),target:"transformed = %RESULT%;",inclusionType:"append"})),e.sizeNode&&e.sizeNode.isNode&&this.addSlot("vertex",new SlotNode({node:e.sizeNode,nodeType:"float",source:"gl_PointSize = size;",target:"gl_PointSize = %RESULT%;"}))}generateTexture(e,t,o){return e.isTextureCube?`textureCube( ${t}, ${o} )`:`texture2D( ${t}, ${o} )`}generateTextureLevel(e,t,o,n){return void 0!==this.material.extensions&&(this.material.extensions.shaderTextureLOD=!0),`textureLod( ${t}, ${o}, ${n} )`}buildFunctionCode(e){const t=e.layout,o=this.flowShaderNode(e),n=[];for(const e of t.inputs)n.push(this.getType(e.type)+" "+e.name);return`${this.getType(t.type)} ${t.name}( ${n.join(", ")} ) {\n\n\t${o.vars}\n\n${o.code}\n\treturn ${o.result};\n\n}`}getUniforms(e){const t=this.uniforms[e];let o="";for(const e of t){if(/^(modelViewMatrix|projectionMatrix)$/.test(e.name))continue;let t=null;if("texture"===e.type)t=`sampler2D ${e.name}; `;else if("cubeTexture"===e.type)t=`samplerCube ${e.name}; `;else{t=`${this.getVectorType(e.type)} ${e.name}; `}const n=e.node.precision;t=null!==n?"uniform "+precisionLib[n]+" "+t:"uniform "+t,o+=t}return o}getAttributes(e){let t="";if("vertex"===e){const e=this.attributes;for(const o of e)/^(position|normal|uv[1-3]?)$/.test(o.name)||(t+=`attribute ${o.type} ${o.name}; `)}return t}getVaryings(e){let t="";const o=this.varyings;if("vertex"===e)for(const e of o)t+=`${e.needsInterpolation?"varying":"/*varying*/"} ${e.type} ${e.name}; `;else if("fragment"===e)for(const e of o)e.needsInterpolation&&(t+=`varying ${e.type} ${e.name}; `);return t}addCode(e,t,o,n=this){const a=getShaderStageProperty(e);let s=n[a];const r=s.indexOf(t);if(-1!==r){const e=s.substring(0,r+t.length),n=s.substring(r+t.length);s=`${e}\n${o}\n${n}`}n[a]=s}replaceCode(e,t,o,n=this){const a=getShaderStageProperty(e);n[a]=n[a].replaceAll(t,o)}getVertexIndex(){return"gl_VertexID"}getFrontFacing(){return"gl_FrontFacing"}getFragCoord(){return"gl_FragCoord"}isFlipY(){return!0}buildCode(){const e={};for(const t of defaultShaderStages){const o=this.getUniforms(t),n=this.getAttributes(t),a=this.getVaryings(t),s=this.getVars(t),r=this.getCodes(t);e[t]=`${this.getSignature()}\n// <node_builder>\n\n// uniforms\n${o}\n\n// attributes\n${n}\n\n// varyings\n${a}\n\n// vars\n${s}\n\n// codes\n${r}\n\n// </node_builder>\n\n${this.shader[getShaderStageProperty(t)]}\n`}this.vertexShader=e.vertex,this.fragmentShader=e.fragment}build(){return super.build(),this._addSnippets(),this._addUniforms(),this._updateUniforms(),this.shader.vertexShader=this.vertexShader,this.shader.fragmentShader=this.fragmentShader,this}_parseInclude(e,...t){for(const o of t){const t=getIncludeSnippet(o),n=ShaderChunk[o],a=getShaderStageProperty(e);this.shader[a]=this.shader[a].replaceAll(t,n)}}_sortSlotsToFlow(){for(const e of defaultShaderStages){const t=this.shader[getShaderStageProperty(e)],o=this.slots[e].sort(((e,o)=>t.indexOf(e.source)>t.indexOf(o.source)?1:-1));for(const t of o)this.addFlow(e,t)}}_addSnippets(){for(const e of defaultShaderStages){for(const t of this.slots[e]){const o=this.getFlowData(t),n=t.inclusionType,a=t.source,s=o.code+"\n\t"+t.target.replace("%RESULT%",o.result);"append"===n?this.addCode(e,a,s):"replace"===n?this.replaceCode(e,a,s):console.warn(`Inclusion type "${n}" not compatible.`)}this.addCode(e,"main() {","\n\t"+this.flowCode[e])}}_addUniforms(){for(const e of defaultShaderStages)for(const t of this.uniforms[e])this.shader.uniforms[t.name]=t}_updateUniforms(){nodeFrame.object=this.object,nodeFrame.renderer=this.renderer;for(const e of this.updateNodes)nodeFrame.updateNode(e)}}export{WebGLNodeBuilder};
//# sourceMappingURL=/sm/f74487b3fb6759d9b5e4bbcbf825ca6e79005f31328d912558f4338516ed9094.map