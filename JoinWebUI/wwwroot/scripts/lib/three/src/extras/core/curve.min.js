/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/extras/core/Curve.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import*as MathUtils from"../../math/MathUtils.js";import{Vector2}from"../../math/Vector2.js";import{Vector3}from"../../math/Vector3.js";import{Matrix4}from"../../math/Matrix4.js";class Curve{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const s=this.getUtoTmapping(t);return this.getPoint(s,e)}getPoints(t=5){const e=[];for(let s=0;s<=t;s++)e.push(this.getPoint(s/t));return e}getSpacedPoints(t=5){const e=[];for(let s=0;s<=t;s++)e.push(this.getPointAt(s/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let s,n=this.getPoint(0),r=0;e.push(0);for(let o=1;o<=t;o++)s=this.getPoint(o/t),r+=s.distanceTo(n),e.push(r),n=s;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const s=this.getLengths();let n=0;const r=s.length;let o;o=e||t*s[r-1];let i,c=0,h=r-1;for(;c<=h;)if(n=Math.floor(c+(h-c)/2),i=s[n]-o,i<0)c=n+1;else{if(!(i>0)){h=n;break}h=n-1}if(n=h,s[n]===o)return n/(r-1);const a=s[n];return(n+(o-a)/(s[n+1]-a))/(r-1)}getTangent(t,e){const s=1e-4;let n=t-s,r=t+s;n<0&&(n=0),r>1&&(r=1);const o=this.getPoint(n),i=this.getPoint(r),c=e||(o.isVector2?new Vector2:new Vector3);return c.copy(i).sub(o).normalize(),c}getTangentAt(t,e){const s=this.getUtoTmapping(t);return this.getTangent(s,e)}computeFrenetFrames(t,e){const s=new Vector3,n=[],r=[],o=[],i=new Vector3,c=new Matrix4;for(let e=0;e<=t;e++){const s=e/t;n[e]=this.getTangentAt(s,new Vector3)}r[0]=new Vector3,o[0]=new Vector3;let h=Number.MAX_VALUE;const a=Math.abs(n[0].x),g=Math.abs(n[0].y),l=Math.abs(n[0].z);a<=h&&(h=a,s.set(1,0,0)),g<=h&&(h=g,s.set(0,1,0)),l<=h&&s.set(0,0,1),i.crossVectors(n[0],s).normalize(),r[0].crossVectors(n[0],i),o[0].crossVectors(n[0],r[0]);for(let e=1;e<=t;e++){if(r[e]=r[e-1].clone(),o[e]=o[e-1].clone(),i.crossVectors(n[e-1],n[e]),i.length()>Number.EPSILON){i.normalize();const t=Math.acos(MathUtils.clamp(n[e-1].dot(n[e]),-1,1));r[e].applyMatrix4(c.makeRotationAxis(i,t))}o[e].crossVectors(n[e],r[e])}if(!0===e){let e=Math.acos(MathUtils.clamp(r[0].dot(r[t]),-1,1));e/=t,n[0].dot(i.crossVectors(r[0],r[t]))>0&&(e=-e);for(let s=1;s<=t;s++)r[s].applyMatrix4(c.makeRotationAxis(n[s],e*s)),o[s].crossVectors(n[s],r[s])}return{tangents:n,normals:r,binormals:o}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}export{Curve};
//# sourceMappingURL=/sm/f74b418b00601a4e7440139da73301316571a1dd29812c2e0f3ea89d4431aa8b.map