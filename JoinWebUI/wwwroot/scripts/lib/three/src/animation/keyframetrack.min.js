/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/animation/KeyframeTrack.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{InterpolateLinear,InterpolateSmooth,InterpolateDiscrete}from"../constants.js";import{CubicInterpolant}from"../math/interpolants/CubicInterpolant.js";import{LinearInterpolant}from"../math/interpolants/LinearInterpolant.js";import{DiscreteInterpolant}from"../math/interpolants/DiscreteInterpolant.js";import*as AnimationUtils from"./AnimationUtils.js";class KeyframeTrack{constructor(t,e,r,i){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=AnimationUtils.convertArray(e,this.TimeBufferType),this.values=AnimationUtils.convertArray(r,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let r;if(e.toJSON!==this.toJSON)r=e.toJSON(t);else{r={name:t.name,times:AnimationUtils.convertArray(t.times,Array),values:AnimationUtils.convertArray(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(r.interpolation=e)}return r.type=t.ValueTypeName,r}InterpolantFactoryMethodDiscrete(t){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new LinearInterpolant(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new CubicInterpolant(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case InterpolateDiscrete:e=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:e=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let r=0,i=e.length;r!==i;++r)e[r]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let r=0,i=e.length;r!==i;++r)e[r]*=t}return this}trim(t,e){const r=this.times,i=r.length;let o=0,n=i-1;for(;o!==i&&r[o]<t;)++o;for(;-1!==n&&r[n]>e;)--n;if(++n,0!==o||n!==i){o>=n&&(n=Math.max(n,1),o=n-1);const t=this.getValueSize();this.times=r.slice(o,n),this.values=this.values.slice(o*t,n*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const r=this.times,i=this.values,o=r.length;0===o&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let n=null;for(let e=0;e!==o;e++){const i=r[e];if("number"==typeof i&&isNaN(i)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,i),t=!1;break}if(null!==n&&n>i){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,i,n),t=!1;break}n=i}if(void 0!==i&&AnimationUtils.isTypedArray(i))for(let e=0,r=i.length;e!==r;++e){const r=i[e];if(isNaN(r)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,r),t=!1;break}}return t}optimize(){const t=this.times.slice(),e=this.values.slice(),r=this.getValueSize(),i=this.getInterpolation()===InterpolateSmooth,o=t.length-1;let n=1;for(let a=1;a<o;++a){let o=!1;const s=t[a];if(s!==t[a+1]&&(1!==a||s!==t[0]))if(i)o=!0;else{const t=a*r,i=t-r,n=t+r;for(let a=0;a!==r;++a){const r=e[t+a];if(r!==e[i+a]||r!==e[n+a]){o=!0;break}}}if(o){if(a!==n){t[n]=t[a];const i=a*r,o=n*r;for(let t=0;t!==r;++t)e[o+t]=e[i+t]}++n}}if(o>0){t[n]=t[o];for(let t=o*r,i=n*r,a=0;a!==r;++a)e[i+a]=e[t+a];++n}return n!==t.length?(this.times=t.slice(0,n),this.values=e.slice(0,n*r)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),r=new(0,this.constructor)(this.name,t,e);return r.createInterpolant=this.createInterpolant,r}}KeyframeTrack.prototype.TimeBufferType=Float32Array,KeyframeTrack.prototype.ValueBufferType=Float32Array,KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;export{KeyframeTrack};
//# sourceMappingURL=/sm/6d9ed4f615d0068c9f08dddf7dda96ad1e66a7f1359e70f05495d592b69bf3f8.map