/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/renderers/common/Renderer.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Animation from"./Animation.js";import RenderObjects from"./RenderObjects.js";import Attributes from"./Attributes.js";import Geometries from"./Geometries.js";import Info from"./Info.js";import Pipelines from"./Pipelines.js";import Bindings from"./Bindings.js";import RenderLists from"./RenderLists.js";import RenderContexts from"./RenderContexts.js";import Textures from"./Textures.js";import Background from"./Background.js";import Nodes from"./nodes/Nodes.js";import Color4 from"./Color4.js";import ClippingContext from"./ClippingContext.js";import QuadMesh from"./QuadMesh.js";import RenderBundles from"./RenderBundles.js";import NodeLibrary from"./nodes/NodeLibrary.js";import Lighting from"./Lighting.js";import NodeMaterial from"../../materials/nodes/NodeMaterial.js";import{Scene}from"../../scenes/Scene.js";import{Frustum}from"../../math/Frustum.js";import{Matrix4}from"../../math/Matrix4.js";import{Vector2}from"../../math/Vector2.js";import{Vector4}from"../../math/Vector4.js";import{RenderTarget}from"../../core/RenderTarget.js";import{DoubleSide,BackSide,FrontSide,SRGBColorSpace,NoToneMapping,LinearFilter,LinearSRGBColorSpace,HalfFloatType,RGBAFormat,PCFShadowMap}from"../../constants.js";const _scene=new Scene,_drawingBufferSize=new Vector2,_screen=new Vector4,_frustum=new Frustum,_projScreenMatrix=new Matrix4,_vector4=new Vector4;class Renderer{constructor(e,t={}){this.isRenderer=!0;const{logarithmicDepthBuffer:i=!1,alpha:r=!0,depth:s=!0,stencil:n=!1,antialias:o=!1,samples:a=0,getFallback:h=null}=t;this.domElement=e.getDomElement(),this.backend=e,this.samples=a||!0===o?4:0,this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.alpha=r,this.logarithmicDepthBuffer=i,this.outputColorSpace=SRGBColorSpace,this.toneMapping=NoToneMapping,this.toneMappingExposure=1,this.sortObjects=!0,this.depth=s,this.stencil=n,this.clippingPlanes=[],this.info=new Info,this.nodes={modelViewMatrix:null,modelNormalViewMatrix:null},this.library=new NodeLibrary,this.lighting=new Lighting,this._getFallback=h,this._pixelRatio=1,this._width=this.domElement.width,this._height=this.domElement.height,this._viewport=new Vector4(0,0,this._width,this._height),this._scissor=new Vector4(0,0,this._width,this._height),this._scissorTest=!1,this._attributes=null,this._geometries=null,this._nodes=null,this._animation=null,this._bindings=null,this._objects=null,this._pipelines=null,this._bundles=null,this._renderLists=null,this._renderContexts=null,this._textures=null,this._background=null,this._quad=new QuadMesh(new NodeMaterial),this._quad.material.type="Renderer_output",this._currentRenderContext=null,this._opaqueSort=null,this._transparentSort=null,this._frameBufferTarget=null;const d=!0===this.alpha?0:1;this._clearColor=new Color4(0,0,0,d),this._clearDepth=1,this._clearStencil=0,this._renderTarget=null,this._activeCubeFace=0,this._activeMipmapLevel=0,this._mrt=null,this._renderObjectFunction=null,this._currentRenderObjectFunction=null,this._currentRenderBundle=null,this._handleObjectFunction=this._renderObjectDirect,this._isDeviceLost=!1,this.onDeviceLost=this._onDeviceLost,this._initialized=!1,this._initPromise=null,this._compilationPromises=null,this.transparent=!0,this.opaque=!0,this.shadowMap={enabled:!1,type:PCFShadowMap},this.xr={enabled:!1},this.debug={checkShaderErrors:!0,onShaderError:null,getShaderAsync:async(e,t,i)=>{await this.compileAsync(e,t);const r=this._renderLists.get(e,t),s=this._renderContexts.get(e,t,this._renderTarget),n=e.overrideMaterial||i.material,o=this._objects.get(i,n,e,t,r.lightsNode,s),{fragmentShader:a,vertexShader:h}=o.getNodeBuilderState();return{fragmentShader:a,vertexShader:h}}}}async init(){if(this._initialized)throw new Error("Renderer: Backend has already been initialized.");return null!==this._initPromise||(this._initPromise=new Promise((async(e,t)=>{let i=this.backend;try{await i.init(this)}catch(e){if(null===this._getFallback)return void t(e);try{this.backend=i=this._getFallback(e),await i.init(this)}catch(e){return void t(e)}}this._nodes=new Nodes(this,i),this._animation=new Animation(this._nodes,this.info),this._attributes=new Attributes(i),this._background=new Background(this,this._nodes),this._geometries=new Geometries(this._attributes,this.info),this._textures=new Textures(this,i,this.info),this._pipelines=new Pipelines(i,this._nodes),this._bindings=new Bindings(i,this._nodes,this._textures,this._attributes,this._pipelines,this.info),this._objects=new RenderObjects(this,this._nodes,this._geometries,this._pipelines,this._bindings,this.info),this._renderLists=new RenderLists(this.lighting),this._bundles=new RenderBundles,this._renderContexts=new RenderContexts,this._initialized=!0,e()}))),this._initPromise}get coordinateSystem(){return this.backend.coordinateSystem}async compileAsync(e,t,i=null){if(!0===this._isDeviceLost)return;!1===this._initialized&&await this.init();const r=this._nodes.nodeFrame,s=r.renderId,n=this._currentRenderContext,o=this._currentRenderObjectFunction,a=this._compilationPromises,h=!0===e.isScene?e:_scene;null===i&&(i=e);const d=this._renderTarget,l=this._renderContexts.get(i,t,d),c=this._activeMipmapLevel,u=[];this._currentRenderContext=l,this._currentRenderObjectFunction=this.renderObject,this._handleObjectFunction=this._createObjectPipeline,this._compilationPromises=u,r.renderId++,r.update(),l.depth=this.depth,l.stencil=this.stencil,l.clippingContext||(l.clippingContext=new ClippingContext),l.clippingContext.updateGlobal(this,t),h.onBeforeRender(this,e,t,d);const p=this._renderLists.get(e,t);if(p.begin(),this._projectObject(e,t,0,p),i!==e&&i.traverseVisible((function(e){e.isLight&&e.layers.test(t.layers)&&p.pushLight(e)})),p.finish(),null!==d){this._textures.updateRenderTarget(d,c);const e=this._textures.get(d);l.textures=e.textures,l.depthTexture=e.depthTexture}else l.textures=null,l.depthTexture=null;this._nodes.updateScene(h),this._background.update(h,p,l);const _=p.opaque,m=p.transparent,g=p.lightsNode;!0===this.opaque&&_.length>0&&this._renderObjects(_,t,h,g),!0===this.transparent&&m.length>0&&this._renderTransparents(m,t,h,g),r.renderId=s,this._currentRenderContext=n,this._currentRenderObjectFunction=o,this._compilationPromises=a,this._handleObjectFunction=this._renderObjectDirect,await Promise.all(u)}async renderAsync(e,t){!1===this._initialized&&await this.init();const i=this._renderScene(e,t);await this.backend.resolveTimestampAsync(i,"render")}async waitForGPU(){await this.backend.waitForGPU()}setMRT(e){return this._mrt=e,this}getMRT(){return this._mrt}_onDeviceLost(e){let t=`THREE.WebGPURenderer: ${e.api} Device Lost:\n\nMessage: ${e.message}`;e.reason&&(t+=`\nReason: ${e.reason}`),console.error(t),this._isDeviceLost=!0}_renderBundle(e,t,i){const{bundleGroup:r,camera:s,renderList:n}=e,o=this._currentRenderContext,a=this._bundles.get(r,s),h=this.backend.get(a);void 0===h.renderContexts&&(h.renderContexts=new Set);const d=r.version!==h.version,l=!1===h.renderContexts.has(o)||d;if(h.renderContexts.add(o),l){this.backend.beginBundle(o),(void 0===h.renderObjects||d)&&(h.renderObjects=[]),this._currentRenderBundle=a;const e=n.opaque;!0===this.opaque&&e.length>0&&this._renderObjects(e,s,t,i),this._currentRenderBundle=null,this.backend.finishBundle(o,a),h.version=r.version}else{const{renderObjects:e}=h;for(let t=0,i=e.length;t<i;t++){const i=e[t];this._nodes.needsRefresh(i)&&(this._nodes.updateBefore(i),this._nodes.updateForRender(i),this._bindings.updateForRender(i),this._nodes.updateAfter(i))}}this.backend.addBundle(o,a)}render(e,t){if(!1===this._initialized)return console.warn("THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead."),this.renderAsync(e,t);this._renderScene(e,t)}_getFrameBufferTarget(){const{currentToneMapping:e,currentColorSpace:t}=this;if(!1===(e!==NoToneMapping)&&!1===(t!==LinearSRGBColorSpace))return null;const{width:i,height:r}=this.getDrawingBufferSize(_drawingBufferSize),{depth:s,stencil:n}=this;let o=this._frameBufferTarget;return null===o&&(o=new RenderTarget(i,r,{depthBuffer:s,stencilBuffer:n,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace,generateMipmaps:!1,minFilter:LinearFilter,magFilter:LinearFilter,samples:this.samples}),o.isPostProcessingRenderTarget=!0,this._frameBufferTarget=o),o.depthBuffer=s,o.stencilBuffer=n,o.setSize(i,r),o.viewport.copy(this._viewport),o.scissor.copy(this._scissor),o.viewport.multiplyScalar(this._pixelRatio),o.scissor.multiplyScalar(this._pixelRatio),o.scissorTest=this._scissorTest,o}_renderScene(e,t,i=!0){if(!0===this._isDeviceLost)return;const r=i?this._getFrameBufferTarget():null,s=this._nodes.nodeFrame,n=s.renderId,o=this._currentRenderContext,a=this._currentRenderObjectFunction,h=!0===e.isScene?e:_scene,d=this._renderTarget,l=this._activeCubeFace,c=this._activeMipmapLevel;let u;null!==r?(u=r,this.setRenderTarget(u)):u=d;const p=this._renderContexts.get(e,t,u);this._currentRenderContext=p,this._currentRenderObjectFunction=this._renderObjectFunction||this.renderObject,this.info.calls++,this.info.render.calls++,this.info.render.frameCalls++,s.renderId=this.info.calls;const _=this.coordinateSystem;t.coordinateSystem!==_&&(t.coordinateSystem=_,t.updateProjectionMatrix()),!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),null===t.parent&&!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld();let m=this._viewport,g=this._scissor,f=this._pixelRatio;null!==u&&(m=u.viewport,g=u.scissor,f=1),this.getDrawingBufferSize(_drawingBufferSize),_screen.set(0,0,_drawingBufferSize.width,_drawingBufferSize.height);const b=void 0===m.minDepth?0:m.minDepth,x=void 0===m.maxDepth?1:m.maxDepth;p.viewportValue.copy(m).multiplyScalar(f).floor(),p.viewportValue.width>>=c,p.viewportValue.height>>=c,p.viewportValue.minDepth=b,p.viewportValue.maxDepth=x,p.viewport=!1===p.viewportValue.equals(_screen),p.scissorValue.copy(g).multiplyScalar(f).floor(),p.scissor=this._scissorTest&&!1===p.scissorValue.equals(_screen),p.scissorValue.width>>=c,p.scissorValue.height>>=c,p.clippingContext||(p.clippingContext=new ClippingContext),p.clippingContext.updateGlobal(this,t),h.onBeforeRender(this,e,t,u),_projScreenMatrix.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),_frustum.setFromProjectionMatrix(_projScreenMatrix,_);const R=this._renderLists.get(e,t);if(R.begin(),this._projectObject(e,t,0,R),R.finish(),!0===this.sortObjects&&R.sort(this._opaqueSort,this._transparentSort),null!==u){this._textures.updateRenderTarget(u,c);const e=this._textures.get(u);p.textures=e.textures,p.depthTexture=e.depthTexture,p.width=e.width,p.height=e.height,p.renderTarget=u,p.depth=u.depthBuffer,p.stencil=u.stencilBuffer}else p.textures=null,p.depthTexture=null,p.width=this.domElement.width,p.height=this.domElement.height,p.depth=this.depth,p.stencil=this.stencil;p.width>>=c,p.height>>=c,p.activeCubeFace=l,p.activeMipmapLevel=c,p.occlusionQueryCount=R.occlusionQueryCount,this._nodes.updateScene(h),this._background.update(h,R,p),this.backend.beginRender(p);const{bundles:w,lightsNode:S,transparentDoublePass:y,transparent:C,opaque:T}=R;if(w.length>0&&this._renderBundles(w,h,S),!0===this.opaque&&T.length>0&&this._renderObjects(T,t,h,S),!0===this.transparent&&C.length>0&&this._renderTransparents(C,y,t,h,S),this.backend.finishRender(p),s.renderId=n,this._currentRenderContext=o,this._currentRenderObjectFunction=a,null!==r){this.setRenderTarget(d,l,c);const e=this._quad;this._nodes.hasOutputChange(u.texture)&&(e.material.fragmentNode=this._nodes.getOutputNode(u.texture),e.material.needsUpdate=!0),this._renderScene(e,e.camera,!1)}return h.onAfterRender(this,e,t,u),p}getMaxAnisotropy(){return this.backend.getMaxAnisotropy()}getActiveCubeFace(){return this._activeCubeFace}getActiveMipmapLevel(){return this._activeMipmapLevel}async setAnimationLoop(e){!1===this._initialized&&await this.init(),this._animation.setAnimationLoop(e)}async getArrayBufferAsync(e){return await this.backend.getArrayBufferAsync(e)}getContext(){return this.backend.getContext()}getPixelRatio(){return this._pixelRatio}getDrawingBufferSize(e){return e.set(this._width*this._pixelRatio,this._height*this._pixelRatio).floor()}getSize(e){return e.set(this._width,this._height)}setPixelRatio(e=1){this._pixelRatio!==e&&(this._pixelRatio=e,this.setSize(this._width,this._height,!1))}setDrawingBufferSize(e,t,i){this._width=e,this._height=t,this._pixelRatio=i,this.domElement.width=Math.floor(e*i),this.domElement.height=Math.floor(t*i),this.setViewport(0,0,e,t),this._initialized&&this.backend.updateSize()}setSize(e,t,i=!0){this._width=e,this._height=t,this.domElement.width=Math.floor(e*this._pixelRatio),this.domElement.height=Math.floor(t*this._pixelRatio),!0===i&&(this.domElement.style.width=e+"px",this.domElement.style.height=t+"px"),this.setViewport(0,0,e,t),this._initialized&&this.backend.updateSize()}setOpaqueSort(e){this._opaqueSort=e}setTransparentSort(e){this._transparentSort=e}getScissor(e){const t=this._scissor;return e.x=t.x,e.y=t.y,e.width=t.width,e.height=t.height,e}setScissor(e,t,i,r){const s=this._scissor;e.isVector4?s.copy(e):s.set(e,t,i,r)}getScissorTest(){return this._scissorTest}setScissorTest(e){this._scissorTest=e,this.backend.setScissorTest(e)}getViewport(e){return e.copy(this._viewport)}setViewport(e,t,i,r,s=0,n=1){const o=this._viewport;e.isVector4?o.copy(e):o.set(e,t,i,r),o.minDepth=s,o.maxDepth=n}getClearColor(e){return e.copy(this._clearColor)}setClearColor(e,t=1){this._clearColor.set(e),this._clearColor.a=t}getClearAlpha(){return this._clearColor.a}setClearAlpha(e){this._clearColor.a=e}getClearDepth(){return this._clearDepth}setClearDepth(e){this._clearDepth=e}getClearStencil(){return this._clearStencil}setClearStencil(e){this._clearStencil=e}isOccluded(e){const t=this._currentRenderContext;return t&&this.backend.isOccluded(t,e)}clear(e=!0,t=!0,i=!0){if(!1===this._initialized)return console.warn("THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead."),this.clearAsync(e,t,i);const r=this._renderTarget||this._getFrameBufferTarget();let s=null;if(null!==r&&(this._textures.updateRenderTarget(r),s=this._textures.get(r)),this.backend.clear(e,t,i,s),null!==r&&null===this._renderTarget){const e=this._quad;this._nodes.hasOutputChange(r.texture)&&(e.material.fragmentNode=this._nodes.getOutputNode(r.texture),e.material.needsUpdate=!0),this._renderScene(e,e.camera,!1)}}clearColor(){return this.clear(!0,!1,!1)}clearDepth(){return this.clear(!1,!0,!1)}clearStencil(){return this.clear(!1,!1,!0)}async clearAsync(e=!0,t=!0,i=!0){!1===this._initialized&&await this.init(),this.clear(e,t,i)}clearColorAsync(){return this.clearAsync(!0,!1,!1)}clearDepthAsync(){return this.clearAsync(!1,!0,!1)}clearStencilAsync(){return this.clearAsync(!1,!1,!0)}get currentToneMapping(){return null!==this._renderTarget?NoToneMapping:this.toneMapping}get currentColorSpace(){return null!==this._renderTarget?LinearSRGBColorSpace:this.outputColorSpace}dispose(){this.info.dispose(),this.backend.dispose(),this._animation.dispose(),this._objects.dispose(),this._pipelines.dispose(),this._nodes.dispose(),this._bindings.dispose(),this._renderLists.dispose(),this._renderContexts.dispose(),this._textures.dispose(),this.setRenderTarget(null),this.setAnimationLoop(null)}setRenderTarget(e,t=0,i=0){this._renderTarget=e,this._activeCubeFace=t,this._activeMipmapLevel=i}getRenderTarget(){return this._renderTarget}setRenderObjectFunction(e){this._renderObjectFunction=e}getRenderObjectFunction(){return this._renderObjectFunction}compute(e){if(!0===this.isDeviceLost)return;if(!1===this._initialized)return console.warn("THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."),this.computeAsync(e);const t=this._nodes.nodeFrame,i=t.renderId;this.info.calls++,this.info.compute.calls++,this.info.compute.frameCalls++,t.renderId=this.info.calls;const r=this.backend,s=this._pipelines,n=this._bindings,o=this._nodes,a=Array.isArray(e)?e:[e];if(void 0===a[0]||!0!==a[0].isComputeNode)throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");r.beginCompute(e);for(const t of a){if(!1===s.has(t)){const e=()=>{t.removeEventListener("dispose",e),s.delete(t),n.delete(t),o.delete(t)};t.addEventListener("dispose",e);const i=t.onInitFunction;null!==i&&i.call(t,{renderer:this})}o.updateForCompute(t),n.updateForCompute(t);const i=n.getForCompute(t),a=s.getForCompute(t,i);r.compute(e,t,i,a)}r.finishCompute(e),t.renderId=i}async computeAsync(e){!1===this._initialized&&await this.init(),this.compute(e),await this.backend.resolveTimestampAsync(e,"compute")}async hasFeatureAsync(e){return!1===this._initialized&&await this.init(),this.backend.hasFeature(e)}hasFeature(e){return!1===this._initialized?(console.warn("THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead."),!1):this.backend.hasFeature(e)}copyFramebufferToTexture(e,t=null){if(null!==t)if(t.isVector2)t=_vector4.set(t.x,t.y,e.image.width,e.image.height).floor();else{if(!t.isVector4)return void console.error("THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.");t=_vector4.copy(t).floor()}else t=_vector4.set(0,0,e.image.width,e.image.height);let i,r=this._currentRenderContext;null!==r?i=r.renderTarget:(i=this._renderTarget||this._getFrameBufferTarget(),null!==i&&(this._textures.updateRenderTarget(i),r=this._textures.get(i))),this._textures.updateTexture(e,{renderTarget:i}),this.backend.copyFramebufferToTexture(e,r,t)}copyTextureToTexture(e,t,i=null,r=null,s=0){this._textures.updateTexture(e),this._textures.updateTexture(t),this.backend.copyTextureToTexture(e,t,i,r,s)}readRenderTargetPixelsAsync(e,t,i,r,s,n=0,o=0){return this.backend.copyTextureToBuffer(e.textures[n],t,i,r,s,o)}_projectObject(e,t,i,r){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)i=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)r.pushLight(e);else if(e.isSprite){if(!e.frustumCulled||_frustum.intersectsSprite(e)){!0===this.sortObjects&&_vector4.setFromMatrixPosition(e.matrixWorld).applyMatrix4(_projScreenMatrix);const{geometry:t,material:s}=e;s.visible&&r.push(e,t,s,i,_vector4.z,null)}}else if(e.isLineLoop)console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");else if((e.isMesh||e.isLine||e.isPoints)&&(!e.frustumCulled||_frustum.intersectsObject(e))){const{geometry:t,material:s}=e;if(!0===this.sortObjects&&(null===t.boundingSphere&&t.computeBoundingSphere(),_vector4.copy(t.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(_projScreenMatrix)),Array.isArray(s)){const n=t.groups;for(let o=0,a=n.length;o<a;o++){const a=n[o],h=s[a.materialIndex];h&&h.visible&&r.push(e,t,h,i,_vector4.z,a)}}else s.visible&&r.push(e,t,s,i,_vector4.z,null)}if(!0===e.isBundleGroup&&void 0!==this.backend.beginBundle){const i=r;(r=this._renderLists.get(e,t)).begin(),i.pushBundle({bundleGroup:e,camera:t,renderList:r}),r.finish()}const s=e.children;for(let e=0,n=s.length;e<n;e++)this._projectObject(s[e],t,i,r)}_renderBundles(e,t,i){for(const r of e)this._renderBundle(r,t,i)}_renderTransparents(e,t,i,r,s){if(t.length>0){for(const{material:e}of t)e.side=BackSide;this._renderObjects(t,i,r,s,"backSide");for(const{material:e}of t)e.side=FrontSide;this._renderObjects(e,i,r,s);for(const{material:e}of t)e.side=DoubleSide}else this._renderObjects(e,i,r,s)}_renderObjects(e,t,i,r,s=null){for(let n=0,o=e.length;n<o;n++){const o=e[n],{object:a,geometry:h,material:d,group:l}=o;if(t.isArrayCamera){const e=t.cameras;for(let t=0,n=e.length;t<n;t++){const n=e[t];if(a.layers.test(n.layers)){const e=n.viewport,t=void 0===e.minDepth?0:e.minDepth,o=void 0===e.maxDepth?1:e.maxDepth,c=this._currentRenderContext.viewportValue;c.copy(e).multiplyScalar(this._pixelRatio).floor(),c.minDepth=t,c.maxDepth=o,this.backend.updateViewport(this._currentRenderContext),this._currentRenderObjectFunction(a,i,n,h,d,l,r,s)}}}else this._currentRenderObjectFunction(a,i,t,h,d,l,r,s)}}renderObject(e,t,i,r,s,n,o,a=null){let h,d,l;if(e.onBeforeRender(this,t,i,r,s,n),null!==t.overrideMaterial){const e=t.overrideMaterial;s.positionNode&&s.positionNode.isNode&&(h=e.positionNode,e.positionNode=s.positionNode),e.isShadowNodeMaterial&&(e.side=null===s.shadowSide?s.side:s.shadowSide,s.depthNode&&s.depthNode.isNode&&(l=e.depthNode,e.depthNode=s.depthNode),s.shadowNode&&s.shadowNode.isNode&&(d=e.fragmentNode,e.fragmentNode=s.shadowNode),this.localClippingEnabled&&(s.clipShadows?(e.clippingPlanes!==s.clippingPlanes&&(e.clippingPlanes=s.clippingPlanes,e.needsUpdate=!0),e.clipIntersection!==s.clipIntersection&&(e.clipIntersection=s.clipIntersection)):Array.isArray(e.clippingPlanes)&&(e.clippingPlanes=null,e.needsUpdate=!0))),s=e}!0===s.transparent&&s.side===DoubleSide&&!1===s.forceSinglePass?(s.side=BackSide,this._handleObjectFunction(e,s,t,i,o,n,"backSide"),s.side=FrontSide,this._handleObjectFunction(e,s,t,i,o,n,a),s.side=DoubleSide):this._handleObjectFunction(e,s,t,i,o,n,a),void 0!==h&&(t.overrideMaterial.positionNode=h),void 0!==l&&(t.overrideMaterial.depthNode=l),void 0!==d&&(t.overrideMaterial.fragmentNode=d),e.onAfterRender(this,t,i,r,s,n)}_renderObjectDirect(e,t,i,r,s,n,o){const a=this._objects.get(e,t,i,r,s,this._currentRenderContext,o);a.drawRange=e.geometry.drawRange,a.group=n;const h=this._nodes.needsRefresh(a);if(h&&(this._nodes.updateBefore(a),this._geometries.updateForRender(a),this._nodes.updateForRender(a),this._bindings.updateForRender(a)),this._pipelines.updateForRender(a),null!==this._currentRenderBundle){this.backend.get(this._currentRenderBundle).renderObjects.push(a),a.bundle=this._currentRenderBundle.scene}this.backend.draw(a,this.info),h&&this._nodes.updateAfter(a)}_createObjectPipeline(e,t,i,r,s,n){const o=this._objects.get(e,t,i,r,s,this._currentRenderContext,n);this._nodes.updateBefore(o),this._geometries.updateForRender(o),this._nodes.updateForRender(o),this._bindings.updateForRender(o),this._pipelines.getForRender(o,this._compilationPromises),this._nodes.updateAfter(o)}get compile(){return this.compileAsync}}export default Renderer;
//# sourceMappingURL=/sm/daf14cd959776f9642e8a165cfd859f4b8e071128bafa0735d1ac8707a57bd06.map