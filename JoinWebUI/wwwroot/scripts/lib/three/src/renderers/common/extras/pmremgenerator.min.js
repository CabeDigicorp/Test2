/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/renderers/common/extras/PMREMGenerator.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import NodeMaterial from"../../../materials/nodes/NodeMaterial.js";import{getDirection,blur}from"../../../nodes/pmrem/PMREMUtils.js";import{equirectUV}from"../../../nodes/utils/EquirectUVNode.js";import{uniform}from"../../../nodes/core/UniformNode.js";import{uniformArray}from"../../../nodes/accessors/UniformArrayNode.js";import{texture}from"../../../nodes/accessors/TextureNode.js";import{cubeTexture}from"../../../nodes/accessors/CubeTextureNode.js";import{float,vec3}from"../../../nodes/tsl/TSLBase.js";import{uv}from"../../../nodes/accessors/UV.js";import{attribute}from"../../../nodes/core/AttributeNode.js";import{OrthographicCamera}from"../../../cameras/OrthographicCamera.js";import{Color}from"../../../math/Color.js";import{Vector3}from"../../../math/Vector3.js";import{BufferGeometry}from"../../../core/BufferGeometry.js";import{BufferAttribute}from"../../../core/BufferAttribute.js";import{RenderTarget}from"../../../core/RenderTarget.js";import{Mesh}from"../../../objects/Mesh.js";import{PerspectiveCamera}from"../../../cameras/PerspectiveCamera.js";import{MeshBasicMaterial}from"../../../materials/MeshBasicMaterial.js";import{BoxGeometry}from"../../../geometries/BoxGeometry.js";import{CubeReflectionMapping,CubeRefractionMapping,CubeUVReflectionMapping,LinearFilter,NoBlending,RGBAFormat,HalfFloatType,BackSide,LinearSRGBColorSpace}from"../../../constants.js";const LOD_MIN=4,EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],MAX_SAMPLES=20,_flatCamera=new OrthographicCamera(-1,1,1,-1,0,1),_cubeCamera=new PerspectiveCamera(90,1),_clearColor=new Color;let _oldTarget=null,_oldActiveCubeFace=0,_oldActiveMipmapLevel=0;const PHI=(1+Math.sqrt(5))/2,INV_PHI=1/PHI,_axisDirections=[new Vector3(-PHI,INV_PHI,0),new Vector3(PHI,INV_PHI,0),new Vector3(-INV_PHI,0,PHI),new Vector3(INV_PHI,0,PHI),new Vector3(0,PHI,-INV_PHI),new Vector3(0,PHI,INV_PHI),new Vector3(-1,1,-1),new Vector3(1,1,-1),new Vector3(-1,1,1),new Vector3(1,1,1)],_faceLib=[3,1,5,0,4,2],direction=getDirection(uv(),attribute("faceIndex")).normalize(),outputDirection=vec3(direction.x,direction.y.negate(),direction.z);class PMREMGenerator{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._backgroundBox=null}fromScene(e,t=0,r=.1,i=100){_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel(),this._setSize(256);const a=this._allocateTargets();return a.depthBuffer=!0,this._sceneToCubeUV(e,r,i,a),t>0&&this._blur(a,0,0,t),this._applyPMREM(a),this._cleanup(a),a}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}async compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=_getCubemapMaterial(),await this._compileMaterial(this._cubemapMaterial))}async compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=_getEquirectMaterial(),await this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose(),null!==this._backgroundBox&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(_oldTarget,_oldActiveCubeFace,_oldActiveMipmapLevel),e.scissorTest=!1,_setViewport(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===CubeReflectionMapping||e.mapping===CubeRefractionMapping?this._setSize(0===e.image.length?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel();const r=t||this._allocateTargets();return this._textureToCubeUV(e,r),this._applyPMREM(r),this._cleanup(r),r}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,r={magFilter:LinearFilter,minFilter:LinearFilter,generateMipmaps:!1,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace},i=_createRenderTarget(e,t,r);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=_createRenderTarget(e,t,r);const{_lodMax:i}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas,lodMeshes:this._lodMeshes}=_createPlanes(i)),this._blurMaterial=_getBlurShader(i,e,t)}return i}async _compileMaterial(e){const t=new Mesh(this._lodPlanes[0],e);await this._renderer.compile(t,_flatCamera)}_sceneToCubeUV(e,t,r,i){const a=_cubeCamera;a.near=t,a.far=r;const o=[-1,1,-1,-1,-1,-1],s=[1,1,1,-1,-1,-1],n=this._renderer,l=n.autoClear;n.getClearColor(_clearColor),n.autoClear=!1;let u=this._backgroundBox;if(null===u){const e=new MeshBasicMaterial({name:"PMREM.Background",side:BackSide,depthWrite:!1,depthTest:!1});u=new Mesh(new BoxGeometry,e)}let c=!1;const _=e.background;_?_.isColor&&(u.material.color.copy(_),e.background=null,c=!0):(u.material.color.copy(_clearColor),c=!0),n.setRenderTarget(i),n.clear(),c&&n.render(u,a);for(let t=0;t<6;t++){const r=t%3;0===r?(a.up.set(0,o[t],0),a.lookAt(s[t],0,0)):1===r?(a.up.set(0,0,o[t]),a.lookAt(0,s[t],0)):(a.up.set(0,o[t],0),a.lookAt(0,0,s[t]));const l=this._cubeSize;_setViewport(i,r*l,t>2?l:0,l,l),n.render(e,a)}n.autoClear=l,e.background=_}_textureToCubeUV(e,t){const r=this._renderer,i=e.mapping===CubeReflectionMapping||e.mapping===CubeRefractionMapping;i?null===this._cubemapMaterial&&(this._cubemapMaterial=_getCubemapMaterial(e)):null===this._equirectMaterial&&(this._equirectMaterial=_getEquirectMaterial(e));const a=i?this._cubemapMaterial:this._equirectMaterial;a.fragmentNode.value=e;const o=this._lodMeshes[0];o.material=a;const s=this._cubeSize;_setViewport(t,0,0,3*s,2*s),r.setRenderTarget(t),r.render(o,_flatCamera)}_applyPMREM(e){const t=this._renderer,r=t.autoClear;t.autoClear=!1;const i=this._lodPlanes.length;for(let t=1;t<i;t++){const r=Math.sqrt(this._sigmas[t]*this._sigmas[t]-this._sigmas[t-1]*this._sigmas[t-1]),a=_axisDirections[(i-t-1)%_axisDirections.length];this._blur(e,t-1,t,r,a)}t.autoClear=r}_blur(e,t,r,i,a){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,r,i,"latitudinal",a),this._halfBlur(o,e,r,r,i,"longitudinal",a)}_halfBlur(e,t,r,i,a,o,s){const n=this._renderer,l=this._blurMaterial;"latitudinal"!==o&&"longitudinal"!==o&&console.error("blur direction must be either latitudinal or longitudinal!");const u=this._lodMeshes[i];u.material=l;const c=l.uniforms,_=this._sizeLods[r]-1,h=isFinite(a)?Math.PI/(2*_):2*Math.PI/39,m=a/h,p=isFinite(a)?1+Math.floor(3*m):20;p>20&&console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${p} samples when the maximum is set to 20`);const d=[];let g=0;for(let e=0;e<20;++e){const t=e/m,r=Math.exp(-t*t/2);d.push(r),0===e?g+=r:e<p&&(g+=2*r)}for(let e=0;e<d.length;e++)d[e]=d[e]/g;e.texture.frame=(e.texture.frame||0)+1,c.envMap.value=e.texture,c.samples.value=p,c.weights.array=d,c.latitudinal.value="latitudinal"===o?1:0,s&&(c.poleAxis.value=s);const{_lodMax:M}=this;c.dTheta.value=h,c.mipInt.value=M-r;const f=this._sizeLods[i];_setViewport(t,3*f*(i>M-4?i-M+4:0),4*(this._cubeSize-f),3*f,2*f),n.setRenderTarget(t),n.render(u,_flatCamera)}}function _createPlanes(e){const t=[],r=[],i=[],a=[];let o=e;const s=e-4+1+EXTRA_LOD_SIGMA.length;for(let n=0;n<s;n++){const s=Math.pow(2,o);r.push(s);let l=1/s;n>e-4?l=EXTRA_LOD_SIGMA[n-e+4-1]:0===n&&(l=0),i.push(l);const u=1/(s-2),c=-u,_=1+u,h=[c,c,_,c,_,_,c,c,_,_,c,_],m=6,p=6,d=3,g=2,M=1,f=new Float32Array(d*p*m),b=new Float32Array(g*p*m),C=new Float32Array(M*p*m);for(let e=0;e<m;e++){const t=e%3*2/3-1,r=e>2?0:-1,i=[t,r,0,t+2/3,r,0,t+2/3,r+1,0,t,r,0,t+2/3,r+1,0,t,r+1,0],a=_faceLib[e];f.set(i,d*p*a),b.set(h,g*p*a);const o=[a,a,a,a,a,a];C.set(o,M*p*a)}const T=new BufferGeometry;T.setAttribute("position",new BufferAttribute(f,d)),T.setAttribute("uv",new BufferAttribute(b,g)),T.setAttribute("faceIndex",new BufferAttribute(C,M)),t.push(T),a.push(new Mesh(T,null)),o>4&&o--}return{lodPlanes:t,sizeLods:r,sigmas:i,lodMeshes:a}}function _createRenderTarget(e,t,r){const i=new RenderTarget(e,t,r);return i.texture.mapping=CubeUVReflectionMapping,i.texture.name="PMREM.cubeUv",i.texture.isPMREMTexture=!0,i.scissorTest=!0,i}function _setViewport(e,t,r,i,a){e.viewport.set(t,r,i,a),e.scissor.set(t,r,i,a)}function _getMaterial(e){const t=new NodeMaterial;return t.depthTest=!1,t.depthWrite=!1,t.blending=NoBlending,t.name=`PMREM_${e}`,t}function _getBlurShader(e,t,r){const i=uniformArray(new Array(20).fill(0)),a=uniform(new Vector3(0,1,0)),o=uniform(0),s=float(20),n=uniform(0),l=uniform(1),u=texture(null),c=uniform(0),_=float(1/t),h=float(1/r),m=float(e),p={n:s,latitudinal:n,weights:i,poleAxis:a,outputDirection:outputDirection,dTheta:o,samples:l,envMap:u,mipInt:c,CUBEUV_TEXEL_WIDTH:_,CUBEUV_TEXEL_HEIGHT:h,CUBEUV_MAX_MIP:m},d=_getMaterial("blur");return d.uniforms=p,d.fragmentNode=blur({...p,latitudinal:n.equal(1)}),d}function _getCubemapMaterial(e){const t=_getMaterial("cubemap");return t.fragmentNode=cubeTexture(e,outputDirection),t}function _getEquirectMaterial(e){const t=_getMaterial("equirect");return t.fragmentNode=texture(e,equirectUV(outputDirection),0),t}export default PMREMGenerator;
//# sourceMappingURL=/sm/dfb4f84bc3e4dd4c132876eea516e2e6ebf710256338ced611cca35e8ee1cd2d.map