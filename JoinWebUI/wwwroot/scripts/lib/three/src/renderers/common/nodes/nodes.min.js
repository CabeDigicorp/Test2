/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/renderers/common/nodes/Nodes.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import DataMap from"../DataMap.js";import ChainMap from"../ChainMap.js";import NodeBuilderState from"./NodeBuilderState.js";import{cubeMapNode}from"../../../nodes/utils/CubeMapNode.js";import{NodeFrame}from"../../../nodes/Nodes.js";import{objectGroup,renderGroup,frameGroup,cubeTexture,texture,rangeFog,densityFog,reference,pmremTexture,screenUV}from"../../../nodes/TSL.js";import{CubeUVReflectionMapping,EquirectangularReflectionMapping,EquirectangularRefractionMapping}from"../../../constants.js";import{hashArray}from"../../../nodes/core/NodeUtils.js";const outputNodeMap=new WeakMap;class Nodes extends DataMap{constructor(e,t){super(),this.renderer=e,this.backend=t,this.nodeFrame=new NodeFrame,this.nodeBuilderCache=new Map,this.callHashCache=new ChainMap,this.groupsData=new ChainMap}updateGroup(e){const t=e.groupNode,r=t.name;if(r===objectGroup.name)return!0;if(r===renderGroup.name){const t=this.get(e),r=this.nodeFrame.renderId;return t.renderId!==r&&(t.renderId=r,!0)}if(r===frameGroup.name){const t=this.get(e),r=this.nodeFrame.frameId;return t.frameId!==r&&(t.frameId=r,!0)}const o=[t,e];let n=this.groupsData.get(o);return void 0===n&&this.groupsData.set(o,n={}),n.version!==t.version&&(n.version=t.version,!0)}getForRenderCacheKey(e){return e.initialCacheKey}getForRender(e){const t=this.get(e);let r=t.nodeBuilderState;if(void 0===r){const{nodeBuilderCache:o}=this,n=this.getForRenderCacheKey(e);if(r=o.get(n),void 0===r){const t=this.backend.createNodeBuilder(e.object,this.renderer);t.scene=e.scene,t.material=e.material,t.camera=e.camera,t.context.material=e.material,t.lightsNode=e.lightsNode,t.environmentNode=this.getEnvironmentNode(e.scene),t.fogNode=this.getFogNode(e.scene),t.clippingContext=e.clippingContext,t.build(),r=this._createNodeBuilderState(t),o.set(n,r)}r.usedTimes++,t.nodeBuilderState=r}return r}delete(e){if(e.isRenderObject){const t=this.get(e).nodeBuilderState;t.usedTimes--,0===t.usedTimes&&this.nodeBuilderCache.delete(this.getForRenderCacheKey(e))}return super.delete(e)}getForCompute(e){const t=this.get(e);let r=t.nodeBuilderState;if(void 0===r){const o=this.backend.createNodeBuilder(e,this.renderer);o.build(),r=this._createNodeBuilderState(o),t.nodeBuilderState=r}return r}_createNodeBuilderState(e){return new NodeBuilderState(e.vertexShader,e.fragmentShader,e.computeShader,e.getAttributesArray(),e.getBindings(),e.updateNodes,e.updateBeforeNodes,e.updateAfterNodes,e.monitor,e.transforms)}getEnvironmentNode(e){return e.environmentNode||this.get(e).environmentNode||null}getBackgroundNode(e){return e.backgroundNode||this.get(e).backgroundNode||null}getFogNode(e){return e.fogNode||this.get(e).fogNode||null}getCacheKey(e,t){const r=[e,t],o=this.renderer.info.calls;let n=this.callHashCache.get(r);if(void 0===n||n.callId!==o){const d=this.getEnvironmentNode(e),a=this.getFogNode(e),s=[];t&&s.push(t.getCacheKey(!0)),d&&s.push(d.getCacheKey()),a&&s.push(a.getCacheKey()),s.push(this.renderer.shadowMap.enabled?1:0),n={callId:o,cacheKey:hashArray(s)},this.callHashCache.set(r,n)}return n.cacheKey}updateScene(e){this.updateEnvironment(e),this.updateFog(e),this.updateBackground(e)}get isToneMappingState(){return!this.renderer.getRenderTarget()}updateBackground(e){const t=this.get(e),r=e.background;if(r){const o=0===e.backgroundBlurriness&&t.backgroundBlurriness>0||e.backgroundBlurriness>0&&0===t.backgroundBlurriness;if(t.background!==r||o){let o=null;if(!0===r.isCubeTexture||r.mapping===EquirectangularReflectionMapping||r.mapping===EquirectangularRefractionMapping||r.mapping===CubeUVReflectionMapping)if(e.backgroundBlurriness>0||r.mapping===CubeUVReflectionMapping)o=pmremTexture(r);else{let e;e=!0===r.isCubeTexture?cubeTexture(r):texture(r),o=cubeMapNode(e)}else!0===r.isTexture?o=texture(r,screenUV.flipY()).setUpdateMatrix(!0):!0!==r.isColor&&console.error("WebGPUNodes: Unsupported background configuration.",r);t.backgroundNode=o,t.background=r,t.backgroundBlurriness=e.backgroundBlurriness}}else t.backgroundNode&&(delete t.backgroundNode,delete t.background)}updateFog(e){const t=this.get(e),r=e.fog;if(r){if(t.fog!==r){let e=null;if(r.isFogExp2){const t=reference("color","color",r).setGroup(renderGroup),o=reference("density","float",r).setGroup(renderGroup);e=densityFog(t,o)}else if(r.isFog){const t=reference("color","color",r).setGroup(renderGroup),o=reference("near","float",r).setGroup(renderGroup),n=reference("far","float",r).setGroup(renderGroup);e=rangeFog(t,o,n)}else console.error("WebGPUNodes: Unsupported fog configuration.",r);t.fogNode=e,t.fog=r}}else delete t.fogNode,delete t.fog}updateEnvironment(e){const t=this.get(e),r=e.environment;if(r){if(t.environment!==r){let e=null;!0===r.isCubeTexture?e=cubeTexture(r):!0===r.isTexture?e=texture(r):console.error("Nodes: Unsupported environment configuration.",r),t.environmentNode=e,t.environment=r}}else t.environmentNode&&(delete t.environmentNode,delete t.environment)}getNodeFrame(e=this.renderer,t=null,r=null,o=null,n=null){const d=this.nodeFrame;return d.renderer=e,d.scene=t,d.object=r,d.camera=o,d.material=n,d}getNodeFrameForRender(e){return this.getNodeFrame(e.renderer,e.scene,e.object,e.camera,e.material)}getOutputCacheKey(){const e=this.renderer;return e.toneMapping+","+e.currentColorSpace}hasOutputChange(e){return outputNodeMap.get(e)!==this.getOutputCacheKey()}getOutputNode(e){const t=this.renderer,r=this.getOutputCacheKey(),o=texture(e,screenUV).renderOutput(t.toneMapping,t.currentColorSpace);return outputNodeMap.set(e,r),o}updateBefore(e){const t=e.getNodeBuilderState();for(const r of t.updateBeforeNodes)this.getNodeFrameForRender(e).updateBeforeNode(r)}updateAfter(e){const t=e.getNodeBuilderState();for(const r of t.updateAfterNodes)this.getNodeFrameForRender(e).updateAfterNode(r)}updateForCompute(e){const t=this.getNodeFrame(),r=this.getForCompute(e);for(const e of r.updateNodes)t.updateNode(e)}updateForRender(e){const t=this.getNodeFrameForRender(e),r=e.getNodeBuilderState();for(const e of r.updateNodes)t.updateNode(e)}needsRefresh(e){const t=this.getNodeFrameForRender(e);return e.getMonitor().needsRefresh(e,t)}dispose(){super.dispose(),this.nodeFrame=new NodeFrame,this.nodeBuilderCache=new Map}}export default Nodes;
//# sourceMappingURL=/sm/c123d206d89dcb110a34898300e0264e441a9bd9852c69647915f54e74a260fe.map