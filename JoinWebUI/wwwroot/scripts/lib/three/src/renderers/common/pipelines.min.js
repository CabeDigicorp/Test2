/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/renderers/common/Pipelines.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import DataMap from"./DataMap.js";import RenderPipeline from"./RenderPipeline.js";import ComputePipeline from"./ComputePipeline.js";import ProgrammableStage from"./ProgrammableStage.js";class Pipelines extends DataMap{constructor(e,t){super(),this.backend=e,this.nodes=t,this.bindings=null,this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}getForCompute(e,t){const{backend:r}=this,s=this.get(e);if(this._needsComputeUpdate(e)){const i=s.pipeline;i&&(i.usedTimes--,i.computeProgram.usedTimes--);const a=this.nodes.getForCompute(e);let m=this.programs.compute.get(a.computeShader);void 0===m&&(i&&0===i.computeProgram.usedTimes&&this._releaseProgram(i.computeProgram),m=new ProgrammableStage(a.computeShader,"compute",a.transforms,a.nodeAttributes),this.programs.compute.set(a.computeShader,m),r.createProgram(m));const n=this._getComputeCacheKey(e,m);let o=this.caches.get(n);void 0===o&&(i&&0===i.usedTimes&&this._releasePipeline(i),o=this._getComputePipeline(e,m,n,t)),o.usedTimes++,m.usedTimes++,s.version=e.version,s.pipeline=o}return s.pipeline}getForRender(e,t=null){const{backend:r}=this,s=this.get(e);if(this._needsRenderUpdate(e)){const i=s.pipeline;i&&(i.usedTimes--,i.vertexProgram.usedTimes--,i.fragmentProgram.usedTimes--);const a=e.getNodeBuilderState();let m=this.programs.vertex.get(a.vertexShader);void 0===m&&(i&&0===i.vertexProgram.usedTimes&&this._releaseProgram(i.vertexProgram),m=new ProgrammableStage(a.vertexShader,"vertex"),this.programs.vertex.set(a.vertexShader,m),r.createProgram(m));let n=this.programs.fragment.get(a.fragmentShader);void 0===n&&(i&&0===i.fragmentProgram.usedTimes&&this._releaseProgram(i.fragmentProgram),n=new ProgrammableStage(a.fragmentShader,"fragment"),this.programs.fragment.set(a.fragmentShader,n),r.createProgram(n));const o=this._getRenderCacheKey(e,m,n);let p=this.caches.get(o);void 0===p?(i&&0===i.usedTimes&&this._releasePipeline(i),p=this._getRenderPipeline(e,m,n,o,t)):e.pipeline=p,p.usedTimes++,m.usedTimes++,n.usedTimes++,s.pipeline=p}return s.pipeline}delete(e){const t=this.get(e).pipeline;return t&&(t.usedTimes--,0===t.usedTimes&&this._releasePipeline(t),t.isComputePipeline?(t.computeProgram.usedTimes--,0===t.computeProgram.usedTimes&&this._releaseProgram(t.computeProgram)):(t.fragmentProgram.usedTimes--,t.vertexProgram.usedTimes--,0===t.vertexProgram.usedTimes&&this._releaseProgram(t.vertexProgram),0===t.fragmentProgram.usedTimes&&this._releaseProgram(t.fragmentProgram))),super.delete(e)}dispose(){super.dispose(),this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}updateForRender(e){this.getForRender(e)}_getComputePipeline(e,t,r,s){r=r||this._getComputeCacheKey(e,t);let i=this.caches.get(r);return void 0===i&&(i=new ComputePipeline(r,t),this.caches.set(r,i),this.backend.createComputePipeline(i,s)),i}_getRenderPipeline(e,t,r,s,i){s=s||this._getRenderCacheKey(e,t,r);let a=this.caches.get(s);return void 0===a&&(a=new RenderPipeline(s,t,r),this.caches.set(s,a),e.pipeline=a,this.backend.createRenderPipeline(e,i)),a}_getComputeCacheKey(e,t){return e.id+","+t.id}_getRenderCacheKey(e,t,r){return t.id+","+r.id+","+this.backend.getRenderCacheKey(e)}_releasePipeline(e){this.caches.delete(e.cacheKey)}_releaseProgram(e){const t=e.code,r=e.stage;this.programs[r].delete(t)}_needsComputeUpdate(e){const t=this.get(e);return void 0===t.pipeline||t.version!==e.version}_needsRenderUpdate(e){return void 0===this.get(e).pipeline||this.backend.needsRenderUpdate(e)}}export default Pipelines;
//# sourceMappingURL=/sm/16d01443f891c05d8abc1568f75b9a0a9163c9fea3e3c6e02f3474f33e613dff.map