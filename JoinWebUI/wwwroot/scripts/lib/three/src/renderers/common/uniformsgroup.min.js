/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/renderers/common/UniformsGroup.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import UniformBuffer from"./UniformBuffer.js";import{GPU_CHUNK_BYTES}from"./Constants.js";class UniformsGroup extends UniformBuffer{constructor(t){super(t),this.isUniformsGroup=!0,this._values=null,this.uniforms=[]}addUniform(t){return this.uniforms.push(t),this}removeUniform(t){const e=this.uniforms.indexOf(t);return-1!==e&&this.uniforms.splice(e,1),this}get values(){return null===this._values&&(this._values=Array.from(this.buffer)),this._values}get buffer(){let t=this._buffer;if(null===t){const e=this.byteLength;t=new Float32Array(new ArrayBuffer(e)),this._buffer=t}return t}get byteLength(){let t=0;for(let e=0,r=this.uniforms.length;e<r;e++){const r=this.uniforms[e],{boundary:s,itemSize:i}=r,u=t%GPU_CHUNK_BYTES;0!==u&&GPU_CHUNK_BYTES-u-s<0?t+=GPU_CHUNK_BYTES-u:u%s!=0&&(t+=u%s),r.offset=t/this.bytesPerElement,t+=i*this.bytesPerElement}return Math.ceil(t/GPU_CHUNK_BYTES)*GPU_CHUNK_BYTES}update(){let t=!1;for(const e of this.uniforms)!0===this.updateByType(e)&&(t=!0);return t}updateByType(t){return t.isNumberUniform?this.updateNumber(t):t.isVector2Uniform?this.updateVector2(t):t.isVector3Uniform?this.updateVector3(t):t.isVector4Uniform?this.updateVector4(t):t.isColorUniform?this.updateColor(t):t.isMatrix3Uniform?this.updateMatrix3(t):t.isMatrix4Uniform?this.updateMatrix4(t):void console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.",t)}updateNumber(t){let e=!1;const r=this.values,s=t.getValue(),i=t.offset;if(r[i]!==s){this.buffer[i]=r[i]=s,e=!0}return e}updateVector2(t){let e=!1;const r=this.values,s=t.getValue(),i=t.offset;if(r[i+0]!==s.x||r[i+1]!==s.y){const t=this.buffer;t[i+0]=r[i+0]=s.x,t[i+1]=r[i+1]=s.y,e=!0}return e}updateVector3(t){let e=!1;const r=this.values,s=t.getValue(),i=t.offset;if(r[i+0]!==s.x||r[i+1]!==s.y||r[i+2]!==s.z){const t=this.buffer;t[i+0]=r[i+0]=s.x,t[i+1]=r[i+1]=s.y,t[i+2]=r[i+2]=s.z,e=!0}return e}updateVector4(t){let e=!1;const r=this.values,s=t.getValue(),i=t.offset;if(r[i+0]!==s.x||r[i+1]!==s.y||r[i+2]!==s.z||r[i+4]!==s.w){const t=this.buffer;t[i+0]=r[i+0]=s.x,t[i+1]=r[i+1]=s.y,t[i+2]=r[i+2]=s.z,t[i+3]=r[i+3]=s.w,e=!0}return e}updateColor(t){let e=!1;const r=this.values,s=t.getValue(),i=t.offset;if(r[i+0]!==s.r||r[i+1]!==s.g||r[i+2]!==s.b){const t=this.buffer;t[i+0]=r[i+0]=s.r,t[i+1]=r[i+1]=s.g,t[i+2]=r[i+2]=s.b,e=!0}return e}updateMatrix3(t){let e=!1;const r=this.values,s=t.getValue().elements,i=t.offset;if(r[i+0]!==s[0]||r[i+1]!==s[1]||r[i+2]!==s[2]||r[i+4]!==s[3]||r[i+5]!==s[4]||r[i+6]!==s[5]||r[i+8]!==s[6]||r[i+9]!==s[7]||r[i+10]!==s[8]){const t=this.buffer;t[i+0]=r[i+0]=s[0],t[i+1]=r[i+1]=s[1],t[i+2]=r[i+2]=s[2],t[i+4]=r[i+4]=s[3],t[i+5]=r[i+5]=s[4],t[i+6]=r[i+6]=s[5],t[i+8]=r[i+8]=s[6],t[i+9]=r[i+9]=s[7],t[i+10]=r[i+10]=s[8],e=!0}return e}updateMatrix4(t){let e=!1;const r=this.values,s=t.getValue().elements,i=t.offset;if(!1===arraysEqual(r,s,i)){this.buffer.set(s,i),setArray(r,s,i),e=!0}return e}}function setArray(t,e,r){for(let s=0,i=e.length;s<i;s++)t[r+s]=e[s]}function arraysEqual(t,e,r){for(let s=0,i=e.length;s<i;s++)if(t[r+s]!==e[s])return!1;return!0}export default UniformsGroup;
//# sourceMappingURL=/sm/92f1443842c847e9ddda475aa34635e7bc30575b93d364db0e879649e6fec42a.map