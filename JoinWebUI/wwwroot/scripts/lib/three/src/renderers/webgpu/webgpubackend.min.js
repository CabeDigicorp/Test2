/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/renderers/webgpu/WebGPUBackend.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{GPUFeatureName,GPULoadOp,GPUStoreOp,GPUIndexFormat,GPUTextureViewDimension}from"./utils/WebGPUConstants.js";import WGSLNodeBuilder from"./nodes/WGSLNodeBuilder.js";import Backend from"../common/Backend.js";import WebGPUUtils from"./utils/WebGPUUtils.js";import WebGPUAttributeUtils from"./utils/WebGPUAttributeUtils.js";import WebGPUBindingUtils from"./utils/WebGPUBindingUtils.js";import WebGPUPipelineUtils from"./utils/WebGPUPipelineUtils.js";import WebGPUTextureUtils from"./utils/WebGPUTextureUtils.js";import{WebGPUCoordinateSystem}from"../../constants.js";class WebGPUBackend extends Backend{constructor(e={}){super(e),this.isWebGPUBackend=!0,this.parameters.alpha=void 0===e.alpha||e.alpha,this.parameters.requiredLimits=void 0===e.requiredLimits?{}:e.requiredLimits,this.trackTimestamp=!0===e.trackTimestamp,this.device=null,this.context=null,this.colorBuffer=null,this.defaultRenderPassdescriptor=null,this.utils=new WebGPUUtils(this),this.attributeUtils=new WebGPUAttributeUtils(this),this.bindingUtils=new WebGPUBindingUtils(this),this.pipelineUtils=new WebGPUPipelineUtils(this),this.textureUtils=new WebGPUTextureUtils(this),this.occludedResolveCache=new Map}async init(e){await super.init(e);const t=this.parameters;let r;if(void 0===t.device){const e={powerPreference:t.powerPreference},i=await navigator.gpu.requestAdapter(e);if(null===i)throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");const s=Object.values(GPUFeatureName),n=[];for(const e of s)i.features.has(e)&&n.push(e);const a={requiredFeatures:n,requiredLimits:t.requiredLimits};r=await i.requestDevice(a)}else r=t.device;r.lost.then((t=>{const r={api:"WebGPU",message:t.message||"Unknown reason",reason:t.reason||null,originalEvent:t};e.onDeviceLost(r)}));const i=void 0!==t.context?t.context:e.domElement.getContext("webgpu");this.device=r,this.context=i;const s=t.alpha?"premultiplied":"opaque";this.trackTimestamp=this.trackTimestamp&&this.hasFeature(GPUFeatureName.TimestampQuery),this.context.configure({device:this.device,format:this.utils.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:s}),this.updateSize()}get coordinateSystem(){return WebGPUCoordinateSystem}async getArrayBufferAsync(e){return await this.attributeUtils.getArrayBufferAsync(e)}getContext(){return this.context}_getDefaultRenderPassDescriptor(){let e=this.defaultRenderPassdescriptor;if(null===e){const t=this.renderer;e={colorAttachments:[{view:null}]},!0!==this.renderer.depth&&!0!==this.renderer.stencil||(e.depthStencilAttachment={view:this.textureUtils.getDepthBuffer(t.depth,t.stencil).createView()});const r=e.colorAttachments[0];this.renderer.samples>0?r.view=this.colorBuffer.createView():r.resolveTarget=void 0,this.defaultRenderPassdescriptor=e}const t=e.colorAttachments[0];return this.renderer.samples>0?t.resolveTarget=this.context.getCurrentTexture().createView():t.view=this.context.getCurrentTexture().createView(),e}_getRenderPassDescriptor(e){const t=e.renderTarget,r=this.get(t);let i=r.descriptors;if(void 0===i||r.width!==t.width||r.height!==t.height||r.activeMipmapLevel!==t.activeMipmapLevel||r.samples!==t.samples){i={},r.descriptors=i;const e=()=>{t.removeEventListener("dispose",e),this.delete(t)};t.addEventListener("dispose",e)}const s=e.getCacheKey();let n=i[s];if(void 0===n){const a=e.textures,o=[];for(let t=0;t<a.length;t++){const r=this.get(a[t]),i=r.texture.createView({baseMipLevel:e.activeMipmapLevel,mipLevelCount:1,baseArrayLayer:e.activeCubeFace,dimension:GPUTextureViewDimension.TwoD});let s,n;void 0!==r.msaaTexture?(s=r.msaaTexture.createView(),n=i):(s=i,n=void 0),o.push({view:s,resolveTarget:n,loadOp:GPULoadOp.Load,storeOp:GPUStoreOp.Store})}if(n={colorAttachments:o},e.depth){const t={view:this.get(e.depthTexture).texture.createView()};n.depthStencilAttachment=t}i[s]=n,r.width=t.width,r.height=t.height,r.samples=t.samples,r.activeMipmapLevel=t.activeMipmapLevel}return n}beginRender(e){const t=this.get(e),r=this.device,i=e.occlusionQueryCount;let s,n;i>0&&(t.currentOcclusionQuerySet&&t.currentOcclusionQuerySet.destroy(),t.currentOcclusionQueryBuffer&&t.currentOcclusionQueryBuffer.destroy(),t.currentOcclusionQuerySet=t.occlusionQuerySet,t.currentOcclusionQueryBuffer=t.occlusionQueryBuffer,t.currentOcclusionQueryObjects=t.occlusionQueryObjects,s=r.createQuerySet({type:"occlusion",count:i}),t.occlusionQuerySet=s,t.occlusionQueryIndex=0,t.occlusionQueryObjects=new Array(i),t.lastOcclusionObject=null),n=null===e.textures?this._getDefaultRenderPassDescriptor():this._getRenderPassDescriptor(e),this.initTimestampQuery(e,n),n.occlusionQuerySet=s;const a=n.depthStencilAttachment;if(null!==e.textures){const t=n.colorAttachments;for(let r=0;r<t.length;r++){const i=t[r];e.clearColor?(i.clearValue=0===r?e.clearColorValue:{r:0,g:0,b:0,a:1},i.loadOp=GPULoadOp.Clear,i.storeOp=GPUStoreOp.Store):(i.loadOp=GPULoadOp.Load,i.storeOp=GPUStoreOp.Store)}}else{const t=n.colorAttachments[0];e.clearColor?(t.clearValue=e.clearColorValue,t.loadOp=GPULoadOp.Clear,t.storeOp=GPUStoreOp.Store):(t.loadOp=GPULoadOp.Load,t.storeOp=GPUStoreOp.Store)}e.depth&&(e.clearDepth?(a.depthClearValue=e.clearDepthValue,a.depthLoadOp=GPULoadOp.Clear,a.depthStoreOp=GPUStoreOp.Store):(a.depthLoadOp=GPULoadOp.Load,a.depthStoreOp=GPUStoreOp.Store)),e.stencil&&(e.clearStencil?(a.stencilClearValue=e.clearStencilValue,a.stencilLoadOp=GPULoadOp.Clear,a.stencilStoreOp=GPUStoreOp.Store):(a.stencilLoadOp=GPULoadOp.Load,a.stencilStoreOp=GPUStoreOp.Store));const o=r.createCommandEncoder({label:"renderContext_"+e.id}),c=o.beginRenderPass(n);if(t.descriptor=n,t.encoder=o,t.currentPass=c,t.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},t.renderBundles=[],e.viewport&&this.updateViewport(e),e.scissor){const{x:t,y:r,width:i,height:s}=e.scissorValue;c.setScissorRect(t,r,i,s)}}finishRender(e){const t=this.get(e),r=e.occlusionQueryCount;if(t.renderBundles.length>0&&t.currentPass.executeBundles(t.renderBundles),r>t.occlusionQueryIndex&&t.currentPass.endOcclusionQuery(),t.currentPass.end(),r>0){const i=8*r;let s=this.occludedResolveCache.get(i);void 0===s&&(s=this.device.createBuffer({size:i,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.occludedResolveCache.set(i,s));const n=this.device.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});t.encoder.resolveQuerySet(t.occlusionQuerySet,0,r,s,0),t.encoder.copyBufferToBuffer(s,0,n,0,i),t.occlusionQueryBuffer=n,this.resolveOccludedAsync(e)}if(this.prepareTimestampBuffer(e,t.encoder),this.device.queue.submit([t.encoder.finish()]),null!==e.textures){const t=e.textures;for(let e=0;e<t.length;e++){const r=t[e];!0===r.generateMipmaps&&this.textureUtils.generateMipmaps(r)}}}isOccluded(e,t){const r=this.get(e);return r.occluded&&r.occluded.has(t)}async resolveOccludedAsync(e){const t=this.get(e),{currentOcclusionQueryBuffer:r,currentOcclusionQueryObjects:i}=t;if(r&&i){const e=new WeakSet;t.currentOcclusionQueryObjects=null,t.currentOcclusionQueryBuffer=null,await r.mapAsync(GPUMapMode.READ);const s=r.getMappedRange(),n=new BigUint64Array(s);for(let t=0;t<i.length;t++)n[t]!==BigInt(0)&&e.add(i[t]);r.destroy(),t.occluded=e}}updateViewport(e){const{currentPass:t}=this.get(e),{x:r,y:i,width:s,height:n,minDepth:a,maxDepth:o}=e.viewportValue;t.setViewport(r,i,s,n,a,o)}clear(e,t,r,i=null){const s=this.device,n=this.renderer;let a,o,c,l,u=[];if(e){const e=this.getClearColor();if(!0===this.renderer.alpha){const t=e.a;o={r:e.r*t,g:e.g*t,b:e.b*t,a:t}}else o={r:e.r,g:e.g,b:e.b,a:e.a}}if(null===i){c=n.depth,l=n.stencil;const t=this._getDefaultRenderPassDescriptor();if(e){u=t.colorAttachments;const e=u[0];e.clearValue=o,e.loadOp=GPULoadOp.Clear,e.storeOp=GPUStoreOp.Store}(c||l)&&(a=t.depthStencilAttachment)}else{if(c=i.depth,l=i.stencil,e)for(const e of i.textures){const t=this.get(e),r=t.texture.createView();let i,s;void 0!==t.msaaTexture?(i=t.msaaTexture.createView(),s=r):(i=r,s=void 0),u.push({view:i,resolveTarget:s,clearValue:o,loadOp:GPULoadOp.Clear,storeOp:GPUStoreOp.Store})}if(c||l){a={view:this.get(i.depthTexture).texture.createView()}}}c&&(t?(a.depthLoadOp=GPULoadOp.Clear,a.depthClearValue=n.getClearDepth(),a.depthStoreOp=GPUStoreOp.Store):(a.depthLoadOp=GPULoadOp.Load,a.depthStoreOp=GPUStoreOp.Store)),l&&(r?(a.stencilLoadOp=GPULoadOp.Clear,a.stencilClearValue=n.getClearStencil(),a.stencilStoreOp=GPUStoreOp.Store):(a.stencilLoadOp=GPULoadOp.Load,a.stencilStoreOp=GPUStoreOp.Store));const d=s.createCommandEncoder({});d.beginRenderPass({colorAttachments:u,depthStencilAttachment:a}).end(),s.queue.submit([d.finish()])}beginCompute(e){const t=this.get(e),r={};this.initTimestampQuery(e,r),t.cmdEncoderGPU=this.device.createCommandEncoder(),t.passEncoderGPU=t.cmdEncoderGPU.beginComputePass(r)}compute(e,t,r,i){const{passEncoderGPU:s}=this.get(e),n=this.get(i).pipeline;s.setPipeline(n);for(let e=0,t=r.length;e<t;e++){const t=r[e],i=this.get(t);s.setBindGroup(e,i.group)}const a=this.device.limits.maxComputeWorkgroupsPerDimension,o=this.get(t);void 0===o.dispatchSize&&(o.dispatchSize={x:0,y:1,z:1});const{dispatchSize:c}=o;t.dispatchCount>a?(c.x=Math.min(t.dispatchCount,a),c.y=Math.ceil(t.dispatchCount/a)):c.x=t.dispatchCount,s.dispatchWorkgroups(c.x,c.y,c.z)}finishCompute(e){const t=this.get(e);t.passEncoderGPU.end(),this.prepareTimestampBuffer(e,t.cmdEncoderGPU),this.device.queue.submit([t.cmdEncoderGPU.finish()])}async waitForGPU(){await this.device.queue.onSubmittedWorkDone()}draw(e,t){const{object:r,context:i,pipeline:s}=e,n=e.getBindings(),a=this.get(i),o=this.get(s).pipeline,c=a.currentSets,l=a.currentPass,u=e.getDrawParameters();if(null===u)return;c.pipeline!==o&&(l.setPipeline(o),c.pipeline=o);const d=c.bindingGroups;for(let e=0,t=n.length;e<t;e++){const t=n[e],r=this.get(t);d[t.index]!==t.id&&(l.setBindGroup(t.index,r.group),d[t.index]=t.id)}const p=e.getIndex(),h=null!==p;if(!0===h&&c.index!==p){const e=this.get(p).buffer,t=p.array instanceof Uint16Array?GPUIndexFormat.Uint16:GPUIndexFormat.Uint32;l.setIndexBuffer(e,t),c.index=p}const f=e.getVertexBuffers();for(let e=0,t=f.length;e<t;e++){const t=f[e];if(c.attributes[e]!==t){const r=this.get(t).buffer;l.setVertexBuffer(e,r),c.attributes[e]=t}}if(void 0!==a.occlusionQuerySet){const e=a.lastOcclusionObject;e!==r&&(null!==e&&!0===e.occlusionTest&&(l.endOcclusionQuery(),a.occlusionQueryIndex++),!0===r.occlusionTest&&(l.beginOcclusionQuery(a.occlusionQueryIndex),a.occlusionQueryObjects[a.occlusionQueryIndex]=r),a.lastOcclusionObject=r)}if(!0===r.isBatchedMesh){const e=r._multiDrawStarts,t=r._multiDrawCounts,i=r._multiDrawCount,s=r._multiDrawInstances,n=h?p.array.BYTES_PER_ELEMENT:1;for(let r=0;r<i;r++){const i=s?s[r]:1,a=i>1?0:r;l.drawIndexed(t[r],i,e[r]/n,0,a)}}else if(!0===h){const{vertexCount:i,instanceCount:s,firstVertex:n}=u,a=e.getIndirect();if(null!==a){const e=this.get(a).buffer;l.drawIndexedIndirect(e,0)}else l.drawIndexed(i,s,n,0,0);t.update(r,i,s)}else{const{vertexCount:i,instanceCount:s,firstVertex:n}=u,a=e.getIndirect();if(null!==a){const e=this.get(a).buffer;l.drawIndirect(e,0)}else l.draw(i,s,n,0);t.update(r,i,s)}}needsRenderUpdate(e){const t=this.get(e),{object:r,material:i}=e,s=this.utils,n=s.getSampleCountRenderContext(e.context),a=s.getCurrentColorSpace(e.context),o=s.getCurrentColorFormat(e.context),c=s.getCurrentDepthStencilFormat(e.context),l=s.getPrimitiveTopology(r,i);let u=!1;return t.material===i&&t.materialVersion===i.version&&t.transparent===i.transparent&&t.blending===i.blending&&t.premultipliedAlpha===i.premultipliedAlpha&&t.blendSrc===i.blendSrc&&t.blendDst===i.blendDst&&t.blendEquation===i.blendEquation&&t.blendSrcAlpha===i.blendSrcAlpha&&t.blendDstAlpha===i.blendDstAlpha&&t.blendEquationAlpha===i.blendEquationAlpha&&t.colorWrite===i.colorWrite&&t.depthWrite===i.depthWrite&&t.depthTest===i.depthTest&&t.depthFunc===i.depthFunc&&t.stencilWrite===i.stencilWrite&&t.stencilFunc===i.stencilFunc&&t.stencilFail===i.stencilFail&&t.stencilZFail===i.stencilZFail&&t.stencilZPass===i.stencilZPass&&t.stencilFuncMask===i.stencilFuncMask&&t.stencilWriteMask===i.stencilWriteMask&&t.side===i.side&&t.alphaToCoverage===i.alphaToCoverage&&t.sampleCount===n&&t.colorSpace===a&&t.colorFormat===o&&t.depthStencilFormat===c&&t.primitiveTopology===l&&t.clippingContextCacheKey===e.clippingContext.cacheKey||(t.material=i,t.materialVersion=i.version,t.transparent=i.transparent,t.blending=i.blending,t.premultipliedAlpha=i.premultipliedAlpha,t.blendSrc=i.blendSrc,t.blendDst=i.blendDst,t.blendEquation=i.blendEquation,t.blendSrcAlpha=i.blendSrcAlpha,t.blendDstAlpha=i.blendDstAlpha,t.blendEquationAlpha=i.blendEquationAlpha,t.colorWrite=i.colorWrite,t.depthWrite=i.depthWrite,t.depthTest=i.depthTest,t.depthFunc=i.depthFunc,t.stencilWrite=i.stencilWrite,t.stencilFunc=i.stencilFunc,t.stencilFail=i.stencilFail,t.stencilZFail=i.stencilZFail,t.stencilZPass=i.stencilZPass,t.stencilFuncMask=i.stencilFuncMask,t.stencilWriteMask=i.stencilWriteMask,t.side=i.side,t.alphaToCoverage=i.alphaToCoverage,t.sampleCount=n,t.colorSpace=a,t.colorFormat=o,t.depthStencilFormat=c,t.primitiveTopology=l,t.clippingContextCacheKey=e.clippingContext.cacheKey,u=!0),u}getRenderCacheKey(e){const{object:t,material:r}=e,i=this.utils,s=e.context;return[r.transparent,r.blending,r.premultipliedAlpha,r.blendSrc,r.blendDst,r.blendEquation,r.blendSrcAlpha,r.blendDstAlpha,r.blendEquationAlpha,r.colorWrite,r.depthWrite,r.depthTest,r.depthFunc,r.stencilWrite,r.stencilFunc,r.stencilFail,r.stencilZFail,r.stencilZPass,r.stencilFuncMask,r.stencilWriteMask,r.side,i.getSampleCountRenderContext(s),i.getCurrentColorSpace(s),i.getCurrentColorFormat(s),i.getCurrentDepthStencilFormat(s),i.getPrimitiveTopology(t,r),e.getGeometryCacheKey(),e.clippingContext.cacheKey].join()}createSampler(e){this.textureUtils.createSampler(e)}destroySampler(e){this.textureUtils.destroySampler(e)}createDefaultTexture(e){this.textureUtils.createDefaultTexture(e)}createTexture(e,t){this.textureUtils.createTexture(e,t)}updateTexture(e,t){this.textureUtils.updateTexture(e,t)}generateMipmaps(e){this.textureUtils.generateMipmaps(e)}destroyTexture(e){this.textureUtils.destroyTexture(e)}copyTextureToBuffer(e,t,r,i,s,n){return this.textureUtils.copyTextureToBuffer(e,t,r,i,s,n)}initTimestampQuery(e,t){if(!this.trackTimestamp)return;const r=this.get(e);if(!r.timeStampQuerySet){const e=this.device.createQuerySet({type:"timestamp",count:2}),i={querySet:e,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1};Object.assign(t,{timestampWrites:i}),r.timeStampQuerySet=e}}prepareTimestampBuffer(e,t){if(!this.trackTimestamp)return;const r=this.get(e),i=2*BigInt64Array.BYTES_PER_ELEMENT;void 0===r.currentTimestampQueryBuffers&&(r.currentTimestampQueryBuffers={resolveBuffer:this.device.createBuffer({label:"timestamp resolve buffer",size:i,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),resultBuffer:this.device.createBuffer({label:"timestamp result buffer",size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),isMappingPending:!1});const{resolveBuffer:s,resultBuffer:n,isMappingPending:a}=r.currentTimestampQueryBuffers;!0!==a&&(t.resolveQuerySet(r.timeStampQuerySet,0,2,s,0),t.copyBufferToBuffer(s,0,n,0,i))}async resolveTimestampAsync(e,t="render"){if(!this.trackTimestamp)return;const r=this.get(e);if(void 0===r.currentTimestampQueryBuffers)return;const{resultBuffer:i,isMappingPending:s}=r.currentTimestampQueryBuffers;!0!==s&&(r.currentTimestampQueryBuffers.isMappingPending=!0,i.mapAsync(GPUMapMode.READ).then((()=>{const e=new BigUint64Array(i.getMappedRange()),s=Number(e[1]-e[0])/1e6;this.renderer.info.updateTimestamp(t,s),i.unmap(),r.currentTimestampQueryBuffers.isMappingPending=!1})))}createNodeBuilder(e,t){return new WGSLNodeBuilder(e,t)}createProgram(e){this.get(e).module={module:this.device.createShaderModule({code:e.code,label:e.stage}),entryPoint:"main"}}destroyProgram(e){this.delete(e)}createRenderPipeline(e,t){this.pipelineUtils.createRenderPipeline(e,t)}createComputePipeline(e,t){this.pipelineUtils.createComputePipeline(e,t)}beginBundle(e){const t=this.get(e);t._currentPass=t.currentPass,t._currentSets=t.currentSets,t.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},t.currentPass=this.pipelineUtils.createBundleEncoder(e)}finishBundle(e,t){const r=this.get(e),i=r.currentPass.finish();this.get(t).bundleGPU=i,r.currentSets=r._currentSets,r.currentPass=r._currentPass}addBundle(e,t){this.get(e).renderBundles.push(this.get(t).bundleGPU)}createBindings(e){this.bindingUtils.createBindings(e)}updateBindings(e){this.bindingUtils.createBindings(e)}updateBinding(e){this.bindingUtils.updateBinding(e)}createIndexAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.INDEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createStorageAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createIndirectStorageAttribute(e){this.attributeUtils.createAttribute(e,GPUBufferUsage.STORAGE|GPUBufferUsage.INDIRECT|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}updateAttribute(e){this.attributeUtils.updateAttribute(e)}destroyAttribute(e){this.attributeUtils.destroyAttribute(e)}updateSize(){this.colorBuffer=this.textureUtils.getColorBuffer(),this.defaultRenderPassdescriptor=null}getMaxAnisotropy(){return 16}hasFeature(e){return this.device.features.has(e)}copyTextureToTexture(e,t,r=null,i=null,s=0){let n=0,a=0,o=0,c=0,l=0,u=0,d=e.image.width,p=e.image.height;null!==r&&(c=r.x,l=r.y,u=r.z||0,d=r.width,p=r.height),null!==i&&(n=i.x,a=i.y,o=i.z||0);const h=this.device.createCommandEncoder({label:"copyTextureToTexture_"+e.id+"_"+t.id}),f=this.get(e).texture,m=this.get(t).texture;h.copyTextureToTexture({texture:f,mipLevel:s,origin:{x:c,y:l,z:u}},{texture:m,mipLevel:s,origin:{x:n,y:a,z:o}},[d,p,1]),this.device.queue.submit([h.finish()])}copyFramebufferToTexture(e,t,r){const i=this.get(t);let s=null;s=t.renderTarget?e.isDepthTexture?this.get(t.depthTexture).texture:this.get(t.textures[0]).texture:e.isDepthTexture?this.textureUtils.getDepthBuffer(t.depth,t.stencil):this.context.getCurrentTexture();const n=this.get(e).texture;if(s.format!==n.format)return void console.error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.",s.format,n.format);let a;if(i.currentPass?(i.currentPass.end(),a=i.encoder):a=this.device.createCommandEncoder({label:"copyFramebufferToTexture_"+e.id}),a.copyTextureToTexture({texture:s,origin:{x:r.x,y:r.y,z:0}},{texture:n},[r.z,r.w]),e.generateMipmaps&&this.textureUtils.generateMipmaps(e),i.currentPass){const{descriptor:e}=i;for(let t=0;t<e.colorAttachments.length;t++)e.colorAttachments[t].loadOp=GPULoadOp.Load;t.depth&&(e.depthStencilAttachment.depthLoadOp=GPULoadOp.Load),t.stencil&&(e.depthStencilAttachment.stencilLoadOp=GPULoadOp.Load),i.currentPass=a.beginRenderPass(e),i.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null}}else this.device.queue.submit([a.finish()])}}export default WebGPUBackend;
//# sourceMappingURL=/sm/912c27c2a2d18317acb2822a31190363cce9349c03633f687513cb64cb49f1e5.map