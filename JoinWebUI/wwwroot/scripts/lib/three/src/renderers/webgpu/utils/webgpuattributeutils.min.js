/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/renderers/webgpu/utils/WebGPUAttributeUtils.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{GPUInputStepMode}from"./WebGPUConstants.js";import{Float16BufferAttribute}from"../../../core/BufferAttribute.js";const typedArraysToVertexFormatPrefix=new Map([[Int8Array,["sint8","snorm8"]],[Uint8Array,["uint8","unorm8"]],[Int16Array,["sint16","snorm16"]],[Uint16Array,["uint16","unorm16"]],[Int32Array,["sint32","snorm32"]],[Uint32Array,["uint32","unorm32"]],[Float32Array,["float32"]]]),typedAttributeToVertexFormatPrefix=new Map([[Float16BufferAttribute,["float16"]]]),typeArraysToVertexFormatPrefixForItemSize1=new Map([[Int32Array,"sint32"],[Int16Array,"sint32"],[Uint32Array,"uint32"],[Uint16Array,"uint32"],[Float32Array,"float32"]]);class WebGPUAttributeUtils{constructor(t){this.backend=t}createAttribute(t,e){const r=this._getBufferAttribute(t),a=this.backend,n=a.get(r);let i=n.buffer;if(void 0===i){const o=a.device;let s=r.array;if(!1===t.normalized&&(s.constructor===Int16Array||s.constructor===Uint16Array)){const t=new Uint32Array(s.length);for(let e=0;e<s.length;e++)t[e]=s[e];s=t}if(r.array=s,(r.isStorageBufferAttribute||r.isStorageInstancedBufferAttribute)&&3===r.itemSize){s=new s.constructor(4*r.count);for(let t=0;t<r.count;t++)s.set(r.array.subarray(3*t,3*t+3),4*t);r.itemSize=4,r.array=s}const u=s.byteLength+(4-s.byteLength%4)%4;i=o.createBuffer({label:r.name,size:u,usage:e,mappedAtCreation:!0}),new s.constructor(i.getMappedRange()).set(s),i.unmap(),n.buffer=i}}updateAttribute(t){const e=this._getBufferAttribute(t),r=this.backend,a=r.device,n=r.get(e).buffer,i=e.array,o=e.updateRanges;if(0===o.length)a.queue.writeBuffer(n,0,i,0);else{for(let t=0,e=o.length;t<e;t++){const e=o[t];a.queue.writeBuffer(n,0,i,e.start*i.BYTES_PER_ELEMENT,e.count*i.BYTES_PER_ELEMENT)}e.clearUpdateRanges()}}createShaderVertexBuffers(t){const e=t.getAttributes(),r=new Map;for(let t=0;t<e.length;t++){const a=e[t],n=a.array.BYTES_PER_ELEMENT,i=this._getBufferAttribute(a);let o=r.get(i);if(void 0===o){let t,e;!0===a.isInterleavedBufferAttribute?(t=a.data.stride*n,e=a.data.isInstancedInterleavedBuffer?GPUInputStepMode.Instance:GPUInputStepMode.Vertex):(t=a.itemSize*n,e=a.isInstancedBufferAttribute?GPUInputStepMode.Instance:GPUInputStepMode.Vertex),!1!==a.normalized||a.array.constructor!==Int16Array&&a.array.constructor!==Uint16Array||(t=4),o={arrayStride:t,attributes:[],stepMode:e},r.set(i,o)}const s=this._getVertexFormat(a),u=!0===a.isInterleavedBufferAttribute?a.offset*n:0;o.attributes.push({shaderLocation:t,offset:u,format:s})}return Array.from(r.values())}destroyAttribute(t){const e=this.backend;e.get(this._getBufferAttribute(t)).buffer.destroy(),e.delete(t)}async getArrayBufferAsync(t){const e=this.backend,r=e.device,a=e.get(this._getBufferAttribute(t)).buffer,n=a.size,i=r.createBuffer({label:t.name,size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),o=r.createCommandEncoder({});o.copyBufferToBuffer(a,0,i,0,n),i.unmap();const s=o.finish();r.queue.submit([s]),await i.mapAsync(GPUMapMode.READ);return i.getMappedRange()}_getVertexFormat(t){const{itemSize:e,normalized:r}=t,a=t.array.constructor,n=t.constructor;let i;if(1==e)i=typeArraysToVertexFormatPrefixForItemSize1.get(a);else{const t=(typedAttributeToVertexFormatPrefix.get(n)||typedArraysToVertexFormatPrefix.get(a))[r?1:0];if(t){const r=a.BYTES_PER_ELEMENT*e,n=4*Math.floor((r+3)/4)/a.BYTES_PER_ELEMENT;if(n%1)throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");i=`${t}x${n}`}}return i||console.error("THREE.WebGPUAttributeUtils: Vertex format not supported yet."),i}_getBufferAttribute(t){return t.isInterleavedBufferAttribute&&(t=t.data),t}}export default WebGPUAttributeUtils;
//# sourceMappingURL=/sm/9e45a11fcd4ba463fb88cf803abe53459eec3520c18334637d70283d5c51d864.map