/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/renderers/webgpu/nodes/WGSLNodeBuilder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import NodeUniformsGroup from"../../common/nodes/NodeUniformsGroup.js";import NodeSampler from"../../common/nodes/NodeSampler.js";import{NodeSampledTexture,NodeSampledCubeTexture,NodeSampledTexture3D}from"../../common/nodes/NodeSampledTexture.js";import NodeUniformBuffer from"../../common/nodes/NodeUniformBuffer.js";import NodeStorageBuffer from"../../common/nodes/NodeStorageBuffer.js";import{NodeBuilder,CodeNode}from"../../../nodes/Nodes.js";import{getFormat}from"../utils/WebGPUTextureUtils.js";import WGSLNodeParser from"./WGSLNodeParser.js";import{GPUBufferBindingType,GPUStorageTextureAccess}from"../utils/WebGPUConstants.js";import{NoColorSpace,FloatType}from"../../../constants.js";const GPUShaderStage=self.GPUShaderStage,gpuShaderStageLib={vertex:GPUShaderStage?GPUShaderStage.VERTEX:1,fragment:GPUShaderStage?GPUShaderStage.FRAGMENT:2,compute:GPUShaderStage?GPUShaderStage.COMPUTE:4},supports={instance:!0,swizzleAssign:!1,storageBuffer:!0},wgslFnOpLib={"^^":"tsl_xor"},wgslTypeLib={float:"f32",int:"i32",uint:"u32",bool:"bool",color:"vec3<f32>",vec2:"vec2<f32>",ivec2:"vec2<i32>",uvec2:"vec2<u32>",bvec2:"vec2<bool>",vec3:"vec3<f32>",ivec3:"vec3<i32>",uvec3:"vec3<u32>",bvec3:"vec3<bool>",vec4:"vec4<f32>",ivec4:"vec4<i32>",uvec4:"vec4<u32>",bvec4:"vec4<bool>",mat2:"mat2x2<f32>",mat3:"mat3x3<f32>",mat4:"mat4x4<f32>"},wgslPolyfill={tsl_xor:new CodeNode("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),mod_float:new CodeNode("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),mod_vec2:new CodeNode("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),mod_vec3:new CodeNode("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),mod_vec4:new CodeNode("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),equals_bool:new CodeNode("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),equals_bvec2:new CodeNode("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),equals_bvec3:new CodeNode("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),equals_bvec4:new CodeNode("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),repeatWrapping:new CodeNode("\nfn tsl_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {\n\n\tlet uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );\n\n\treturn ( ( uvScaled % dimension ) + dimension ) % dimension;\n\n}\n"),biquadraticTexture:new CodeNode("\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, level : i32 ) -> vec4f {\n\n\tlet iRes = vec2i( textureDimensions( map, level ) );\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2i( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2i( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2i( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2i( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n")},wgslMethods={dFdx:"dpdx",dFdy:"- dpdy",mod_float:"tsl_mod_float",mod_vec2:"tsl_mod_vec2",mod_vec3:"tsl_mod_vec3",mod_vec4:"tsl_mod_vec4",equals_bool:"tsl_equals_bool",equals_bvec2:"tsl_equals_bvec2",equals_bvec3:"tsl_equals_bvec3",equals_bvec4:"tsl_equals_bvec4",inversesqrt:"inverseSqrt",bitcast:"bitcast<f32>"};/Windows/g.test(navigator.userAgent)&&(wgslPolyfill.pow_float=new CodeNode("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"),wgslPolyfill.pow_vec2=new CodeNode("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }",[wgslPolyfill.pow_float]),wgslPolyfill.pow_vec3=new CodeNode("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }",[wgslPolyfill.pow_float]),wgslPolyfill.pow_vec4=new CodeNode("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }",[wgslPolyfill.pow_float]),wgslMethods.pow_float="tsl_pow_float",wgslMethods.pow_vec2="tsl_pow_vec2",wgslMethods.pow_vec3="tsl_pow_vec3",wgslMethods.pow_vec4="tsl_pow_vec4");let diagnostics="";!0!==/Firefox|Deno/g.test(navigator.userAgent)&&(diagnostics+="diagnostic( off, derivative_uniformity );\n");class WGSLNodeBuilder extends NodeBuilder{constructor(e,t){super(e,t,new WGSLNodeParser),this.uniformGroups={},this.builtins={},this.directives={},this.scopedArrays=new Map}needsToWorkingColorSpace(e){return!0===e.isVideoTexture&&e.colorSpace!==NoColorSpace}_generateTextureSample(e,t,r,n,o=this.shaderStage){return"fragment"===o?n?`textureSample( ${t}, ${t}_sampler, ${r}, ${n} )`:`textureSample( ${t}, ${t}_sampler, ${r} )`:this.isFilteredTexture(e)?this.generateFilteredTexture(e,t,r):this.generateTextureLod(e,t,r,"0")}_generateVideoSample(e,t,r=this.shaderStage){if("fragment"===r)return`textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${t}.x, 1.0 - ${t}.y ) )`;console.error(`WebGPURenderer: THREE.VideoTexture does not support ${r} shader.`)}_generateTextureSampleLevel(e,t,r,n,o,s=this.shaderStage){return"fragment"===s&&!1===this.isUnfilterable(e)?`textureSampleLevel( ${t}, ${t}_sampler, ${r}, ${n} )`:this.isFilteredTexture(e)?this.generateFilteredTexture(e,t,r,n):this.generateTextureLod(e,t,r,n)}generateFilteredTexture(e,t,r,n="0"){return this._include("biquadraticTexture"),`tsl_biquadraticTexture( ${t}, ${r}, i32( ${n} ) )`}generateTextureLod(e,t,r,n="0"){this._include("repeatWrapping");return`textureLoad( ${t}, tsl_repeatWrapping( ${r}, ${!0===e.isMultisampleRenderTargetTexture?`textureDimensions( ${t} )`:`textureDimensions( ${t}, 0 )`} ), i32( ${n} ) )`}generateTextureLoad(e,t,r,n,o="0u"){return n?`textureLoad( ${t}, ${r}, ${n}, ${o} )`:`textureLoad( ${t}, ${r}, ${o} )`}generateTextureStore(e,t,r,n){return`textureStore( ${t}, ${r}, ${n} )`}isUnfilterable(e){return"float"!==this.getComponentTypeFromTexture(e)||!this.isAvailable("float32Filterable")&&!0===e.isDataTexture&&e.type===FloatType||!0===e.isMultisampleRenderTargetTexture}generateTexture(e,t,r,n,o=this.shaderStage){let s=null;return s=!0===e.isVideoTexture?this._generateVideoSample(t,r,o):this.isUnfilterable(e)?this.generateTextureLod(e,t,r,"0",n,o):this._generateTextureSample(e,t,r,n,o),s}generateTextureGrad(e,t,r,n,o,s=this.shaderStage){if("fragment"===s)return`textureSampleGrad( ${t}, ${t}_sampler, ${r},  ${n[0]}, ${n[1]} )`;console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${s} shader.`)}generateTextureCompare(e,t,r,n,o,s=this.shaderStage){if("fragment"===s)return`textureSampleCompare( ${t}, ${t}_sampler, ${r}, ${n} )`;console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${s} shader.`)}generateTextureLevel(e,t,r,n,o,s=this.shaderStage){let i=null;return i=!0===e.isVideoTexture?this._generateVideoSample(t,r,s):this._generateTextureSampleLevel(e,t,r,n,o,s),i}generateTextureBias(e,t,r,n,o,s=this.shaderStage){if("fragment"===s)return`textureSampleBias( ${t}, ${t}_sampler, ${r}, ${n} )`;console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${s} shader.`)}getPropertyName(e,t=this.shaderStage){if(!0===e.isNodeVarying&&!0===e.needsInterpolation){if("vertex"===t)return`varyings.${e.name}`}else if(!0===e.isNodeUniform){const t=e.name,r=e.type;return"texture"===r||"cubeTexture"===r||"storageTexture"===r||"texture3D"===r?t:"buffer"===r||"storageBuffer"===r||"indirectStorageBuffer"===r?`NodeBuffer_${e.id}.${t}`:e.groupNode.name+"."+t}return super.getPropertyName(e)}getOutputStructName(){return"output"}_getUniformGroupCount(e){return Object.keys(this.uniforms[e]).length}getFunctionOperator(e){const t=wgslFnOpLib[e];return void 0!==t?(this._include(t),t):null}getStorageAccess(e){if(e.isStorageTextureNode)switch(e.access){case GPUStorageTextureAccess.ReadOnly:return"read";case GPUStorageTextureAccess.WriteOnly:return"write";default:return"read_write"}else switch(e.access){case GPUBufferBindingType.Storage:return"read_write";case GPUBufferBindingType.ReadOnlyStorage:return"read";default:return"write"}}getUniformFromNode(e,t,r,n=null){const o=super.getUniformFromNode(e,t,r,n),s=this.getDataFromNode(e,r,this.globalCache);if(void 0===s.uniformGPU){let n;const i=e.groupNode,u=i.name,a=this.getBindGroupArray(u,r);if("texture"===t||"cubeTexture"===t||"storageTexture"===t||"texture3D"===t){let s=null;if("texture"===t||"storageTexture"===t?s=new NodeSampledTexture(o.name,o.node,i,e.access?e.access:null):"cubeTexture"===t?s=new NodeSampledCubeTexture(o.name,o.node,i,e.access?e.access:null):"texture3D"===t&&(s=new NodeSampledTexture3D(o.name,o.node,i,e.access?e.access:null)),s.store=!0===e.isStorageTextureNode,s.setVisibility(gpuShaderStageLib[r]),"fragment"===r&&!1===this.isUnfilterable(e.value)&&!1===s.store){const e=new NodeSampler(`${o.name}_sampler`,o.node,i);e.setVisibility(gpuShaderStageLib[r]),a.push(e,s),n=[e,s]}else a.push(s),n=[s]}else if("buffer"===t||"storageBuffer"===t||"indirectStorageBuffer"===t){const o=new("buffer"===t?NodeUniformBuffer:NodeStorageBuffer)(e,i);o.setVisibility(gpuShaderStageLib[r]),a.push(o),n=o}else{const e=this.uniformGroups[r]||(this.uniformGroups[r]={});let s=e[u];void 0===s&&(s=new NodeUniformsGroup(u,i),s.setVisibility(gpuShaderStageLib[r]),e[u]=s,a.push(s)),n=this.getNodeUniform(o,t),s.addUniform(n)}s.uniformGPU=n}return o}getBuiltin(e,t,r,n=this.shaderStage){const o=this.builtins[n]||(this.builtins[n]=new Map);return!1===o.has(e)&&o.set(e,{name:e,property:t,type:r}),t}hasBuiltin(e,t=this.shaderStage){return void 0!==this.builtins[t]&&this.builtins[t].has(e)}getVertexIndex(){return"vertex"===this.shaderStage?this.getBuiltin("vertex_index","vertexIndex","u32","attribute"):"vertexIndex"}buildFunctionCode(e){const t=e.layout,r=this.flowShaderNode(e),n=[];for(const e of t.inputs)n.push(e.name+" : "+this.getType(e.type));let o=`fn ${t.name}( ${n.join(", ")} ) -> ${this.getType(t.type)} {\n${r.vars}\n${r.code}\n`;return r.result&&(o+=`\treturn ${r.result};\n`),o+="\n}\n",o}getInstanceIndex(){return"vertex"===this.shaderStage?this.getBuiltin("instance_index","instanceIndex","u32","attribute"):"instanceIndex"}getInvocationLocalIndex(){return this.getBuiltin("local_invocation_index","invocationLocalIndex","u32","attribute")}getSubgroupSize(){return this.enableSubGroups(),this.getBuiltin("subgroup_size","subgroupSize","u32","attribute")}getInvocationSubgroupIndex(){return this.enableSubGroups(),this.getBuiltin("subgroup_invocation_id","invocationSubgroupIndex","u32","attribute")}getSubgroupIndex(){return this.enableSubGroups(),this.getBuiltin("subgroup_id","subgroupIndex","u32","attribute")}getDrawIndex(){return null}getFrontFacing(){return this.getBuiltin("front_facing","isFront","bool")}getFragCoord(){return this.getBuiltin("position","fragCoord","vec4<f32>")+".xy"}getFragDepth(){return"output."+this.getBuiltin("frag_depth","depth","f32","output")}isFlipY(){return!1}enableDirective(e,t=this.shaderStage){(this.directives[t]||(this.directives[t]=new Set)).add(e)}getDirectives(e){const t=[],r=this.directives[e];if(void 0!==r)for(const e of r)t.push(`enable ${e};`);return t.join("\n")}enableSubGroups(){this.enableDirective("subgroups")}enableSubgroupsF16(){this.enableDirective("subgroups-f16")}enableClipDistances(){this.enableDirective("clip_distances")}enableShaderF16(){this.enableDirective("f16")}enableDualSourceBlending(){this.enableDirective("dual_source_blending")}getBuiltins(e){const t=[],r=this.builtins[e];if(void 0!==r)for(const{name:e,property:n,type:o}of r.values())t.push(`@builtin( ${e} ) ${n} : ${o}`);return t.join(",\n\t")}getScopedArray(e,t,r,n){return!1===this.scopedArrays.has(e)&&this.scopedArrays.set(e,{name:e,scope:t,bufferType:r,bufferCount:n}),e}getScopedArrays(e){if("compute"!==e)return;const t=[];for(const{name:e,scope:r,bufferType:n,bufferCount:o}of this.scopedArrays.values()){const s=this.getType(n);t.push(`var<${r}> ${e}: array< ${s}, ${o} >;`)}return t.join("\n")}getAttributes(e){const t=[];if("compute"===e&&(this.getBuiltin("global_invocation_id","id","vec3<u32>","attribute"),this.getBuiltin("workgroup_id","workgroupId","vec3<u32>","attribute"),this.getBuiltin("local_invocation_id","localId","vec3<u32>","attribute"),this.getBuiltin("num_workgroups","numWorkgroups","vec3<u32>","attribute"),this.renderer.hasFeature("subgroups")&&(this.enableDirective("subgroups",e),this.getBuiltin("subgroup_size","subgroupSize","u32","attribute"))),"vertex"===e||"compute"===e){const e=this.getBuiltins("attribute");e&&t.push(e);const r=this.getAttributesArray();for(let e=0,n=r.length;e<n;e++){const n=r[e],o=n.name,s=this.getType(n.type);t.push(`@location( ${e} ) ${o} : ${s}`)}}return t.join(",\n\t")}getStructMembers(e){const t=[],r=e.getMemberTypes();for(let e=0;e<r.length;e++){const n=r[e];t.push(`\t@location( ${e} ) m${e} : ${n}<f32>`)}const n=this.getBuiltins("output");return n&&t.push("\t"+n),t.join(",\n")}getStructs(e){const t=[],r=this.structs[e];for(let e=0,n=r.length;e<n;e++){const n=r[e],o=n.name;let s=`struct ${o} {\n`;s+=this.getStructMembers(n),s+="\n}",t.push(s),t.push(`\nvar<private> output : ${o};\n\n`)}return t.join("\n\n")}getVar(e,t){return`var ${t} : ${this.getType(e)}`}getVars(e){const t=[],r=this.vars[e];if(void 0!==r)for(const e of r)t.push(`\t${this.getVar(e.type,e.name)};`);return`\n${t.join("\n")}\n`}getVaryings(e){const t=[];if("vertex"===e&&this.getBuiltin("position","Vertex","vec4<f32>","vertex"),"vertex"===e||"fragment"===e){const r=this.varyings,n=this.vars[e];for(let o=0;o<r.length;o++){const s=r[o];if(s.needsInterpolation){let e=`@location( ${o} )`;/^(int|uint|ivec|uvec)/.test(s.type)&&(e+=" @interpolate( flat )"),t.push(`${e} ${s.name} : ${this.getType(s.type)}`)}else"vertex"===e&&!1===n.includes(s)&&n.push(s)}}const r=this.getBuiltins(e);r&&t.push(r);const n=t.join(",\n\t");return"vertex"===e?this._getWGSLStruct("VaryingsStruct","\t"+n):n}getUniforms(e){const t=this.uniforms[e],r=[],n=[],o=[],s={};for(const o of t){const t=o.groupNode.name,i=this.bindingsIndexes[t];if("texture"===o.type||"cubeTexture"===o.type||"storageTexture"===o.type||"texture3D"===o.type){const t=o.node.value;let n;"fragment"===e&&!1===this.isUnfilterable(t)&&!0!==o.node.isStorageTextureNode&&(!0===t.isDepthTexture&&null!==t.compareFunction?r.push(`@binding( ${i.binding++} ) @group( ${i.group} ) var ${o.name}_sampler : sampler_comparison;`):r.push(`@binding( ${i.binding++} ) @group( ${i.group} ) var ${o.name}_sampler : sampler;`));let s="";if(!0===t.isMultisampleRenderTargetTexture&&(s="_multisampled"),!0===t.isCubeTexture)n="texture_cube<f32>";else if(!0===t.isDataArrayTexture||!0===t.isCompressedArrayTexture)n="texture_2d_array<f32>";else if(!0===t.isDepthTexture)n=`texture_depth${s}_2d`;else if(!0===t.isVideoTexture)n="texture_external";else if(!0===t.isData3DTexture)n="texture_3d<f32>";else if(!0===o.node.isStorageTextureNode){n=`texture_storage_2d<${getFormat(t)}, ${this.getStorageAccess(o.node)}>`}else{n=`texture${s}_2d<${this.getComponentTypeFromTexture(t).charAt(0)}32>`}r.push(`@binding( ${i.binding++} ) @group( ${i.group} ) var ${o.name} : ${n};`)}else if("buffer"===o.type||"storageBuffer"===o.type||"indirectStorageBuffer"===o.type){const e=o.node,t=this.getType(e.bufferType),r=e.bufferCount,s=r>0&&"buffer"===o.type?", "+r:"",u=e.isAtomic?`atomic<${t}>`:`${t}`,a=`\t${o.name} : array< ${u}${s} >\n`,l=e.isStorageBufferNode?`storage, ${this.getStorageAccess(e)}`:"uniform";n.push(this._getWGSLStructBinding("NodeBuffer_"+e.id,a,l,i.binding++,i.group))}else{const e=this.getType(this.getVectorType(o.type)),t=o.groupNode.name;(s[t]||(s[t]={index:i.binding++,id:i.group,snippets:[]})).snippets.push(`\t${o.name} : ${e}`)}}for(const e in s){const t=s[e];o.push(this._getWGSLStructBinding(e,t.snippets.join(",\n"),"uniform",t.index,t.id))}let i=r.join("\n");return i+=n.join("\n"),i+=o.join("\n"),i}buildCode(){const e=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};this.sortBindingGroups();for(const t in e){const r=e[t];r.uniforms=this.getUniforms(t),r.attributes=this.getAttributes(t),r.varyings=this.getVaryings(t),r.structs=this.getStructs(t),r.vars=this.getVars(t),r.codes=this.getCodes(t),r.directives=this.getDirectives(t),r.scopedArrays=this.getScopedArrays(t);let n="// code\n\n";n+=this.flowCode[t];const o=this.flowNodes[t],s=o[o.length-1],i=s.outputNode,u=void 0!==i&&!0===i.isOutputStructNode;for(const e of o){const o=this.getFlowData(e),a=e.name;if(a&&(n.length>0&&(n+="\n"),n+=`\t// flow -> ${a}\n\t`),n+=`${o.code}\n\t`,e===s&&"compute"!==t)if(n+="// result\n\n\t","vertex"===t)n+=`varyings.Vertex = ${o.result};`;else if("fragment"===t)if(u)r.returnType=i.nodeType,n+=`return ${o.result};`;else{let e="\t@location(0) color: vec4<f32>";const t=this.getBuiltins("output");t&&(e+=",\n\t"+t),r.returnType="OutputStruct",r.structs+=this._getWGSLStruct("OutputStruct",e),r.structs+="\nvar<private> output : OutputStruct;\n\n",n+=`output.color = ${o.result};\n\n\treturn output;`}}r.flow=n}null!==this.material?(this.vertexShader=this._getWGSLVertexCode(e.vertex),this.fragmentShader=this._getWGSLFragmentCode(e.fragment)):this.computeShader=this._getWGSLComputeCode(e.compute,(this.object.workgroupSize||[64]).join(", "))}getMethod(e,t=null){let r;return null!==t&&(r=this._getWGSLMethod(e+"_"+t)),void 0===r&&(r=this._getWGSLMethod(e)),r||e}getType(e){return wgslTypeLib[e]||e}isAvailable(e){let t=supports[e];return void 0===t&&("float32Filterable"===e&&(t=this.renderer.hasFeature("float32-filterable")),supports[e]=t),t}_getWGSLMethod(e){return void 0!==wgslPolyfill[e]&&this._include(e),wgslMethods[e]}_include(e){const t=wgslPolyfill[e];return t.build(this),null!==this.currentFunctionNode&&this.currentFunctionNode.includes.push(t),t}_getWGSLVertexCode(e){return`${this.getSignature()}\n// directives\n${e.directives}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${e.codes}\n\n@vertex\nfn main( ${e.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n\treturn varyings;\n\n}\n`}_getWGSLFragmentCode(e){return`${this.getSignature()}\n// global\n${diagnostics}\n\n// uniforms\n${e.uniforms}\n\n// structs\n${e.structs}\n\n// codes\n${e.codes}\n\n@fragment\nfn main( ${e.varyings} ) -> ${e.returnType} {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getWGSLComputeCode(e,t){return`${this.getSignature()}\n// directives\n${e.directives}\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${e.scopedArrays}\n\n// uniforms\n${e.uniforms}\n\n// codes\n${e.codes}\n\n@compute @workgroup_size( ${t} )\nfn main( ${e.attributes} ) {\n\n\t// system\n\tinstanceIndex = id.x + id.y * numWorkgroups.x * u32(${t}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${t});\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}_getWGSLStruct(e,t){return`\nstruct ${e} {\n${t}\n};`}_getWGSLStructBinding(e,t,r,n=0,o=0){const s=e+"Struct";return`${this._getWGSLStruct(s,t)}\n@binding( ${n} ) @group( ${o} )\nvar<${r}> ${e} : ${s};`}}export default WGSLNodeBuilder;
//# sourceMappingURL=/sm/6454eafc474bc1d5d8af856461f6668ae9067c07ab1e4498a0641d758b0a3e9d.map