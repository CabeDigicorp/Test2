/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/renderers/webgpu/nodes/WGSLNodeFunction.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import NodeFunction from"../../../nodes/core/NodeFunction.js";import NodeFunctionInput from"../../../nodes/core/NodeFunctionInput.js";const declarationRegexp=/^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i,propertiesRegexp=/([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/gi,wgslTypeLib={f32:"float",i32:"int",u32:"uint",bool:"bool","vec2<f32>":"vec2","vec2<i32>":"ivec2","vec2<u32>":"uvec2","vec2<bool>":"bvec2",vec2f:"vec2",vec2i:"ivec2",vec2u:"uvec2",vec2b:"bvec2","vec3<f32>":"vec3","vec3<i32>":"ivec3","vec3<u32>":"uvec3","vec3<bool>":"bvec3",vec3f:"vec3",vec3i:"ivec3",vec3u:"uvec3",vec3b:"bvec3","vec4<f32>":"vec4","vec4<i32>":"ivec4","vec4<u32>":"uvec4","vec4<bool>":"bvec4",vec4f:"vec4",vec4i:"ivec4",vec4u:"uvec4",vec4b:"bvec4","mat2x2<f32>":"mat2",mat2x2f:"mat2","mat3x3<f32>":"mat3",mat3x3f:"mat3","mat4x4<f32>":"mat4",mat4x4f:"mat4",sampler:"sampler",texture_1d:"texture",texture_2d:"texture",texture_2d_array:"texture",texture_multisampled_2d:"cubeTexture",texture_depth_2d:"depthTexture",texture_3d:"texture3D",texture_cube:"cubeTexture",texture_cube_array:"cubeTexture",texture_storage_1d:"storageTexture",texture_storage_2d:"storageTexture",texture_storage_2d_array:"storageTexture",texture_storage_3d:"storageTexture"},parse=e=>{const t=(e=e.trim()).match(declarationRegexp);if(null!==t&&4===t.length){const o=t[2],c=[];let u=null;for(;null!==(u=propertiesRegexp.exec(o));)c.push({name:u[1],type:u[2]});const r=[];for(let e=0;e<c.length;e++){const{name:t,type:o}=c[e];let u=o;u.startsWith("ptr")?u="pointer":(u.startsWith("texture")&&(u=o.split("<")[0]),u=wgslTypeLib[u]),r.push(new NodeFunctionInput(u,t))}const s=e.substring(t[0].length),n=t[3]||"void",i=void 0!==t[1]?t[1]:"";return{type:wgslTypeLib[n]||n,inputs:r,name:i,inputsCode:o,blockCode:s,outputType:n}}throw new Error("FunctionNode: Function is not a WGSL code.")};class WGSLNodeFunction extends NodeFunction{constructor(e){const{type:t,inputs:o,name:c,inputsCode:u,blockCode:r,outputType:s}=parse(e);super(t,o,c),this.inputsCode=u,this.blockCode=r,this.outputType=s}getCode(e=this.name){const t="void"!==this.outputType?"-> "+this.outputType:"";return`fn ${e} ( ${this.inputsCode.trim()} ) ${t}`+this.blockCode}}export default WGSLNodeFunction;
//# sourceMappingURL=/sm/3d00386af5b208522010126b47074c658db81407e4301adef334e7416832628f.map