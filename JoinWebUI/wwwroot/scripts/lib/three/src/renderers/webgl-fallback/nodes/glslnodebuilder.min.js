/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/renderers/webgl-fallback/nodes/GLSLNodeBuilder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{GLSLNodeParser,NodeBuilder,TextureNode,vectorComponents}from"../../../nodes/Nodes.js";import NodeUniformBuffer from"../../common/nodes/NodeUniformBuffer.js";import NodeUniformsGroup from"../../common/nodes/NodeUniformsGroup.js";import{NodeSampledTexture,NodeSampledCubeTexture,NodeSampledTexture3D}from"../../common/nodes/NodeSampledTexture.js";import{NoColorSpace,ByteType,ShortType,RGBAIntegerFormat,RGBIntegerFormat,RedIntegerFormat,RGIntegerFormat,UnsignedByteType,UnsignedIntType,UnsignedShortType,RedFormat,RGFormat,IntType,RGBFormat,RGBAFormat,FloatType}from"../../../constants.js";import{DataTexture}from"../../../textures/DataTexture.js";const glslMethods={atan2:"atan",textureDimensions:"textureSize",equals:"equal"},precisionLib={low:"lowp",medium:"mediump",high:"highp"},supports={swizzleAssign:!0,storageBuffer:!1},defaultPrecisions="\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision lowp sampler2DShadow;\n";class GLSLNodeBuilder extends NodeBuilder{constructor(e,t){super(e,t,new GLSLNodeParser),this.uniformGroups={},this.transforms=[],this.extensions={},this.useComparisonMethod=!0}needsColorSpaceToLinearSRGB(e){return!0===e.isVideoTexture&&e.colorSpace!==NoColorSpace}getMethod(e){return glslMethods[e]||e}getOutputStructName(){return""}buildFunctionCode(e){const t=e.layout,n=this.flowShaderNode(e),r=[];for(const e of t.inputs)r.push(this.getType(e.type)+" "+e.name);return`${this.getType(t.type)} ${t.name}( ${r.join(", ")} ) {\n\n\t${n.vars}\n\n${n.code}\n\treturn ${n.result};\n\n}`}setupPBO(e){const t=e.value;if(void 0===t.pbo){const e=t.array,n=t.count*t.itemSize,{itemSize:r}=t,o=t.array.constructor.name.toLowerCase().includes("int");let s=o?RedIntegerFormat:RedFormat;2===r?s=o?RGIntegerFormat:RGFormat:3===r?s=o?RGBIntegerFormat:RGBFormat:4===r&&(s=o?RGBAIntegerFormat:RGBAFormat);const i={Float32Array:FloatType,Uint8Array:UnsignedByteType,Uint16Array:UnsignedShortType,Uint32Array:UnsignedIntType,Int8Array:ByteType,Int16Array:ShortType,Int32Array:IntType,Uint8ClampedArray:UnsignedByteType},a=Math.pow(2,Math.ceil(Math.log2(Math.sqrt(n/r))));let u=Math.ceil(n/r/a);a*u*r<n&&u++;const p=a*u*r,l=new e.constructor(p);l.set(e,0),t.array=l;const d=new DataTexture(t.array,a,u,s,i[t.array.constructor.name]||FloatType);d.needsUpdate=!0,d.isPBOTexture=!0;const m=new TextureNode(d,null,null);m.setPrecision("high"),t.pboNode=m,t.pbo=m.value,this.getUniformFromNode(t.pboNode,"texture",this.shaderStage,this.context.label)}}getPropertyName(e,t=this.shaderStage){return e.isNodeUniform&&!0!==e.node.isTextureNode&&!0!==e.node.isBufferNode?t.charAt(0)+"_"+e.name:super.getPropertyName(e,t)}generatePBO(e){const{node:t,indexNode:n}=e,r=t.value;if(this.renderer.backend.has(r)){this.renderer.backend.get(r).pbo=r.pbo}const o=this.getUniformFromNode(r.pboNode,"texture",this.shaderStage,this.context.label),s=this.getPropertyName(o);this.increaseUsage(n);const i=n.build(this,"uint"),a=this.getDataFromNode(e);let u=a.propertyName;if(void 0===u){const n=this.getVarFromNode(e);u=this.getPropertyName(n);const o=this.getDataFromNode(t);let p=o.propertySizeName;void 0===p&&(p=u+"Size",this.getVarFromNode(t,p,"uint"),this.addLineFlowCode(`${p} = uint( textureSize( ${s}, 0 ).x )`,e),o.propertySizeName=p);const{itemSize:l}=r,d="."+vectorComponents.join("").slice(0,l),m=`ivec2(${i} % ${p}, ${i} / ${p})`,c=this.generateTextureLoad(null,s,m,null,"0");let h="vec4";r.pbo.type===UnsignedIntType?h="uvec4":r.pbo.type===IntType&&(h="ivec4"),this.addLineFlowCode(`${u} = ${h}(${c})${d}`,e),a.propertyName=u}return u}generateTextureLoad(e,t,n,r,o="0"){return r?`texelFetch( ${t}, ivec3( ${n}, ${r} ), ${o} )`:`texelFetch( ${t}, ${n}, ${o} )`}generateTexture(e,t,n,r){return e.isDepthTexture?`texture( ${t}, ${n} ).x`:(r&&(n=`vec3( ${n}, ${r} )`),`texture( ${t}, ${n} )`)}generateTextureLevel(e,t,n,r){return`textureLod( ${t}, ${n}, ${r} )`}generateTextureBias(e,t,n,r){return`texture( ${t}, ${n}, ${r} )`}generateTextureGrad(e,t,n,r){return`textureGrad( ${t}, ${n}, ${r[0]}, ${r[1]} )`}generateTextureCompare(e,t,n,r,o,s=this.shaderStage){if("fragment"===s)return`texture( ${t}, vec3( ${n}, ${r} ) )`;console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${s} shader.`)}getVars(e){const t=[],n=this.vars[e];if(void 0!==n)for(const e of n)t.push(`${this.getVar(e.type,e.name)};`);return t.join("\n\t")}getUniforms(e){const t=this.uniforms[e],n=[],r={};for(const o of t){let t=null,s=!1;if("texture"===o.type){const e=o.node.value;let n="";!0===e.isDataTexture&&(e.type===UnsignedIntType?n="u":e.type===IntType&&(n="i")),t=e.compareFunction?`sampler2DShadow ${o.name};`:!0===e.isDataArrayTexture||!0===e.isCompressedArrayTexture?`${n}sampler2DArray ${o.name};`:`${n}sampler2D ${o.name};`}else if("cubeTexture"===o.type)t=`samplerCube ${o.name};`;else if("texture3D"===o.type)t=`sampler3D ${o.name};`;else if("buffer"===o.type){const e=o.node,n=this.getType(e.bufferType),r=e.bufferCount,s=r>0?r:"";t=`${e.name} {\n\t${n} ${o.name}[${s}];\n};\n`}else{t=`${this.getVectorType(o.type)} ${this.getPropertyName(o,e)};`,s=!0}const i=o.node.precision;if(null!==i&&(t=precisionLib[i]+" "+t),s){t="\t"+t;const e=o.groupNode.name;(r[e]||(r[e]=[])).push(t)}else t="uniform "+t,n.push(t)}let o="";for(const t in r){const n=r[t];o+=this._getGLSLUniformStruct(e+"_"+t,n.join("\n"))+"\n"}return o+=n.join("\n"),o}getTypeFromAttribute(e){let t=super.getTypeFromAttribute(e);if(/^[iu]/.test(t)&&e.gpuType!==IntType){let n=e;e.isInterleavedBufferAttribute&&(n=e.data);const r=n.array;!1==(r instanceof Uint32Array||r instanceof Int32Array)&&(t=t.slice(1))}return t}getAttributes(e){let t="";if("vertex"===e||"compute"===e){const e=this.getAttributesArray();let n=0;for(const r of e)t+=`layout( location = ${n++} ) in ${r.type} ${r.name};\n`}return t}getStructMembers(e){const t=[],n=e.getMemberTypes();for(let e=0;e<n.length;e++){const r=n[e];t.push(`layout( location = ${e} ) out ${r} m${e};`)}return t.join("\n")}getStructs(e){const t=[],n=this.structs[e];if(0===n.length)return"layout( location = 0 ) out vec4 fragColor;\n";for(let e=0,r=n.length;e<r;e++){const r=n[e];let o="\n";o+=this.getStructMembers(r),o+="\n",t.push(o)}return t.join("\n\n")}getVaryings(e){let t="";const n=this.varyings;if("vertex"===e||"compute"===e)for(const r of n){"compute"===e&&(r.needsInterpolation=!0);const n=r.type;t+=`${n.includes("int")||n.includes("uv")||n.includes("iv")?"flat ":""}${r.needsInterpolation?"out":"/*out*/"} ${n} ${r.name};\n`}else if("fragment"===e)for(const e of n)if(e.needsInterpolation){const n=e.type;t+=`${n.includes("int")||n.includes("uv")||n.includes("iv")?"flat ":""}in ${n} ${e.name};\n`}return t}getVertexIndex(){return"uint( gl_VertexID )"}getInstanceIndex(){return"uint( gl_InstanceID )"}getInvocationLocalIndex(){return`uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce(((e,t)=>e*t),1)}u`}getDrawIndex(){return this.renderer.backend.extensions.has("WEBGL_multi_draw")?"uint( gl_DrawID )":null}getFrontFacing(){return"gl_FrontFacing"}getFragCoord(){return"gl_FragCoord.xy"}getFragDepth(){return"gl_FragDepth"}enableExtension(e,t,n=this.shaderStage){const r=this.extensions[n]||(this.extensions[n]=new Map);!1===r.has(e)&&r.set(e,{name:e,behavior:t})}getExtensions(e){const t=[];if("vertex"===e){const t=this.renderer.backend.extensions;this.object.isBatchedMesh&&t.has("WEBGL_multi_draw")&&this.enableExtension("GL_ANGLE_multi_draw","require",e)}const n=this.extensions[e];if(void 0!==n)for(const{name:e,behavior:r}of n.values())t.push(`#extension ${e} : ${r}`);return t.join("\n")}isAvailable(e){let t=supports[e];if(void 0===t){if("float32Filterable"===e){const e=this.renderer.backend.extensions;e.has("OES_texture_float_linear")?(e.get("OES_texture_float_linear"),t=!0):t=!1}supports[e]=t}return t}isFlipY(){return!0}registerTransform(e,t){this.transforms.push({varyingName:e,attributeNode:t})}getTransforms(){const e=this.transforms;let t="";for(let n=0;n<e.length;n++){const r=e[n],o=this.getPropertyName(r.attributeNode);t+=`${r.varyingName} = ${o};\n\t`}return t}_getGLSLUniformStruct(e,t){return`\nlayout( std140 ) uniform ${e} {\n${t}\n};`}_getGLSLVertexCode(e){return`#version 300 es\n\n${this.getSignature()}\n\n// extensions \n${e.extensions}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\n\n// attributes\n${e.attributes}\n\n// codes\n${e.codes}\n\nvoid main() {\n\n\t// vars\n\t${e.vars}\n\n\t// transforms\n\t${e.transforms}\n\n\t// flow\n\t${e.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`}_getGLSLFragmentCode(e){return`#version 300 es\n\n${this.getSignature()}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${e.uniforms}\n\n// varyings\n${e.varyings}\n\n// codes\n${e.codes}\n\n${e.structs}\n\nvoid main() {\n\n\t// vars\n\t${e.vars}\n\n\t// flow\n\t${e.flow}\n\n}\n`}buildCode(){const e=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};this.sortBindingGroups();for(const t in e){let n="// code\n\n";n+=this.flowCode[t];const r=this.flowNodes[t],o=r[r.length-1];for(const e of r){const r=this.getFlowData(e),s=e.name;s&&(n.length>0&&(n+="\n"),n+=`\t// flow -> ${s}\n\t`),n+=`${r.code}\n\t`,e===o&&"compute"!==t&&(n+="// result\n\t","vertex"===t?(n+="gl_Position = ",n+=`${r.result};`):"fragment"===t&&(e.outputNode.isOutputStructNode||(n+="fragColor = ",n+=`${r.result};`)))}const s=e[t];s.extensions=this.getExtensions(t),s.uniforms=this.getUniforms(t),s.attributes=this.getAttributes(t),s.varyings=this.getVaryings(t),s.vars=this.getVars(t),s.structs=this.getStructs(t),s.codes=this.getCodes(t),s.transforms=this.getTransforms(t),s.flow=n}null!==this.material?(this.vertexShader=this._getGLSLVertexCode(e.vertex),this.fragmentShader=this._getGLSLFragmentCode(e.fragment)):this.computeShader=this._getGLSLVertexCode(e.compute)}getUniformFromNode(e,t,n,r=null){const o=super.getUniformFromNode(e,t,n,r),s=this.getDataFromNode(e,n,this.globalCache);let i=s.uniformGPU;if(void 0===i){const r=e.groupNode,a=r.name,u=this.getBindGroupArray(a,n);if("texture"===t)i=new NodeSampledTexture(o.name,o.node,r),u.push(i);else if("cubeTexture"===t)i=new NodeSampledCubeTexture(o.name,o.node,r),u.push(i);else if("texture3D"===t)i=new NodeSampledTexture3D(o.name,o.node,r),u.push(i);else if("buffer"===t){e.name=`NodeBuffer_${e.id}`,o.name=`buffer${e.id}`;const t=new NodeUniformBuffer(e,r);t.name=e.name,u.push(t),i=t}else{const e=this.uniformGroups[n]||(this.uniformGroups[n]={});let s=e[a];void 0===s&&(s=new NodeUniformsGroup(n+"_"+a,r),e[a]=s,u.push(s)),i=this.getNodeUniform(o,t),s.addUniform(i)}s.uniformGPU=i}return o}}export default GLSLNodeBuilder;
//# sourceMappingURL=/sm/977d0786e4ba5acdcce9b80aaf11927384b3dd6a6a46815436cdcfbd14e24843.map