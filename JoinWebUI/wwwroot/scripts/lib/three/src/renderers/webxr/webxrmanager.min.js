/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/renderers/webxr/WebXRManager.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{ArrayCamera}from"../../cameras/ArrayCamera.js";import{EventDispatcher}from"../../core/EventDispatcher.js";import{PerspectiveCamera}from"../../cameras/PerspectiveCamera.js";import{Vector2}from"../../math/Vector2.js";import{Vector3}from"../../math/Vector3.js";import{Vector4}from"../../math/Vector4.js";import{RAD2DEG}from"../../math/MathUtils.js";import{WebGLAnimation}from"../webgl/WebGLAnimation.js";import{WebGLRenderTarget}from"../WebGLRenderTarget.js";import{WebXRController}from"./WebXRController.js";import{DepthTexture}from"../../textures/DepthTexture.js";import{DepthFormat,DepthStencilFormat,RGBAFormat,UnsignedByteType,UnsignedIntType,UnsignedInt248Type}from"../../constants.js";import{WebXRDepthSensing}from"./WebXRDepthSensing.js";class WebXRManager extends EventDispatcher{constructor(e,t){super();const n=this;let r=null,i=1,o=null,a="local-floor",s=1,l=null,c=null,p=null,u=null,d=null,m=null;const f=new WebXRDepthSensing,h=t.getContextAttributes();let g=null,x=null;const v=[],y=[],R=new Vector2;let b=null;const W=new PerspectiveCamera;W.viewport=new Vector4;const w=new PerspectiveCamera;w.viewport=new Vector4;const S=[W,w],T=new ArrayCamera;let M=null,j=null;function E(e){const t=y.indexOf(e.inputSource);if(-1===t)return;const n=v[t];void 0!==n&&(n.update(e.inputSource,e.frame,l||o),n.dispatchEvent({type:e.type,data:e.inputSource}))}function L(){r.removeEventListener("select",E),r.removeEventListener("selectstart",E),r.removeEventListener("selectend",E),r.removeEventListener("squeeze",E),r.removeEventListener("squeezestart",E),r.removeEventListener("squeezeend",E),r.removeEventListener("end",L),r.removeEventListener("inputsourceschange",C);for(let e=0;e<v.length;e++){const t=y[e];null!==t&&(y[e]=null,v[e].disconnect(t))}M=null,j=null,f.reset(),e.setRenderTarget(g),d=null,u=null,p=null,r=null,x=null,V.stop(),n.isPresenting=!1,e.setPixelRatio(b),e.setSize(R.width,R.height,!1),n.dispatchEvent({type:"sessionend"})}function C(e){for(let t=0;t<e.removed.length;t++){const n=e.removed[t],r=y.indexOf(n);r>=0&&(y[r]=null,v[r].disconnect(n))}for(let t=0;t<e.added.length;t++){const n=e.added[t];let r=y.indexOf(n);if(-1===r){for(let e=0;e<v.length;e++){if(e>=y.length){y.push(n),r=e;break}if(null===y[e]){y[e]=n,r=e;break}}if(-1===r)break}const i=v[r];i&&i.connect(n)}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(e){let t=v[e];return void 0===t&&(t=new WebXRController,v[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){let t=v[e];return void 0===t&&(t=new WebXRController,v[e]=t),t.getGripSpace()},this.getHand=function(e){let t=v[e];return void 0===t&&(t=new WebXRController,v[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=function(e){i=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){a=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||o},this.setReferenceSpace=function(e){l=e},this.getBaseLayer=function(){return null!==u?u:d},this.getBinding=function(){return p},this.getFrame=function(){return m},this.getSession=function(){return r},this.setSession=async function(c){if(r=c,null!==r){if(g=e.getRenderTarget(),r.addEventListener("select",E),r.addEventListener("selectstart",E),r.addEventListener("selectend",E),r.addEventListener("squeeze",E),r.addEventListener("squeezestart",E),r.addEventListener("squeezeend",E),r.addEventListener("end",L),r.addEventListener("inputsourceschange",C),!0!==h.xrCompatible&&await t.makeXRCompatible(),b=e.getPixelRatio(),e.getSize(R),void 0===r.renderState.layers){const n={antialias:h.antialias,alpha:!0,depth:h.depth,stencil:h.stencil,framebufferScaleFactor:i};d=new XRWebGLLayer(r,t,n),r.updateRenderState({baseLayer:d}),e.setPixelRatio(1),e.setSize(d.framebufferWidth,d.framebufferHeight,!1),x=new WebGLRenderTarget(d.framebufferWidth,d.framebufferHeight,{format:RGBAFormat,type:UnsignedByteType,colorSpace:e.outputColorSpace,stencilBuffer:h.stencil})}else{let n=null,o=null,a=null;h.depth&&(a=h.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,n=h.stencil?DepthStencilFormat:DepthFormat,o=h.stencil?UnsignedInt248Type:UnsignedIntType);const s={colorFormat:t.RGBA8,depthFormat:a,scaleFactor:i};p=new XRWebGLBinding(r,t),u=p.createProjectionLayer(s),r.updateRenderState({layers:[u]}),e.setPixelRatio(1),e.setSize(u.textureWidth,u.textureHeight,!1),x=new WebGLRenderTarget(u.textureWidth,u.textureHeight,{format:RGBAFormat,type:UnsignedByteType,depthTexture:new DepthTexture(u.textureWidth,u.textureHeight,o,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:h.stencil,colorSpace:e.outputColorSpace,samples:h.antialias?4:0,resolveDepthBuffer:!1===u.ignoreDepthValues})}x.isXRRenderTarget=!0,this.setFoveation(s),l=null,o=await r.requestReferenceSpace(a),V.setContext(r),V.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(null!==r)return r.environmentBlendMode},this.getDepthTexture=function(){return f.getDepthTexture()};const D=new Vector3,F=new Vector3;function P(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.copy(e.matrixWorld).invert()}this.updateCamera=function(e){if(null===r)return;let t=e.near,n=e.far;null!==f.texture&&(f.depthNear>0&&(t=f.depthNear),f.depthFar>0&&(n=f.depthFar)),T.near=w.near=W.near=t,T.far=w.far=W.far=n,M===T.near&&j===T.far||(r.updateRenderState({depthNear:T.near,depthFar:T.far}),M=T.near,j=T.far),W.layers.mask=2|e.layers.mask,w.layers.mask=4|e.layers.mask,T.layers.mask=W.layers.mask|w.layers.mask;const i=e.parent,o=T.cameras;P(T,i);for(let e=0;e<o.length;e++)P(o[e],i);2===o.length?function(e,t,n){D.setFromMatrixPosition(t.matrixWorld),F.setFromMatrixPosition(n.matrixWorld);const r=D.distanceTo(F),i=t.projectionMatrix.elements,o=n.projectionMatrix.elements,a=i[14]/(i[10]-1),s=i[14]/(i[10]+1),l=(i[9]+1)/i[5],c=(i[9]-1)/i[5],p=(i[8]-1)/i[0],u=(o[8]+1)/o[0],d=a*p,m=a*u,f=r/(-p+u),h=f*-p;if(t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(h),e.translateZ(f),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.copy(e.matrixWorld).invert(),-1===i[10])e.projectionMatrix.copy(t.projectionMatrix),e.projectionMatrixInverse.copy(t.projectionMatrixInverse);else{const t=a+f,n=s+f,i=d-h,o=m+(r-h),p=l*s/n*t,u=c*s/n*t;e.projectionMatrix.makePerspective(i,o,p,u,t,n),e.projectionMatrixInverse.copy(e.projectionMatrix).invert()}}(T,W,w):T.projectionMatrix.copy(W.projectionMatrix),function(e,t,n){null===n?e.matrix.copy(t.matrixWorld):(e.matrix.copy(n.matrixWorld),e.matrix.invert(),e.matrix.multiply(t.matrixWorld));e.matrix.decompose(e.position,e.quaternion,e.scale),e.updateMatrixWorld(!0),e.projectionMatrix.copy(t.projectionMatrix),e.projectionMatrixInverse.copy(t.projectionMatrixInverse),e.isPerspectiveCamera&&(e.fov=2*RAD2DEG*Math.atan(1/e.projectionMatrix.elements[5]),e.zoom=1)}(e,T,i)},this.getCamera=function(){return T},this.getFoveation=function(){if(null!==u||null!==d)return s},this.setFoveation=function(e){s=e,null!==u&&(u.fixedFoveation=e),null!==d&&void 0!==d.fixedFoveation&&(d.fixedFoveation=e)},this.hasDepthSensing=function(){return null!==f.texture},this.getDepthSensingMesh=function(){return f.getMesh(T)};let A=null;const V=new WebGLAnimation;V.setAnimationLoop((function(t,i){if(c=i.getViewerPose(l||o),m=i,null!==c){const t=c.views;null!==d&&(e.setRenderTargetFramebuffer(x,d.framebuffer),e.setRenderTarget(x));let n=!1;t.length!==T.cameras.length&&(T.cameras.length=0,n=!0);for(let r=0;r<t.length;r++){const i=t[r];let o=null;if(null!==d)o=d.getViewport(i);else{const t=p.getViewSubImage(u,i);o=t.viewport,0===r&&(e.setRenderTargetTextures(x,t.colorTexture,u.ignoreDepthValues?void 0:t.depthStencilTexture),e.setRenderTarget(x))}let a=S[r];void 0===a&&(a=new PerspectiveCamera,a.layers.enable(r),a.viewport=new Vector4,S[r]=a),a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.quaternion,a.scale),a.projectionMatrix.fromArray(i.projectionMatrix),a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),a.viewport.set(o.x,o.y,o.width,o.height),0===r&&(T.matrix.copy(a.matrix),T.matrix.decompose(T.position,T.quaternion,T.scale)),!0===n&&T.cameras.push(a)}const i=r.enabledFeatures;if(i&&i.includes("depth-sensing")){const n=p.getDepthInformation(t[0]);n&&n.isValid&&n.texture&&f.init(e,n,r.renderState)}}for(let e=0;e<v.length;e++){const t=y[e],n=v[e];null!==t&&void 0!==n&&n.update(t,i,l||o)}A&&A(t,i),i.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:i}),m=null})),this.setAnimationLoop=function(e){A=e},this.dispose=function(){}}}export{WebXRManager};
//# sourceMappingURL=/sm/b39594ebbe42bacbbf29237f40a6eb560542742075c360414840ab4fd8b718ec.map