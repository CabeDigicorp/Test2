/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/renderers/webxr/WebXRDepthSensing.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{PlaneGeometry}from"../../geometries/PlaneGeometry.js";import{ShaderMaterial}from"../../materials/ShaderMaterial.js";import{Mesh}from"../../objects/Mesh.js";import{Texture}from"../../textures/Texture.js";const _occlusion_vertex="\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",_occlusion_fragment="\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}";class WebXRDepthSensing{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,t,r){if(null===this.texture){const o=new Texture;e.properties.get(o).__webglTexture=t.texture,t.depthNear==r.depthNear&&t.depthFar==r.depthFar||(this.depthNear=t.depthNear,this.depthFar=t.depthFar),this.texture=o}}getMesh(e){if(null!==this.texture&&null===this.mesh){const t=e.cameras[0].viewport,r=new ShaderMaterial({vertexShader:_occlusion_vertex,fragmentShader:_occlusion_fragment,uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new Mesh(new PlaneGeometry(20,20),r)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}export{WebXRDepthSensing};
//# sourceMappingURL=/sm/de3738e3a71138945011bd4f6e28617408d4378c2dad3a92de1f0f44b40d048e.map