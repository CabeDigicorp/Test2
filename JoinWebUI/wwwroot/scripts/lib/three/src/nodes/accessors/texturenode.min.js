/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/accessors/TextureNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import UniformNode,{uniform}from"../core/UniformNode.js";import{uv}from"./UV.js";import{textureSize}from"./TextureSizeNode.js";import{colorSpaceToWorking}from"../display/ColorSpaceNode.js";import{expression}from"../code/ExpressionNode.js";import{maxMipLevel}from"../utils/MaxMipLevelNode.js";import{nodeProxy,vec3,nodeObject,int}from"../tsl/TSLBase.js";import{NodeUpdateType}from"../core/constants.js";import{IntType,UnsignedIntType}from"../../constants.js";class TextureNode extends UniformNode{static get type(){return"TextureNode"}constructor(e,t=null,r=null,o=null){super(e),this.isTextureNode=!0,this.uvNode=t,this.levelNode=r,this.biasNode=o,this.compareNode=null,this.depthNode=null,this.gradNode=null,this.sampler=!0,this.updateMatrix=!1,this.updateType=NodeUpdateType.NONE,this.referenceNode=null,this._value=e,this._matrixUniform=null,this.setUpdateMatrix(null===t)}set value(e){this.referenceNode?this.referenceNode.value=e:this._value=e}get value(){return this.referenceNode?this.referenceNode.value:this._value}getUniformHash(){return this.value.uuid}getNodeType(){return!0===this.value.isDepthTexture?"float":this.value.type===UnsignedIntType?"uvec4":this.value.type===IntType?"ivec4":"vec4"}getInputType(){return"texture"}getDefaultUV(){return uv(this.value.channel)}updateReference(){return this.value}getTransformedUV(e){return null===this._matrixUniform&&(this._matrixUniform=uniform(this.value.matrix)),this._matrixUniform.mul(vec3(e,1)).xy}setUpdateMatrix(e){return this.updateMatrix=e,this.updateType=e?NodeUpdateType.FRAME:NodeUpdateType.NONE,this}setupUV(e,t){const r=this.value;return!e.isFlipY()||!0!==r.isRenderTargetTexture&&!0!==r.isFramebufferTexture&&!0!==r.isDepthTexture||(t=this.sampler?t.flipY():t.setY(int(textureSize(this,this.levelNode).y).sub(t.y).sub(1))),t}setup(e){const t=e.getNodeProperties(this);t.referenceNode=this.referenceNode;let r=this.uvNode;null!==r&&!0!==e.context.forceUVContext||!e.context.getUV||(r=e.context.getUV(this)),r||(r=this.getDefaultUV()),!0===this.updateMatrix&&(r=this.getTransformedUV(r)),r=this.setupUV(e,r);let o=this.levelNode;null===o&&e.context.getTextureLevel&&(o=e.context.getTextureLevel(this)),t.uvNode=r,t.levelNode=o,t.biasNode=this.biasNode,t.compareNode=this.compareNode,t.gradNode=this.gradNode,t.depthNode=this.depthNode}generateUV(e,t){return t.build(e,!0===this.sampler?"vec2":"ivec2")}generateSnippet(e,t,r,o,s,i,n,a){const u=this.value;let d;return d=o?e.generateTextureLevel(u,t,r,o,i):s?e.generateTextureBias(u,t,r,s,i):a?e.generateTextureGrad(u,t,r,a,i):n?e.generateTextureCompare(u,t,r,n,i):!1===this.sampler?e.generateTextureLoad(u,t,r,i):e.generateTexture(u,t,r,i),d}generate(e,t){const r=e.getNodeProperties(this),o=this.value;if(!o||!0!==o.isTexture)throw new Error("TextureNode: Need a three.js texture.");const s=super.generate(e,"property");if("sampler"===t)return s+"_sampler";if(e.isReference(t))return s;{const i=e.getDataFromNode(this);let n=i.propertyName;if(void 0===n){const{uvNode:t,levelNode:o,biasNode:a,compareNode:u,depthNode:d,gradNode:l}=r,p=this.generateUV(e,t),h=o?o.build(e,"float"):null,c=a?a.build(e,"float"):null,N=d?d.build(e,"int"):null,m=u?u.build(e,"float"):null,x=l?[l[0].build(e,"vec2"),l[1].build(e,"vec2")]:null,f=e.getVarFromNode(this);n=e.getPropertyName(f);const v=this.generateSnippet(e,s,p,h,c,N,m,x);e.addLineFlowCode(`${n} = ${v}`,this),i.snippet=v,i.propertyName=n}let a=n;const u=this.getNodeType(e);return e.needsToWorkingColorSpace(o)&&(a=colorSpaceToWorking(expression(a,u),o.colorSpace).setup(e).build(e,u)),e.format(a,u,t)}}setSampler(e){return this.sampler=e,this}getSampler(){return this.sampler}uv(e){const t=this.clone();return t.uvNode=nodeObject(e),t.referenceNode=this.getSelf(),nodeObject(t)}blur(e){const t=this.clone();return t.biasNode=nodeObject(e).mul(maxMipLevel(t)),t.referenceNode=this.getSelf(),nodeObject(t)}level(e){const t=this.clone();return t.levelNode=nodeObject(e),t.referenceNode=this.getSelf(),nodeObject(t)}size(e){return textureSize(this,e)}bias(e){const t=this.clone();return t.biasNode=nodeObject(e),t.referenceNode=this.getSelf(),nodeObject(t)}compare(e){const t=this.clone();return t.compareNode=nodeObject(e),t.referenceNode=this.getSelf(),nodeObject(t)}grad(e,t){const r=this.clone();return r.gradNode=[nodeObject(e),nodeObject(t)],r.referenceNode=this.getSelf(),nodeObject(r)}depth(e){const t=this.clone();return t.depthNode=nodeObject(e),t.referenceNode=this.getSelf(),nodeObject(t)}serialize(e){super.serialize(e),e.value=this.value.toJSON(e.meta).uuid,e.sampler=this.sampler,e.updateMatrix=this.updateMatrix,e.updateType=this.updateType}deserialize(e){super.deserialize(e),this.value=e.meta.textures[e.value],this.sampler=e.sampler,this.updateMatrix=e.updateMatrix,this.updateType=e.updateType}update(){const e=this.value,t=this._matrixUniform;null!==t&&(t.value=e.matrix),!0===e.matrixAutoUpdate&&e.updateMatrix()}clone(){const e=new this.constructor(this.value,this.uvNode,this.levelNode,this.biasNode);return e.sampler=this.sampler,e}}export default TextureNode;export const texture=nodeProxy(TextureNode);export const textureLoad=(...e)=>texture(...e).setSampler(!1);export const sampler=e=>(!0===e.isNode?e:texture(e)).convert("sampler");
//# sourceMappingURL=/sm/2a411ddfe35e691f5c5d82d8c7fad0fe3afca6948b657aca29bb73d15f34853d.map