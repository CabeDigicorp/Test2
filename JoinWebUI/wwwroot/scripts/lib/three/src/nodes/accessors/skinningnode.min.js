/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/accessors/SkinningNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Node from"../core/Node.js";import{NodeUpdateType}from"../core/constants.js";import{nodeObject}from"../tsl/TSLBase.js";import{attribute}from"../core/AttributeNode.js";import{reference,referenceBuffer}from"./ReferenceNode.js";import{add}from"../math/OperatorNode.js";import{normalLocal}from"./Normal.js";import{positionLocal,positionPrevious}from"./Position.js";import{tangentLocal}from"./Tangent.js";import{uniform}from"../core/UniformNode.js";import{buffer}from"./BufferNode.js";const _frameId=new WeakMap;class SkinningNode extends Node{static get type(){return"SkinningNode"}constructor(e,t=!1){let n,o,i;super("void"),this.skinnedMesh=e,this.useReference=t,this.updateType=NodeUpdateType.OBJECT,this.skinIndexNode=attribute("skinIndex","uvec4"),this.skinWeightNode=attribute("skinWeight","vec4"),t?(n=reference("bindMatrix","mat4"),o=reference("bindMatrixInverse","mat4"),i=referenceBuffer("skeleton.boneMatrices","mat4",e.skeleton.bones.length)):(n=uniform(e.bindMatrix,"mat4"),o=uniform(e.bindMatrixInverse,"mat4"),i=buffer(e.skeleton.boneMatrices,"mat4",e.skeleton.bones.length)),this.bindMatrixNode=n,this.bindMatrixInverseNode=o,this.boneMatricesNode=i,this.previousBoneMatricesNode=null}getSkinnedPosition(e=this.boneMatricesNode,t=positionLocal){const{skinIndexNode:n,skinWeightNode:o,bindMatrixNode:i,bindMatrixInverseNode:s}=this,r=e.element(n.x),a=e.element(n.y),d=e.element(n.z),m=e.element(n.w),l=i.mul(t),u=add(r.mul(o.x).mul(l),a.mul(o.y).mul(l),d.mul(o.z).mul(l),m.mul(o.w).mul(l));return s.mul(u).xyz}getSkinnedNormal(e=this.boneMatricesNode,t=normalLocal){const{skinIndexNode:n,skinWeightNode:o,bindMatrixNode:i,bindMatrixInverseNode:s}=this,r=e.element(n.x),a=e.element(n.y),d=e.element(n.z),m=e.element(n.w);let l=add(o.x.mul(r),o.y.mul(a),o.z.mul(d),o.w.mul(m));return l=s.mul(l).mul(i),l.transformDirection(t).xyz}getPreviousSkinnedPosition(e){const t=e.object;return null===this.previousBoneMatricesNode&&(t.skeleton.previousBoneMatrices=new Float32Array(t.skeleton.boneMatrices),this.previousBoneMatricesNode=referenceBuffer("skeleton.previousBoneMatrices","mat4",t.skeleton.bones.length)),this.getSkinnedPosition(this.previousBoneMatricesNode,positionPrevious)}needsPreviousBoneMatrices(e){const t=e.renderer.getMRT();return t&&t.has("velocity")}setup(e){this.needsPreviousBoneMatrices(e)&&positionPrevious.assign(this.getPreviousSkinnedPosition(e));const t=this.getSkinnedPosition();if(positionLocal.assign(t),e.hasGeometryAttribute("normal")){const t=this.getSkinnedNormal();normalLocal.assign(t),e.hasGeometryAttribute("tangent")&&tangentLocal.assign(t)}}generate(e,t){if("void"!==t)return positionLocal.build(e,t)}update(e){const t=(this.useReference?e.object:this.skinnedMesh).skeleton;_frameId.get(t)!==e.frameId&&(_frameId.set(t,e.frameId),null!==this.previousBoneMatricesNode&&t.previousBoneMatrices.set(t.boneMatrices),t.update())}}export default SkinningNode;export const skinning=e=>nodeObject(new SkinningNode(e));export const skinningReference=e=>nodeObject(new SkinningNode(e,!0));
//# sourceMappingURL=/sm/48bba4e1fa007454f758bbffe48591295024bbfe767d9f9b5a3cf1372cd5218e.map