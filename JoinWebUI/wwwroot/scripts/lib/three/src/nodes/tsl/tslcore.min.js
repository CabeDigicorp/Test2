/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/tsl/TSLCore.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Node from"../core/Node.js";import ArrayElementNode from"../utils/ArrayElementNode.js";import ConvertNode from"../utils/ConvertNode.js";import JoinNode from"../utils/JoinNode.js";import SplitNode from"../utils/SplitNode.js";import SetNode from"../utils/SetNode.js";import FlipNode from"../utils/FlipNode.js";import ConstNode from"../core/ConstNode.js";import{getValueFromType,getValueType}from"../core/NodeUtils.js";let currentStack=null;const NodeElements=new Map;export function addMethodChaining(e,t){if(NodeElements.has(e))console.warn(`Redefinition of method chaining ${e}`);else{if("function"!=typeof t)throw new Error(`Node element ${e} is not a function`);NodeElements.set(e,t)}}const parseSwizzle=e=>e.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),parseSwizzleAndSort=e=>parseSwizzle(e).split("").sort().join(""),shaderNodeHandler={setup(e,t){const o=t.shift();return e(nodeObjects(o),...t)},get(e,t,o){if("string"==typeof t&&void 0===e[t]){if(!0!==e.isStackNode&&"assign"===t)return(...e)=>(currentStack.assign(o,...e),o);if(NodeElements.has(t)){const n=NodeElements.get(t);return e.isStackNode?(...e)=>o.add(n(...e)):(...e)=>n(o,...e)}if("self"===t)return e;if(t.endsWith("Assign")&&NodeElements.has(t.slice(0,t.length-6))){const n=NodeElements.get(t.slice(0,t.length-6));return e.isStackNode?(...e)=>o.assign(e[0],n(...e)):(...e)=>o.assign(n(o,...e))}if(!0===/^[xyzwrgbastpq]{1,4}$/.test(t))return t=parseSwizzle(t),nodeObject(new SplitNode(o,t));if(!0===/^set[XYZWRGBASTPQ]{1,4}$/.test(t))return t=parseSwizzleAndSort(t.slice(3).toLowerCase()),o=>nodeObject(new SetNode(e,t,o));if(!0===/^flip[XYZWRGBASTPQ]{1,4}$/.test(t))return t=parseSwizzleAndSort(t.slice(4).toLowerCase()),()=>nodeObject(new FlipNode(nodeObject(e),t));if("width"===t||"height"===t||"depth"===t)return"width"===t?t="x":"height"===t?t="y":"depth"===t&&(t="z"),nodeObject(new SplitNode(e,t));if(!0===/^\d+$/.test(t))return nodeObject(new ArrayElementNode(o,new ConstNode(Number(t),"uint")))}return Reflect.get(e,t,o)},set:(e,t,o,n)=>"string"!=typeof t||void 0!==e[t]||!0!==/^[xyzwrgbastpq]{1,4}$/.test(t)&&"width"!==t&&"height"!==t&&"depth"!==t&&!0!==/^\d+$/.test(t)?Reflect.set(e,t,o,n):(n[t].assign(o),!0)},nodeObjectsCacheMap=new WeakMap,nodeBuilderFunctionsCacheMap=new WeakMap,ShaderNodeObject=function(e,t=null){const o=getValueType(e);if("node"===o){let t=nodeObjectsCacheMap.get(e);return void 0===t&&(t=new Proxy(e,shaderNodeHandler),nodeObjectsCacheMap.set(e,t),nodeObjectsCacheMap.set(t,t)),t}return null===t&&("float"===o||"boolean"===o)||o&&"shader"!==o&&"string"!==o?nodeObject(getConstNode(e,t)):"shader"===o?Fn(e):e},ShaderNodeObjects=function(e,t=null){for(const o in e)e[o]=nodeObject(e[o],t);return e},ShaderNodeArray=function(e,t=null){const o=e.length;for(let n=0;n<o;n++)e[n]=nodeObject(e[n],t);return e},ShaderNodeProxy=function(e,t=null,o=null,n=null){const r=e=>nodeObject(null!==n?Object.assign(e,n):e);return null===t?(...t)=>r(new e(...nodeArray(t))):null!==o?(o=nodeObject(o),(...n)=>r(new e(t,...nodeArray(n),o))):(...o)=>r(new e(t,...nodeArray(o)))},ShaderNodeImmutable=function(e,...t){return nodeObject(new e(...nodeArray(t)))};class ShaderCallNodeInternal extends Node{constructor(e,t){super(),this.shaderNode=e,this.inputNodes=t}getNodeType(e){return this.shaderNode.nodeType||this.getOutputNode(e).getNodeType(e)}call(e){const{shaderNode:t,inputNodes:o}=this,n=e.getNodeProperties(t);if(n.onceOutput)return n.onceOutput;let r=null;if(t.layout){let n=nodeBuilderFunctionsCacheMap.get(e.constructor);void 0===n&&(n=new WeakMap,nodeBuilderFunctionsCacheMap.set(e.constructor,n));let d=n.get(t);void 0===d&&(d=nodeObject(e.buildFunctionNode(t)),n.set(t,d)),null!==e.currentFunctionNode&&e.currentFunctionNode.includes.push(d),r=nodeObject(d.call(o))}else{const n=t.jsFunc,d=null!==o?n(o,e):n(e);r=nodeObject(d)}return t.once&&(n.onceOutput=r),r}getOutputNode(e){const t=e.getNodeProperties(this);return null===t.outputNode&&(t.outputNode=this.setupOutput(e)),t.outputNode}setup(e){return this.getOutputNode(e)}setupOutput(e){return e.addStack(),e.stack.outputNode=this.call(e),e.removeStack()}generate(e,t){return this.getOutputNode(e).build(e,t)}}class ShaderNodeInternal extends Node{constructor(e,t){super(t),this.jsFunc=e,this.layout=null,this.global=!0,this.once=!1}setLayout(e){return this.layout=e,this}call(e=null){return nodeObjects(e),nodeObject(new ShaderCallNodeInternal(this,e))}setup(){return this.call()}}const bools=[!1,!0],uints=[0,1,2,3],ints=[-1,-2],floats=[.5,1.5,1/3,1e-6,1e6,Math.PI,2*Math.PI,1/Math.PI,2/Math.PI,1/(2*Math.PI),Math.PI/2],boolsCacheMap=new Map;for(const e of bools)boolsCacheMap.set(e,new ConstNode(e));const uintsCacheMap=new Map;for(const t of uints)uintsCacheMap.set(t,new ConstNode(t,"uint"));const intsCacheMap=new Map([...uintsCacheMap].map((e=>new ConstNode(e.value,"int"))));for(const o of ints)intsCacheMap.set(o,new ConstNode(o,"int"));const floatsCacheMap=new Map([...intsCacheMap].map((e=>new ConstNode(e.value))));for(const n of floats)floatsCacheMap.set(n,new ConstNode(n));for(const r of floats)floatsCacheMap.set(-r,new ConstNode(-r));const cacheMaps={bool:boolsCacheMap,uint:uintsCacheMap,ints:intsCacheMap,float:floatsCacheMap},constNodesCacheMap=new Map([...boolsCacheMap,...floatsCacheMap]),getConstNode=(e,t)=>constNodesCacheMap.has(e)?constNodesCacheMap.get(e):!0===e.isNode?e:new ConstNode(e,t),safeGetNodeType=e=>{try{return e.getNodeType()}catch(e){return}},ConvertType=function(e,t=null){return(...o)=>{if((0===o.length||!["bool","float","int","uint"].includes(e)&&o.every((e=>"object"!=typeof e)))&&(o=[getValueFromType(e,...o)]),1===o.length&&null!==t&&t.has(o[0]))return nodeObject(t.get(o[0]));if(1===o.length){const t=getConstNode(o[0],e);return safeGetNodeType(t)===e?nodeObject(t):nodeObject(new ConvertNode(t,e))}const n=o.map((e=>getConstNode(e)));return nodeObject(new JoinNode(n,e))}};export const defined=e=>"object"==typeof e&&null!==e?e.value:e;export const getConstNodeType=e=>null!=e?e.nodeType||e.convertTo||("string"==typeof e?e:null):null;export function ShaderNode(e,t){return new Proxy(new ShaderNodeInternal(e,t),shaderNodeHandler)}export const nodeObject=(e,t=null)=>ShaderNodeObject(e,t);export const nodeObjects=(e,t=null)=>new ShaderNodeObjects(e,t);export const nodeArray=(e,t=null)=>new ShaderNodeArray(e,t);export const nodeProxy=(...e)=>new ShaderNodeProxy(...e);export const nodeImmutable=(...e)=>new ShaderNodeImmutable(...e);export const Fn=(e,t)=>{const o=new ShaderNode(e,t),n=(...e)=>{let t;return nodeObjects(e),t=e[0]&&e[0].isNode?[...e]:e[0],o.call(t)};return n.shaderNode=o,n.setLayout=e=>(o.setLayout(e),n),n.once=()=>(o.once=!0,n),n};export const tslFn=(...e)=>(console.warn("TSL.ShaderNode: tslFn() has been renamed to Fn()."),Fn(...e));addMethodChaining("toGlobal",(e=>(e.global=!0,e)));export const setCurrentStack=e=>{currentStack=e};export const getCurrentStack=()=>currentStack;export const If=(...e)=>currentStack.If(...e);export function append(e){return currentStack&&currentStack.add(e),e}addMethodChaining("append",append);export const color=new ConvertType("color");export const float=new ConvertType("float",cacheMaps.float);export const int=new ConvertType("int",cacheMaps.ints);export const uint=new ConvertType("uint",cacheMaps.uint);export const bool=new ConvertType("bool",cacheMaps.bool);export const vec2=new ConvertType("vec2");export const ivec2=new ConvertType("ivec2");export const uvec2=new ConvertType("uvec2");export const bvec2=new ConvertType("bvec2");export const vec3=new ConvertType("vec3");export const ivec3=new ConvertType("ivec3");export const uvec3=new ConvertType("uvec3");export const bvec3=new ConvertType("bvec3");export const vec4=new ConvertType("vec4");export const ivec4=new ConvertType("ivec4");export const uvec4=new ConvertType("uvec4");export const bvec4=new ConvertType("bvec4");export const mat2=new ConvertType("mat2");export const mat3=new ConvertType("mat3");export const mat4=new ConvertType("mat4");export const string=(e="")=>nodeObject(new ConstNode(e,"string"));export const arrayBuffer=e=>nodeObject(new ConstNode(e,"ArrayBuffer"));addMethodChaining("toColor",color),addMethodChaining("toFloat",float),addMethodChaining("toInt",int),addMethodChaining("toUint",uint),addMethodChaining("toBool",bool),addMethodChaining("toVec2",vec2),addMethodChaining("toIVec2",ivec2),addMethodChaining("toUVec2",uvec2),addMethodChaining("toBVec2",bvec2),addMethodChaining("toVec3",vec3),addMethodChaining("toIVec3",ivec3),addMethodChaining("toUVec3",uvec3),addMethodChaining("toBVec3",bvec3),addMethodChaining("toVec4",vec4),addMethodChaining("toIVec4",ivec4),addMethodChaining("toUVec4",uvec4),addMethodChaining("toBVec4",bvec4),addMethodChaining("toMat2",mat2),addMethodChaining("toMat3",mat3),addMethodChaining("toMat4",mat4);export const element=nodeProxy(ArrayElementNode);export const convert=(e,t)=>nodeObject(new ConvertNode(nodeObject(e),t));export const split=(e,t)=>nodeObject(new SplitNode(nodeObject(e),t));addMethodChaining("element",element),addMethodChaining("convert",convert);
//# sourceMappingURL=/sm/86868edc9aeeb72eb620ef6b6cbb3981db83834f174810e94091693a748ac919.map