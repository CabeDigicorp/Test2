/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/pmrem/PMREMNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import TempNode from"../core/TempNode.js";import{texture}from"../accessors/TextureNode.js";import{textureCubeUV}from"./PMREMUtils.js";import{uniform}from"../core/UniformNode.js";import{NodeUpdateType}from"../core/constants.js";import{nodeProxy,vec3}from"../tsl/TSLBase.js";import{WebGLCoordinateSystem}from"../../constants.js";import{Texture}from"../../textures/Texture.js";let _generator=null;const _cache=new WeakMap;function _generateCubeUVSize(e){const t=Math.log2(e)-2,r=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:r,maxMip:t}}function _getPMREMFromTexture(e){let t=_cache.get(e);if((void 0!==t?t.pmremVersion:-1)!==e.pmremVersion){const r=e.image;if(e.isCubeTexture){if(!isCubeMapReady(r))return null;t=_generator.fromCubemap(e,t)}else{if(!isEquirectangularMapReady(r))return null;t=_generator.fromEquirectangular(e,t)}t.pmremVersion=e.pmremVersion,_cache.set(e,t)}return t.texture}class PMREMNode extends TempNode{static get type(){return"PMREMNode"}constructor(e,t=null,r=null){super("vec3"),this._value=e,this._pmrem=null,this.uvNode=t,this.levelNode=r,this._generator=null;const i=new Texture;i.isRenderTargetTexture=!0,this._texture=texture(i),this._width=uniform(0),this._height=uniform(0),this._maxMip=uniform(0),this.updateBeforeType=NodeUpdateType.RENDER}set value(e){this._value=e,this._pmrem=null}get value(){return this._value}updateFromTexture(e){const t=_generateCubeUVSize(e.image.height);this._texture.value=e,this._width.value=t.texelWidth,this._height.value=t.texelHeight,this._maxMip.value=t.maxMip}updateBefore(){let e=this._pmrem;const t=e?e.pmremVersion:-1,r=this._value;t!==r.pmremVersion&&(e=!0===r.isPMREMTexture?r:_getPMREMFromTexture(r),null!==e&&(this._pmrem=e,this.updateFromTexture(e)))}setup(e){null===_generator&&(_generator=e.createPMREMGenerator()),this.updateBefore(e);let t=this.uvNode;null===t&&e.context.getUV&&(t=e.context.getUV(this));const r=this.value;e.renderer.coordinateSystem===WebGLCoordinateSystem&&!0!==r.isPMREMTexture&&!0===r.isRenderTargetTexture&&(t=vec3(t.x.negate(),t.yz));let i=this.levelNode;return null===i&&e.context.getTextureLevel&&(i=e.context.getTextureLevel(this)),textureCubeUV(this._texture,t,i,this._width,this._height,this._maxMip)}}export default PMREMNode;function isCubeMapReady(e){if(null==e)return!1;let t=0;for(let r=0;r<6;r++)void 0!==e[r]&&t++;return 6===t}function isEquirectangularMapReady(e){return null!=e&&e.height>0}export const pmremTexture=nodeProxy(PMREMNode);
//# sourceMappingURL=/sm/fbaa167a39c5532066da02ffab8d7987895bf043eaa07c7e123ee46599102aba.map