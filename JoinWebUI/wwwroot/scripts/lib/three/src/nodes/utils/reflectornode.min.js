/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/utils/ReflectorNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Node from"../core/Node.js";import TextureNode from"../accessors/TextureNode.js";import{nodeObject}from"../tsl/TSLBase.js";import{NodeUpdateType}from"../core/constants.js";import{screenUV}from"../display/ScreenNode.js";import{HalfFloatType,LinearMipMapLinearFilter,WebGPUCoordinateSystem}from"../../constants.js";import{Plane}from"../../math/Plane.js";import{Object3D}from"../../core/Object3D.js";import{Vector2}from"../../math/Vector2.js";import{Vector3}from"../../math/Vector3.js";import{Vector4}from"../../math/Vector4.js";import{Matrix4}from"../../math/Matrix4.js";import{RenderTarget}from"../../core/RenderTarget.js";import{DepthTexture}from"../../textures/DepthTexture.js";const _reflectorPlane=new Plane,_normal=new Vector3,_reflectorWorldPosition=new Vector3,_cameraWorldPosition=new Vector3,_rotationMatrix=new Matrix4,_lookAtPosition=new Vector3(0,0,-1),clipPlane=new Vector4,_view=new Vector3,_target=new Vector3,_q=new Vector4,_size=new Vector2,_defaultRT=new RenderTarget,_defaultUV=screenUV.flipX();_defaultRT.depthTexture=new DepthTexture(1,1);let _inReflector=!1;class ReflectorNode extends TextureNode{static get type(){return"ReflectorNode"}constructor(e={}){super(e.defaultTexture||_defaultRT.texture,_defaultUV),this._reflectorBaseNode=e.reflector||new ReflectorBaseNode(this,e),this._depthNode=null,this.setUpdateMatrix(!1)}get reflector(){return this._reflectorBaseNode}get target(){return this._reflectorBaseNode.target}getDepthNode(){if(null===this._depthNode){if(!0!==this._reflectorBaseNode.depth)throw new Error("THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ");this._depthNode=nodeObject(new ReflectorNode({defaultTexture:_defaultRT.depthTexture,reflector:this._reflectorBaseNode}))}return this._depthNode}setup(e){return e.object.isQuadMesh||this._reflectorBaseNode.build(e),super.setup(e)}clone(){const e=new this.constructor(this.reflectorNode);return e._reflectorBaseNode=this._reflectorBaseNode,e}}class ReflectorBaseNode extends Node{static get type(){return"ReflectorBaseNode"}constructor(e,t={}){super();const{target:r=new Object3D,resolution:o=1,generateMipmaps:a=!1,bounces:i=!0,depth:n=!1}=t;this.textureNode=e,this.target=r,this.resolution=o,this.generateMipmaps=a,this.bounces=i,this.depth=n,this.updateBeforeType=i?NodeUpdateType.RENDER:NodeUpdateType.FRAME,this.virtualCameras=new WeakMap,this.renderTargets=new WeakMap}_updateResolution(e,t){const r=this.resolution;t.getDrawingBufferSize(_size),e.setSize(Math.round(_size.width*r),Math.round(_size.height*r))}setup(e){return this._updateResolution(_defaultRT,e.renderer),super.setup(e)}getVirtualCamera(e){let t=this.virtualCameras.get(e);return void 0===t&&(t=e.clone(),this.virtualCameras.set(e,t)),t}getRenderTarget(e){let t=this.renderTargets.get(e);return void 0===t&&(t=new RenderTarget(0,0,{type:HalfFloatType}),!0===this.generateMipmaps&&(t.texture.minFilter=LinearMipMapLinearFilter,t.texture.generateMipmaps=!0),!0===this.depth&&(t.depthTexture=new DepthTexture),this.renderTargets.set(e,t)),t}updateBefore(e){if(!1===this.bounces&&_inReflector)return;_inReflector=!0;const{scene:t,camera:r,renderer:o,material:a}=e,{target:i}=this,n=this.getVirtualCamera(r),s=this.getRenderTarget(n);if(o.getDrawingBufferSize(_size),this._updateResolution(s,o),_reflectorWorldPosition.setFromMatrixPosition(i.matrixWorld),_cameraWorldPosition.setFromMatrixPosition(r.matrixWorld),_rotationMatrix.extractRotation(i.matrixWorld),_normal.set(0,0,1),_normal.applyMatrix4(_rotationMatrix),_view.subVectors(_reflectorWorldPosition,_cameraWorldPosition),_view.dot(_normal)>0)return;_view.reflect(_normal).negate(),_view.add(_reflectorWorldPosition),_rotationMatrix.extractRotation(r.matrixWorld),_lookAtPosition.set(0,0,-1),_lookAtPosition.applyMatrix4(_rotationMatrix),_lookAtPosition.add(_cameraWorldPosition),_target.subVectors(_reflectorWorldPosition,_lookAtPosition),_target.reflect(_normal).negate(),_target.add(_reflectorWorldPosition),n.coordinateSystem=r.coordinateSystem,n.position.copy(_view),n.up.set(0,1,0),n.up.applyMatrix4(_rotationMatrix),n.up.reflect(_normal),n.lookAt(_target),n.near=r.near,n.far=r.far,n.updateMatrixWorld(),n.projectionMatrix.copy(r.projectionMatrix),_reflectorPlane.setFromNormalAndCoplanarPoint(_normal,_reflectorWorldPosition),_reflectorPlane.applyMatrix4(n.matrixWorldInverse),clipPlane.set(_reflectorPlane.normal.x,_reflectorPlane.normal.y,_reflectorPlane.normal.z,_reflectorPlane.constant);const l=n.projectionMatrix;_q.x=(Math.sign(clipPlane.x)+l.elements[8])/l.elements[0],_q.y=(Math.sign(clipPlane.y)+l.elements[9])/l.elements[5],_q.z=-1,_q.w=(1+l.elements[10])/l.elements[14],clipPlane.multiplyScalar(1/clipPlane.dot(_q));l.elements[2]=clipPlane.x,l.elements[6]=clipPlane.y,l.elements[10]=o.coordinateSystem===WebGPUCoordinateSystem?clipPlane.z-0:clipPlane.z+1-0,l.elements[14]=clipPlane.w,this.textureNode.value=s.texture,!0===this.depth&&(this.textureNode.getDepthNode().value=s.depthTexture),a.visible=!1;const c=o.getRenderTarget(),d=o.getMRT();o.setMRT(null),o.setRenderTarget(s),o.render(t,n),o.setMRT(d),o.setRenderTarget(c),a.visible=!0,_inReflector=!1}}export const reflector=e=>nodeObject(new ReflectorNode(e));export default ReflectorNode;
//# sourceMappingURL=/sm/dee0d0f9e5ff811c54025a8a076cc37b52cde023b3a475e0798a2a98c321b3a0.map