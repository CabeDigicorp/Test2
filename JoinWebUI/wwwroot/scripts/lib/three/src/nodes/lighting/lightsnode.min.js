/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/lighting/LightsNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Node from"../core/Node.js";import{nodeObject,vec3}from"../tsl/TSLBase.js";const sortLights=t=>t.sort(((t,s)=>t.id-s.id)),getLightNodeById=(t,s)=>{for(const e of s)if(e.isAnalyticLightNode&&e.light.id===t)return e;return null},_lightsNodeRef=new WeakMap;class LightsNode extends Node{static get type(){return"LightsNode"}constructor(){super("vec3"),this.totalDiffuseNode=vec3().toVar("totalDiffuse"),this.totalSpecularNode=vec3().toVar("totalSpecular"),this.outgoingLightNode=vec3().toVar("outgoingLight"),this._lights=[],this._lightNodes=null,this._lightNodesHash=null,this.global=!0}getHash(t){if(null===this._lightNodesHash){null===this._lightNodes&&this.setupLightsNode(t);const s=[];for(const t of this._lightNodes)s.push(t.getSelf().getHash());this._lightNodesHash="lights-"+s.join(",")}return this._lightNodesHash}analyze(t){const s=t.getDataFromNode(this);for(const e of s.nodes)e.build(t)}setupLightsNode(t){const s=[],e=this._lightNodes,i=sortLights(this._lights),o=t.renderer.library;for(const t of i)if(t.isNode)s.push(nodeObject(t));else{let i=null;if(null!==e&&(i=getLightNodeById(t.id,e)),null===i){const e=o.getLightNodeClass(t.constructor);if(null===e){console.warn(`LightsNode.setupNodeLights: Light node not found for ${t.constructor.name}`);continue}let i=null;_lightsNodeRef.has(t)?i=_lightsNodeRef.get(t):(i=nodeObject(new e(t)),_lightsNodeRef.set(t,i)),s.push(i)}}this._lightNodes=s}setupLights(t,s){for(const e of s)e.build(t)}setup(t){null===this._lightNodes&&this.setupLightsNode(t);const s=t.context,e=s.lightingModel;let i=this.outgoingLightNode;if(e){const{_lightNodes:o,totalDiffuseNode:h,totalSpecularNode:l}=this;s.outgoingLight=i;const n=t.addStack();t.getDataFromNode(this).nodes=n.nodes,e.start(s,n,t),this.setupLights(t,o),e.indirect(s,n,t);const{backdrop:d,backdropAlpha:g}=s,{directDiffuse:r,directSpecular:a,indirectDiffuse:u,indirectSpecular:c}=s.reflectedLight;let N=r.add(u);null!==d&&(N=vec3(null!==g?g.mix(N,d):d),s.material.transparent=!0),h.assign(N),l.assign(a.add(c)),i.assign(h.add(l)),e.finish(s,n,t),i=i.bypass(t.removeStack())}return i}setLights(t){return this._lights=t,this._lightNodes=null,this._lightNodesHash=null,this}getLights(){return this._lights}get hasLights(){return this._lights.length>0}}export default LightsNode;export const lights=(t=[])=>nodeObject(new LightsNode).setLights(t);
//# sourceMappingURL=/sm/1c64f32ecf40543b9980b1b063767790830e91a9433d35acdd8fdf9943ee76be.map