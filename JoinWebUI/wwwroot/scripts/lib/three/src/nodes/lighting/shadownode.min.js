/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/lighting/ShadowNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Node from"../core/Node.js";import{NodeUpdateType}from"../core/constants.js";import{uniform}from"../core/UniformNode.js";import{float,vec2,vec3,vec4,If,int,Fn,nodeObject}from"../tsl/TSLBase.js";import{reference}from"../accessors/ReferenceNode.js";import{texture}from"../accessors/TextureNode.js";import{positionWorld}from"../accessors/Position.js";import{transformedNormalWorld}from"../accessors/Normal.js";import{mix,fract,step,max,clamp,sqrt}from"../math/MathNode.js";import{add,sub}from"../math/OperatorNode.js";import{DepthTexture}from"../../textures/DepthTexture.js";import NodeMaterial from"../../materials/nodes/NodeMaterial.js";import QuadMesh from"../../renderers/common/QuadMesh.js";import{Loop}from"../utils/LoopNode.js";import{screenCoordinate}from"../display/ScreenNode.js";import{HalfFloatType,LessCompare,RGFormat,VSMShadowMap,WebGPUCoordinateSystem}from"../../constants.js";import{renderGroup}from"../core/UniformGroupNode.js";import{perspectiveDepthToLogarithmicDepth}from"../display/ViewportDepthNode.js";const BasicShadowMap=Fn((({depthTexture:e,shadowCoord:a})=>texture(e,a.xy).compare(a.z))),PCFShadowMap=Fn((({depthTexture:e,shadowCoord:a,shadow:t})=>{const o=(a,t)=>texture(e,a).compare(t),r=reference("mapSize","vec2",t).setGroup(renderGroup),s=reference("radius","float",t).setGroup(renderGroup),d=vec2(1).div(r),i=d.x.negate().mul(s),n=d.y.negate().mul(s),l=d.x.mul(s),h=d.y.mul(s),p=i.div(2),m=n.div(2),c=l.div(2),u=h.div(2);return add(o(a.xy.add(vec2(i,n)),a.z),o(a.xy.add(vec2(0,n)),a.z),o(a.xy.add(vec2(l,n)),a.z),o(a.xy.add(vec2(p,m)),a.z),o(a.xy.add(vec2(0,m)),a.z),o(a.xy.add(vec2(c,m)),a.z),o(a.xy.add(vec2(i,0)),a.z),o(a.xy.add(vec2(p,0)),a.z),o(a.xy,a.z),o(a.xy.add(vec2(c,0)),a.z),o(a.xy.add(vec2(l,0)),a.z),o(a.xy.add(vec2(p,u)),a.z),o(a.xy.add(vec2(0,u)),a.z),o(a.xy.add(vec2(c,u)),a.z),o(a.xy.add(vec2(i,h)),a.z),o(a.xy.add(vec2(0,h)),a.z),o(a.xy.add(vec2(l,h)),a.z)).mul(1/17)})),PCFSoftShadowMap=Fn((({depthTexture:e,shadowCoord:a,shadow:t})=>{const o=(a,t)=>texture(e,a).compare(t),r=reference("mapSize","vec2",t).setGroup(renderGroup),s=vec2(1).div(r),d=s.x,i=s.y,n=a.xy,l=fract(n.mul(r).add(.5));return n.subAssign(l.mul(s)),add(o(n,a.z),o(n.add(vec2(d,0)),a.z),o(n.add(vec2(0,i)),a.z),o(n.add(s),a.z),mix(o(n.add(vec2(d.negate(),0)),a.z),o(n.add(vec2(d.mul(2),0)),a.z),l.x),mix(o(n.add(vec2(d.negate(),i)),a.z),o(n.add(vec2(d.mul(2),i)),a.z),l.x),mix(o(n.add(vec2(0,i.negate())),a.z),o(n.add(vec2(0,i.mul(2))),a.z),l.y),mix(o(n.add(vec2(d,i.negate())),a.z),o(n.add(vec2(d,i.mul(2))),a.z),l.y),mix(mix(o(n.add(vec2(d.negate(),i.negate())),a.z),o(n.add(vec2(d.mul(2),i.negate())),a.z),l.x),mix(o(n.add(vec2(d.negate(),i.mul(2))),a.z),o(n.add(vec2(d.mul(2),i.mul(2))),a.z),l.x),l.y)).mul(1/9)})),VSMShadowMapNode=Fn((({depthTexture:e,shadowCoord:a})=>{const t=float(1).toVar(),o=texture(e).uv(a.xy).rg,r=step(a.z,o.x);return If(r.notEqual(float(1)),(()=>{const e=a.z.sub(o.x),s=max(0,o.y.mul(o.y));let d=s.div(s.add(e.mul(e)));d=clamp(sub(d,.3).div(.95-.3)),t.assign(clamp(max(r,d)))})),t})),VSMPassVertical=Fn((({samples:e,radius:a,size:t,shadowPass:o})=>{const r=float(0).toVar(),s=float(0).toVar(),d=e.lessThanEqual(float(1)).select(float(0),float(2).div(e.sub(1))),i=e.lessThanEqual(float(1)).select(float(0),float(-1));Loop({start:int(0),end:int(e),type:"int",condition:"<"},(({i:e})=>{const n=i.add(float(e).mul(d)),l=o.uv(add(screenCoordinate.xy,vec2(0,n).mul(a)).div(t)).x;r.addAssign(l),s.addAssign(l.mul(l))})),r.divAssign(e),s.divAssign(e);const n=sqrt(s.sub(r.mul(r)));return vec2(r,n)})),VSMPassHorizontal=Fn((({samples:e,radius:a,size:t,shadowPass:o})=>{const r=float(0).toVar(),s=float(0).toVar(),d=e.lessThanEqual(float(1)).select(float(0),float(2).div(e.sub(1))),i=e.lessThanEqual(float(1)).select(float(0),float(-1));Loop({start:int(0),end:int(e),type:"int",condition:"<"},(({i:e})=>{const n=i.add(float(e).mul(d)),l=o.uv(add(screenCoordinate.xy,vec2(n,0).mul(a)).div(t));r.addAssign(l.x),s.addAssign(add(l.y.mul(l.y),l.x.mul(l.x)))})),r.divAssign(e),s.divAssign(e);const n=sqrt(s.sub(r.mul(r)));return vec2(r,n)})),_shadowFilterLib=[BasicShadowMap,PCFShadowMap,PCFSoftShadowMap,VSMShadowMapNode];let _overrideMaterial=null;const _quadMesh=new QuadMesh;class ShadowNode extends Node{static get type(){return"ShadowNode"}constructor(e,a=null){super(),this.light=e,this.shadow=a||e.shadow,this.shadowMap=null,this.vsmShadowMapVertical=null,this.vsmShadowMapHorizontal=null,this.vsmMaterialVertical=null,this.vsmMaterialHorizontal=null,this.updateBeforeType=NodeUpdateType.RENDER,this._node=null,this.isShadowNode=!0}setupShadow(e){const{object:a,renderer:t}=e;null===_overrideMaterial&&(_overrideMaterial=new NodeMaterial,_overrideMaterial.fragmentNode=vec4(0,0,0,1),_overrideMaterial.isShadowNodeMaterial=!0,_overrideMaterial.name="ShadowMaterial");const o=this.shadow,r=t.shadowMap.type,s=new DepthTexture(o.mapSize.width,o.mapSize.height);s.compareFunction=LessCompare;const d=e.createRenderTarget(o.mapSize.width,o.mapSize.height);if(d.depthTexture=s,o.camera.updateProjectionMatrix(),r===VSMShadowMap){s.compareFunction=null,this.vsmShadowMapVertical=e.createRenderTarget(o.mapSize.width,o.mapSize.height,{format:RGFormat,type:HalfFloatType}),this.vsmShadowMapHorizontal=e.createRenderTarget(o.mapSize.width,o.mapSize.height,{format:RGFormat,type:HalfFloatType});const a=texture(s),t=texture(this.vsmShadowMapVertical.texture),r=reference("blurSamples","float",o).setGroup(renderGroup),d=reference("radius","float",o).setGroup(renderGroup),i=reference("mapSize","vec2",o).setGroup(renderGroup);let n=this.vsmMaterialVertical||(this.vsmMaterialVertical=new NodeMaterial);n.fragmentNode=VSMPassVertical({samples:r,radius:d,size:i,shadowPass:a}).context(e.getSharedContext()),n.name="VSMVertical",n=this.vsmMaterialHorizontal||(this.vsmMaterialHorizontal=new NodeMaterial),n.fragmentNode=VSMPassHorizontal({samples:r,radius:d,size:i,shadowPass:t}).context(e.getSharedContext()),n.name="VSMHorizontal"}const i=reference("intensity","float",o).setGroup(renderGroup),n=reference("bias","float",o).setGroup(renderGroup),l=reference("normalBias","float",o).setGroup(renderGroup),h=a.material.shadowPositionNode||positionWorld;let p,m=uniform(o.matrix).setGroup(renderGroup).mul(h.add(transformedNormalWorld.mul(l)));if(o.camera.isOrthographicCamera||!0!==t.logarithmicDepthBuffer)m=m.xyz.div(m.w),p=m.z,t.coordinateSystem===WebGPUCoordinateSystem&&(p=p.mul(2).sub(1));else{const e=m.w;m=m.xy.div(e);const a=uniform("float").onRenderUpdate((()=>o.camera.near)),t=uniform("float").onRenderUpdate((()=>o.camera.far));p=perspectiveDepthToLogarithmicDepth(e,a,t)}m=vec3(m.x,m.y.oneMinus(),p.add(n));const c=m.x.greaterThanEqual(0).and(m.x.lessThanEqual(1)).and(m.y.greaterThanEqual(0)).and(m.y.lessThanEqual(1)).and(m.z.lessThanEqual(1)),u=o.filterNode||_shadowFilterLib[t.shadowMap.type]||null;if(null===u)throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");const v=texture(d.texture,m),w=c.select(u({depthTexture:r===VSMShadowMap?this.vsmShadowMapHorizontal.texture:s,shadowCoord:m,shadow:o}),float(1));return this.shadowMap=d,this.shadow.map=d,mix(1,w.rgb.mix(v,1),i.mul(v.a))}setup(e){if(!1!==e.renderer.shadowMap.enabled)return null!==this._node?this._node:this._node=this.setupShadow(e)}updateShadow(e){const{shadowMap:a,light:t,shadow:o}=this,{renderer:r,scene:s,camera:d}=e,i=r.shadowMap.type,n=a.depthTexture.version;this._depthVersionCached=n;const l=s.overrideMaterial;s.overrideMaterial=_overrideMaterial,a.setSize(o.mapSize.width,o.mapSize.height),o.updateMatrices(t),o.camera.layers.mask=d.layers.mask;const h=r.getRenderTarget(),p=r.getRenderObjectFunction();r.setRenderObjectFunction(((e,...a)=>{(!0===e.castShadow||e.receiveShadow&&i===VSMShadowMap)&&r.renderObject(e,...a)})),r.setRenderTarget(a),r.render(s,o.camera),r.setRenderObjectFunction(p),!0!==t.isPointLight&&i===VSMShadowMap&&this.vsmPass(r),r.setRenderTarget(h),s.overrideMaterial=l}vsmPass(e){const{shadow:a}=this;this.vsmShadowMapVertical.setSize(a.mapSize.width,a.mapSize.height),this.vsmShadowMapHorizontal.setSize(a.mapSize.width,a.mapSize.height),e.setRenderTarget(this.vsmShadowMapVertical),_quadMesh.material=this.vsmMaterialVertical,_quadMesh.render(e),e.setRenderTarget(this.vsmShadowMapHorizontal),_quadMesh.material=this.vsmMaterialHorizontal,_quadMesh.render(e)}dispose(){this.shadowMap.dispose(),this.shadowMap=null,null!==this.vsmShadowMapVertical&&(this.vsmShadowMapVertical.dispose(),this.vsmShadowMapVertical=null,this.vsmMaterialVertical.dispose(),this.vsmMaterialVertical=null),null!==this.vsmShadowMapHorizontal&&(this.vsmShadowMapHorizontal.dispose(),this.vsmShadowMapHorizontal=null,this.vsmMaterialHorizontal.dispose(),this.vsmMaterialHorizontal=null),this.updateBeforeType=NodeUpdateType.NONE}updateBefore(e){const{shadow:a}=this;(a.needsUpdate||a.autoUpdate)&&(this.updateShadow(e),this.shadowMap.depthTexture.version===this._depthVersionCached&&(a.needsUpdate=!1))}}export default ShadowNode;export const shadow=(e,a)=>nodeObject(new ShadowNode(e,a));
//# sourceMappingURL=/sm/e30180ce03b18b4524eeb5df9c241e1f45bf2071b4c54aa53ae64028ff76c549.map