/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/gpgpu/ComputeNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Node from"../core/Node.js";import{NodeUpdateType}from"../core/constants.js";import{addMethodChaining,nodeObject}from"../tsl/TSLCore.js";class ComputeNode extends Node{static get type(){return"ComputeNode"}constructor(t,e,o=[64]){super("void"),this.isComputeNode=!0,this.computeNode=t,this.count=e,this.workgroupSize=o,this.dispatchCount=0,this.version=1,this.updateBeforeType=NodeUpdateType.OBJECT,this.onInitFunction=null,this.updateDispatchCount()}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}updateDispatchCount(){const{count:t,workgroupSize:e}=this;let o=e[0];for(let t=1;t<e.length;t++)o*=e[t];this.dispatchCount=Math.ceil(t/o)}onInit(t){return this.onInitFunction=t,this}updateBefore({renderer:t}){t.compute(this)}generate(t){const{shaderStage:e}=t;if("compute"===e){const e=this.computeNode.build(t,"void");""!==e&&t.addLineFlowCode(e,this)}}}export default ComputeNode;export const compute=(t,e,o)=>nodeObject(new ComputeNode(nodeObject(t),e,o));addMethodChaining("compute",compute);
//# sourceMappingURL=/sm/87a9ab169f5379c8978bafe8db08026419b457985db49645957ac9d2a610d455.map