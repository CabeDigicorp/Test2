/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/code/FunctionCallNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import TempNode from"../core/TempNode.js";import{addMethodChaining,nodeArray,nodeObject,nodeObjects}from"../tsl/TSLCore.js";class FunctionCallNode extends TempNode{static get type(){return"FunctionCallNode"}constructor(e=null,t={}){super(),this.functionNode=e,this.parameters=t}setParameters(e){return this.parameters=e,this}getParameters(){return this.parameters}getNodeType(e){return this.functionNode.getNodeType(e)}generate(e){const t=[],o=this.functionNode,n=o.getInputs(e),r=this.parameters,s=(t,o)=>{const n=o.type;let r;return r="pointer"===n?"&"+t.build(e):t.build(e,n),r};if(Array.isArray(r))for(let e=0;e<r.length;e++)t.push(s(r[e],n[e]));else for(const e of n){const o=r[e.name];if(void 0===o)throw new Error(`FunctionCallNode: Input '${e.name}' not found in FunctionNode.`);t.push(s(o,e))}return`${o.build(e,"property")}( ${t.join(", ")} )`}}export default FunctionCallNode;export const call=(e,...t)=>(t=t.length>1||t[0]&&!0===t[0].isNode?nodeArray(t):nodeObjects(t[0]),nodeObject(new FunctionCallNode(nodeObject(e),t)));addMethodChaining("call",call);
//# sourceMappingURL=/sm/d856fb4a6ad34f9f0a7fc864ea09307dfeaaf32debbaf454e757378329b6e880.map