/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/core/Node.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{NodeUpdateType}from"./constants.js";import{getNodeChildren,getCacheKey}from"./NodeUtils.js";import{EventDispatcher}from"../../core/EventDispatcher.js";import{MathUtils}from"../../math/MathUtils.js";let _nodeId=0;class Node extends EventDispatcher{static get type(){return"Node"}constructor(e=null){super(),this.nodeType=e,this.updateType=NodeUpdateType.NONE,this.updateBeforeType=NodeUpdateType.NONE,this.updateAfterType=NodeUpdateType.NONE,this.uuid=MathUtils.generateUUID(),this.version=0,this._cacheKey=null,this._cacheKeyVersion=0,this.global=!1,this.isNode=!0,Object.defineProperty(this,"id",{value:_nodeId++})}set needsUpdate(e){!0===e&&this.version++}get type(){return this.constructor.type}onUpdate(e,t){return this.updateType=t,this.update=e.bind(this.getSelf()),this}onFrameUpdate(e){return this.onUpdate(e,NodeUpdateType.FRAME)}onRenderUpdate(e){return this.onUpdate(e,NodeUpdateType.RENDER)}onObjectUpdate(e){return this.onUpdate(e,NodeUpdateType.OBJECT)}onReference(e){return this.updateReference=e.bind(this.getSelf()),this}getSelf(){return this.self||this}updateReference(){return this}isGlobal(){return this.global}*getChildren(){for(const{childNode:e}of getNodeChildren(this))yield e}dispose(){this.dispatchEvent({type:"dispose"})}traverse(e){e(this);for(const t of this.getChildren())t.traverse(e)}getCacheKey(e=!1){return!0!==(e=e||this.version!==this._cacheKeyVersion)&&null!==this._cacheKey||(this._cacheKey=getCacheKey(this,e),this._cacheKeyVersion=this.version),this._cacheKey}getScope(){return this}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getUpdateAfterType(){return this.updateAfterType}getElementType(e){const t=this.getNodeType(e);return e.getElementType(t)}getNodeType(e){const t=e.getNodeProperties(this);return t.outputNode?t.outputNode.getNodeType(e):this.nodeType}getShared(e){const t=this.getHash(e);return e.getNodeFromHash(t)||this}setup(e){const t=e.getNodeProperties(this);let s=0;for(const e of this.getChildren())t["node"+s++]=e;return null}analyze(e){if(1===e.increaseUsage(this)){const t=e.getNodeProperties(this);for(const s of Object.values(t))s&&!0===s.isNode&&s.build(e)}}generate(e,t){const{outputNode:s}=e.getNodeProperties(this);if(s&&!0===s.isNode)return s.build(e,t)}updateBefore(){console.warn("Abstract function.")}updateAfter(){console.warn("Abstract function.")}update(){console.warn("Abstract function.")}build(e,t=null){const s=this.getShared(e);if(this!==s)return s.build(e,t);e.addNode(this),e.addChain(this);let i=null;const o=e.getBuildStage();if("setup"===o){this.updateReference(e);const t=e.getNodeProperties(this);if(!0!==t.initialized){e.stack.nodes.length;t.initialized=!0,t.outputNode=this.setup(e),null!==t.outputNode&&e.stack.nodes.length;for(const s of Object.values(t))s&&!0===s.isNode&&s.build(e)}}else if("analyze"===o)this.analyze(e);else if("generate"===o){if(1===this.generate.length){const s=this.getNodeType(e),o=e.getDataFromNode(this);i=o.snippet,void 0===i?(i=this.generate(e)||"",o.snippet=i):void 0!==o.flowCodes&&void 0!==e.context.nodeBlock&&e.addFlowCodeHierarchy(this,e.context.nodeBlock),i=e.format(i,s,t)}else i=this.generate(e,t)||""}return e.removeChain(this),e.addSequentialNode(this),i}getSerializeChildren(){return getNodeChildren(this)}serialize(e){const t=this.getSerializeChildren(),s={};for(const{property:i,index:o,childNode:n}of t)void 0!==o?(void 0===s[i]&&(s[i]=Number.isInteger(o)?[]:{}),s[i][o]=n.toJSON(e.meta).uuid):s[i]=n.toJSON(e.meta).uuid;Object.keys(s).length>0&&(e.inputNodes=s)}deserialize(e){if(void 0!==e.inputNodes){const t=e.meta.nodes;for(const s in e.inputNodes)if(Array.isArray(e.inputNodes[s])){const i=[];for(const o of e.inputNodes[s])i.push(t[o]);this[s]=i}else if("object"==typeof e.inputNodes[s]){const i={};for(const o in e.inputNodes[s]){const n=e.inputNodes[s][o];i[o]=t[n]}this[s]=i}else{const i=e.inputNodes[s];this[s]=t[i]}}}toJSON(e){const{uuid:t,type:s}=this,i=void 0===e||"string"==typeof e;i&&(e={textures:{},images:{},nodes:{}});let o=e.nodes[t];function n(e){const t=[];for(const s in e){const i=e[s];delete i.metadata,t.push(i)}return t}if(void 0===o&&(o={uuid:t,type:s,meta:e,metadata:{version:4.6,type:"Node",generator:"Node.toJSON"}},!0!==i&&(e.nodes[o.uuid]=o),this.serialize(o),delete o.meta),i){const t=n(e.textures),s=n(e.images),i=n(e.nodes);t.length>0&&(o.textures=t),s.length>0&&(o.images=s),i.length>0&&(o.nodes=i)}return o}}export default Node;
//# sourceMappingURL=/sm/3e598d1da21c16e258a355936691e7370575d6549cb5c132a5ccdd6a9706d578.map