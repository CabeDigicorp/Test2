/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/core/NodeBuilder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import NodeUniform from"./NodeUniform.js";import NodeAttribute from"./NodeAttribute.js";import NodeVarying from"./NodeVarying.js";import NodeVar from"./NodeVar.js";import NodeCode from"./NodeCode.js";import NodeCache from"./NodeCache.js";import ParameterNode from"./ParameterNode.js";import FunctionNode from"../code/FunctionNode.js";import NodeMaterial from"../../materials/nodes/NodeMaterial.js";import{NodeUpdateType,defaultBuildStages,shaderStages}from"./constants.js";import{NumberNodeUniform,Vector2NodeUniform,Vector3NodeUniform,Vector4NodeUniform,ColorNodeUniform,Matrix3NodeUniform,Matrix4NodeUniform}from"../../renderers/common/nodes/NodeUniform.js";import{stack}from"./StackNode.js";import{getCurrentStack,setCurrentStack}from"../tsl/TSLBase.js";import CubeRenderTarget from"../../renderers/common/CubeRenderTarget.js";import ChainMap from"../../renderers/common/ChainMap.js";import PMREMGenerator from"../../renderers/common/extras/PMREMGenerator.js";import BindGroup from"../../renderers/common/BindGroup.js";import{REVISION}from"../../constants.js";import{RenderTarget}from"../../core/RenderTarget.js";import{Color}from"../../math/Color.js";import{Vector2}from"../../math/Vector2.js";import{Vector3}from"../../math/Vector3.js";import{Vector4}from"../../math/Vector4.js";import{Float16BufferAttribute}from"../../core/BufferAttribute.js";import{IntType,UnsignedIntType,LinearFilter,LinearMipmapNearestFilter,NearestMipmapLinearFilter,LinearMipmapLinearFilter}from"../../constants.js";const rendererCache=new WeakMap,typeFromLength=new Map([[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]),typeFromArray=new Map([[Int8Array,"int"],[Int16Array,"int"],[Int32Array,"int"],[Uint8Array,"uint"],[Uint16Array,"uint"],[Uint32Array,"uint"],[Float32Array,"float"]]),toFloat=e=>/e/g.test(e)?String(e).replace(/\+/g,""):(e=Number(e))+(e%1?"":".0");class NodeBuilder{constructor(e,t,r){this.object=e,this.material=e&&e.material||null,this.geometry=e&&e.geometry||null,this.renderer=t,this.parser=r,this.scene=null,this.camera=null,this.nodes=[],this.sequentialNodes=[],this.updateNodes=[],this.updateBeforeNodes=[],this.updateAfterNodes=[],this.hashNodes={},this.monitor=null,this.lightsNode=null,this.environmentNode=null,this.fogNode=null,this.clippingContext=null,this.vertexShader=null,this.fragmentShader=null,this.computeShader=null,this.flowNodes={vertex:[],fragment:[],compute:[]},this.flowCode={vertex:"",fragment:"",compute:""},this.uniforms={vertex:[],fragment:[],compute:[],index:0},this.structs={vertex:[],fragment:[],compute:[],index:0},this.bindings={vertex:{},fragment:{},compute:{}},this.bindingsIndexes={},this.bindGroups=null,this.attributes=[],this.bufferAttributes=[],this.varyings=[],this.codes={},this.vars={},this.flow={code:""},this.chaining=[],this.stack=stack(),this.stacks=[],this.tab="\t",this.currentFunctionNode=null,this.context={material:this.material},this.cache=new NodeCache,this.globalCache=this.cache,this.flowsData=new WeakMap,this.shaderStage=null,this.buildStage=null,this.useComparisonMethod=!1}getBindGroupsCache(){let e=rendererCache.get(this.renderer);return void 0===e&&(e=new ChainMap,rendererCache.set(this.renderer,e)),e}createRenderTarget(e,t,r){return new RenderTarget(e,t,r)}createCubeRenderTarget(e,t){return new CubeRenderTarget(e,t)}createPMREMGenerator(){return new PMREMGenerator(this.renderer)}includes(e){return this.nodes.includes(e)}_getBindGroup(e,t){const r=this.getBindGroupsCache(),o=[];let n,i=!0;for(const e of t)o.push(e),i=i&&!0!==e.groupNode.shared;return i?(n=r.get(o),void 0===n&&(n=new BindGroup(e,o,this.bindingsIndexes[e].group,o),r.set(o,n))):n=new BindGroup(e,o,this.bindingsIndexes[e].group,o),n}getBindGroupArray(e,t){const r=this.bindings[t];let o=r[e];return void 0===o&&(void 0===this.bindingsIndexes[e]&&(this.bindingsIndexes[e]={binding:0,group:Object.keys(this.bindingsIndexes).length}),r[e]=o=[]),o}getBindings(){let e=this.bindGroups;if(null===e){const t={},r=this.bindings;for(const e of shaderStages)for(const o in r[e]){const n=r[e][o];(t[o]||(t[o]=[])).push(...n)}e=[];for(const r in t){const o=t[r],n=this._getBindGroup(r,o);e.push(n)}this.bindGroups=e}return e}sortBindingGroups(){const e=this.getBindings();e.sort(((e,t)=>e.bindings[0].groupNode.order-t.bindings[0].groupNode.order));for(let t=0;t<e.length;t++){const r=e[t];this.bindingsIndexes[r.name].group=t,r.index=t}}setHashNode(e,t){this.hashNodes[t]=e}addNode(e){!1===this.nodes.includes(e)&&(this.nodes.push(e),this.setHashNode(e,e.getHash(this)))}addSequentialNode(e){!1===this.sequentialNodes.includes(e)&&this.sequentialNodes.push(e)}buildUpdateNodes(){for(const e of this.nodes){e.getUpdateType()!==NodeUpdateType.NONE&&this.updateNodes.push(e.getSelf())}for(const e of this.sequentialNodes){const t=e.getUpdateBeforeType(),r=e.getUpdateAfterType();t!==NodeUpdateType.NONE&&this.updateBeforeNodes.push(e.getSelf()),r!==NodeUpdateType.NONE&&this.updateAfterNodes.push(e.getSelf())}}get currentNode(){return this.chaining[this.chaining.length-1]}isFilteredTexture(e){return e.magFilter===LinearFilter||e.magFilter===LinearMipmapNearestFilter||e.magFilter===NearestMipmapLinearFilter||e.magFilter===LinearMipmapLinearFilter||e.minFilter===LinearFilter||e.minFilter===LinearMipmapNearestFilter||e.minFilter===NearestMipmapLinearFilter||e.minFilter===LinearMipmapLinearFilter}addChain(e){this.chaining.push(e)}removeChain(e){if(this.chaining.pop()!==e)throw new Error("NodeBuilder: Invalid node chaining!")}getMethod(e){return e}getNodeFromHash(e){return this.hashNodes[e]}addFlow(e,t){return this.flowNodes[e].push(t),t}setContext(e){this.context=e}getContext(){return this.context}getSharedContext(){return delete{...this.context}.material,this.context}setCache(e){this.cache=e}getCache(){return this.cache}getCacheFromNode(e,t=!0){const r=this.getDataFromNode(e);return void 0===r.cache&&(r.cache=new NodeCache(t?this.getCache():null)),r.cache}isAvailable(){return!1}getVertexIndex(){console.warn("Abstract function.")}getInstanceIndex(){console.warn("Abstract function.")}getDrawIndex(){console.warn("Abstract function.")}getFrontFacing(){console.warn("Abstract function.")}getFragCoord(){console.warn("Abstract function.")}isFlipY(){return!1}increaseUsage(e){const t=this.getDataFromNode(e);return t.usageCount=void 0===t.usageCount?1:t.usageCount+1,t.usageCount}generateTexture(){console.warn("Abstract function.")}generateTextureLod(){console.warn("Abstract function.")}generateConst(e,t=null){if(null===t&&("float"===e||"int"===e||"uint"===e?t=0:"bool"===e?t=!1:"color"===e?t=new Color:"vec2"===e?t=new Vector2:"vec3"===e?t=new Vector3:"vec4"===e&&(t=new Vector4)),"float"===e)return toFloat(t);if("int"===e)return`${Math.round(t)}`;if("uint"===e)return t>=0?`${Math.round(t)}u`:"0u";if("bool"===e)return t?"true":"false";if("color"===e)return`${this.getType("vec3")}( ${toFloat(t.r)}, ${toFloat(t.g)}, ${toFloat(t.b)} )`;const r=this.getTypeLength(e),o=this.getComponentType(e),n=e=>this.generateConst(o,e);if(2===r)return`${this.getType(e)}( ${n(t.x)}, ${n(t.y)} )`;if(3===r)return`${this.getType(e)}( ${n(t.x)}, ${n(t.y)}, ${n(t.z)} )`;if(4===r)return`${this.getType(e)}( ${n(t.x)}, ${n(t.y)}, ${n(t.z)}, ${n(t.w)} )`;if(r>4&&t&&(t.isMatrix3||t.isMatrix4))return`${this.getType(e)}( ${t.elements.map(n).join(", ")} )`;if(r>4)return`${this.getType(e)}()`;throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`)}getType(e){return"color"===e?"vec3":e}hasGeometryAttribute(e){return this.geometry&&void 0!==this.geometry.getAttribute(e)}getAttribute(e,t){const r=this.attributes;for(const t of r)if(t.name===e)return t;const o=new NodeAttribute(e,t);return r.push(o),o}getPropertyName(e){return e.name}isVector(e){return/vec\d/.test(e)}isMatrix(e){return/mat\d/.test(e)}isReference(e){return"void"===e||"property"===e||"sampler"===e||"texture"===e||"cubeTexture"===e||"storageTexture"===e||"depthTexture"===e||"texture3D"===e}needsToWorkingColorSpace(){return!1}getComponentTypeFromTexture(e){const t=e.type;if(e.isDataTexture){if(t===IntType)return"int";if(t===UnsignedIntType)return"uint"}return"float"}getElementType(e){return"mat2"===e?"vec2":"mat3"===e?"vec3":"mat4"===e?"vec4":this.getComponentType(e)}getComponentType(e){if("float"===(e=this.getVectorType(e))||"bool"===e||"int"===e||"uint"===e)return e;const t=/(b|i|u|)(vec|mat)([2-4])/.exec(e);return null===t?null:"b"===t[1]?"bool":"i"===t[1]?"int":"u"===t[1]?"uint":"float"}getVectorType(e){return"color"===e?"vec3":"texture"===e||"cubeTexture"===e||"storageTexture"===e||"texture3D"===e?"vec4":e}getTypeFromLength(e,t="float"){if(1===e)return t;const r=typeFromLength.get(e);return("float"===t?"":t[0])+r}getTypeFromArray(e){return typeFromArray.get(e.constructor)}getTypeFromAttribute(e){let t=e;e.isInterleavedBufferAttribute&&(t=e.data);const r=t.array,o=e.itemSize,n=e.normalized;let i;return e instanceof Float16BufferAttribute||!0===n||(i=this.getTypeFromArray(r)),this.getTypeFromLength(o,i)}getTypeLength(e){const t=this.getVectorType(e),r=/vec([2-4])/.exec(t);return null!==r?Number(r[1]):"float"===t||"bool"===t||"int"===t||"uint"===t?1:!0===/mat2/.test(e)?4:!0===/mat3/.test(e)?9:!0===/mat4/.test(e)?16:0}getVectorFromMatrix(e){return e.replace("mat","vec")}changeComponentType(e,t){return this.getTypeFromLength(this.getTypeLength(e),t)}getIntegerType(e){const t=this.getComponentType(e);return"int"===t||"uint"===t?e:this.changeComponentType(e,"int")}addStack(){return this.stack=stack(this.stack),this.stacks.push(getCurrentStack()||this.stack),setCurrentStack(this.stack),this.stack}removeStack(){const e=this.stack;return this.stack=e.parent,setCurrentStack(this.stacks.pop()),e}getDataFromNode(e,t=this.shaderStage,r=null){let o=(r=null===r?e.isGlobal(this)?this.globalCache:this.cache:r).getData(e);return void 0===o&&(o={},r.setData(e,o)),void 0===o[t]&&(o[t]={}),o[t]}getNodeProperties(e,t="any"){const r=this.getDataFromNode(e,t);return r.properties||(r.properties={outputNode:null})}getBufferAttributeFromNode(e,t){const r=this.getDataFromNode(e);let o=r.bufferAttribute;if(void 0===o){const n=this.uniforms.index++;o=new NodeAttribute("nodeAttribute"+n,t,e),this.bufferAttributes.push(o),r.bufferAttribute=o}return o}getStructTypeFromNode(e,t=this.shaderStage){const r=this.getDataFromNode(e,t);if(void 0===r.structType){const o=this.structs.index++;e.name=`StructType${o}`,this.structs[t].push(e),r.structType=e}return e}getUniformFromNode(e,t,r=this.shaderStage,o=null){const n=this.getDataFromNode(e,r,this.globalCache);let i=n.uniform;if(void 0===i){const s=this.uniforms.index++;i=new NodeUniform(o||"nodeUniform"+s,t,e),this.uniforms[r].push(i),n.uniform=i}return i}getVarFromNode(e,t=null,r=e.getNodeType(this),o=this.shaderStage){const n=this.getDataFromNode(e,o);let i=n.variable;if(void 0===i){const e=this.vars[o]||(this.vars[o]=[]);null===t&&(t="nodeVar"+e.length),i=new NodeVar(t,r),e.push(i),n.variable=i}return i}getVaryingFromNode(e,t=null,r=e.getNodeType(this)){const o=this.getDataFromNode(e,"any");let n=o.varying;if(void 0===n){const e=this.varyings,i=e.length;null===t&&(t="nodeVarying"+i),n=new NodeVarying(t,r),e.push(n),o.varying=n}return n}getCodeFromNode(e,t,r=this.shaderStage){const o=this.getDataFromNode(e);let n=o.code;if(void 0===n){const e=this.codes[r]||(this.codes[r]=[]),i=e.length;n=new NodeCode("nodeCode"+i,t),e.push(n),o.code=n}return n}addFlowCodeHierarchy(e,t){const{flowCodes:r,flowCodeBlock:o}=this.getDataFromNode(e);let n=!0,i=t;for(;i;){if(!0===o.get(i)){n=!1;break}i=this.getDataFromNode(i).parentNodeBlock}if(n)for(const e of r)this.addLineFlowCode(e)}addLineFlowCodeBlock(e,t,r){const o=this.getDataFromNode(e),n=o.flowCodes||(o.flowCodes=[]),i=o.flowCodeBlock||(o.flowCodeBlock=new WeakMap);n.push(t),i.set(r,!0)}addLineFlowCode(e,t=null){return""===e||(null!==t&&this.context.nodeBlock&&this.addLineFlowCodeBlock(t,e,this.context.nodeBlock),e=this.tab+e,/;\s*$/.test(e)||(e+=";\n"),this.flow.code+=e),this}addFlowCode(e){return this.flow.code+=e,this}addFlowTab(){return this.tab+="\t",this}removeFlowTab(){return this.tab=this.tab.slice(0,-1),this}getFlowData(e){return this.flowsData.get(e)}flowNode(e){const t=e.getNodeType(this),r=this.flowChildNode(e,t);return this.flowsData.set(e,r),r}buildFunctionNode(e){const t=new FunctionNode,r=this.currentFunctionNode;return this.currentFunctionNode=t,t.code=this.buildFunctionCode(e),this.currentFunctionNode=r,t}flowShaderNode(e){const t=e.layout,r={[Symbol.iterator](){let e=0;const t=Object.values(this);return{next:()=>({value:t[e],done:e++>=t.length})}}};for(const e of t.inputs)r[e.name]=new ParameterNode(e.type,e.name);e.layout=null;const o=e.call(r),n=this.flowStagesNode(o,t.type);return e.layout=t,n}flowStagesNode(e,t=null){const r=this.flow,o=this.vars,n=this.cache,i=this.buildStage,s=this.stack,a={code:""};this.flow=a,this.vars={},this.cache=new NodeCache,this.stack=stack();for(const r of defaultBuildStages)this.setBuildStage(r),a.result=e.build(this,t);return a.vars=this.getVars(this.shaderStage),this.flow=r,this.vars=o,this.cache=n,this.stack=s,this.setBuildStage(i),a}getFunctionOperator(){return null}flowChildNode(e,t=null){const r=this.flow,o={code:""};return this.flow=o,o.result=e.build(this,t),this.flow=r,o}flowNodeFromShaderStage(e,t,r=null,o=null){const n=this.shaderStage;this.setShaderStage(e);const i=this.flowChildNode(t,r);return null!==o&&(i.code+=`${this.tab+o} = ${i.result};\n`),this.flowCode[e]=this.flowCode[e]+i.code,this.setShaderStage(n),i}getAttributesArray(){return this.attributes.concat(this.bufferAttributes)}getAttributes(){console.warn("Abstract function.")}getVaryings(){console.warn("Abstract function.")}getVar(e,t){return`${this.getType(e)} ${t}`}getVars(e){let t="";const r=this.vars[e];if(void 0!==r)for(const e of r)t+=`${this.getVar(e.type,e.name)}; `;return t}getUniforms(){console.warn("Abstract function.")}getCodes(e){const t=this.codes[e];let r="";if(void 0!==t)for(const e of t)r+=e.code+"\n";return r}getHash(){return this.vertexShader+this.fragmentShader+this.computeShader}setShaderStage(e){this.shaderStage=e}getShaderStage(){return this.shaderStage}setBuildStage(e){this.buildStage=e}getBuildStage(){return this.buildStage}buildCode(){console.warn("Abstract function.")}build(){const{object:e,material:t,renderer:r}=this;if(null!==t){let e=r.library.fromMaterial(t);null===e&&(console.error(`NodeMaterial: Material "${t.type}" is not compatible.`),e=new NodeMaterial),e.build(this)}else this.addFlow("compute",e);for(const e of defaultBuildStages){this.setBuildStage(e),this.context.vertex&&this.context.vertex.isNode&&this.flowNodeFromShaderStage("vertex",this.context.vertex);for(const t of shaderStages){this.setShaderStage(t);const r=this.flowNodes[t];for(const t of r)"generate"===e?this.flowNode(t):t.build(this)}}return this.setBuildStage(null),this.setShaderStage(null),this.buildCode(),this.buildUpdateNodes(),this}getNodeUniform(e,t){if("float"===t||"int"===t||"uint"===t)return new NumberNodeUniform(e);if("vec2"===t||"ivec2"===t||"uvec2"===t)return new Vector2NodeUniform(e);if("vec3"===t||"ivec3"===t||"uvec3"===t)return new Vector3NodeUniform(e);if("vec4"===t||"ivec4"===t||"uvec4"===t)return new Vector4NodeUniform(e);if("color"===t)return new ColorNodeUniform(e);if("mat3"===t)return new Matrix3NodeUniform(e);if("mat4"===t)return new Matrix4NodeUniform(e);throw new Error(`Uniform "${t}" not declared.`)}createNodeMaterial(e="NodeMaterial"){throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${e}() instead.`)}format(e,t,r){if((t=this.getVectorType(t))===(r=this.getVectorType(r))||null===r||this.isReference(r))return e;const o=this.getTypeLength(t),n=this.getTypeLength(r);return 16===o&&9===n?`${this.getType(r)}(${e}[0].xyz, ${e}[1].xyz, ${e}[2].xyz)`:9===o&&4===n?`${this.getType(r)}(${e}[0].xy, ${e}[1].xy)`:o>4||n>4||0===n?e:o===n?`${this.getType(r)}( ${e} )`:o>n?this.format(`${e}.${"xyz".slice(0,n)}`,this.getTypeFromLength(n,this.getComponentType(t)),r):4===n&&o>1?`${this.getType(r)}( ${this.format(e,t,"vec3")}, 1.0 )`:2===o?`${this.getType(r)}( ${this.format(e,t,"vec2")}, 0.0 )`:(1===o&&n>1&&t!==this.getComponentType(r)&&(e=`${this.getType(this.getComponentType(r))}( ${e} )`),`${this.getType(r)}( ${e} )`)}getSignature(){return`// Three.js r${REVISION} - Node System\n`}}export default NodeBuilder;
//# sourceMappingURL=/sm/3d8784af1517b44e851abd667fb7e702485fea9aa47634e2c1df8711e6aa3a18.map