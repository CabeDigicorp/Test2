/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.169.0/src/nodes/display/AnamorphicNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import TempNode from"../core/TempNode.js";import{nodeObject,Fn,float,vec2,vec3}from"../tsl/TSLBase.js";import{Loop}from"../utils/LoopNode.js";import{uniform}from"../core/UniformNode.js";import{NodeUpdateType}from"../core/constants.js";import{threshold}from"./ColorAdjustment.js";import{uv}from"../accessors/UV.js";import{passTexture}from"./PassNode.js";import{convertToTexture}from"../utils/RTTNode.js";import QuadMesh from"../../renderers/common/QuadMesh.js";import NodeMaterial from"../../materials/nodes/NodeMaterial.js";import{Vector2}from"../../math/Vector2.js";import{RenderTarget}from"../../core/RenderTarget.js";const _quadMesh=new QuadMesh;class AnamorphicNode extends TempNode{static get type(){return"AnamorphicNode"}constructor(e,t,r,o){super("vec4"),this.textureNode=e,this.tresholdNode=t,this.scaleNode=r,this.colorNode=vec3(.1,0,1),this.samples=o,this.resolution=new Vector2(1,1),this._renderTarget=new RenderTarget,this._renderTarget.texture.name="anamorphic",this._invSize=uniform(new Vector2),this._textureNode=passTexture(this,this._renderTarget.texture),this.updateBeforeType=NodeUpdateType.RENDER}getTextureNode(){return this._textureNode}setSize(e,t){this._invSize.value.set(1/e,1/t),e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._renderTarget.setSize(e,t)}updateBefore(e){const{renderer:t}=e,r=this.textureNode,o=r.value;this._renderTarget.texture.type=o.type;const s=t.getRenderTarget(),i=r.value;_quadMesh.material=this._material,this.setSize(o.image.width,o.image.height),t.setRenderTarget(this._renderTarget),_quadMesh.render(t),t.setRenderTarget(s),r.value=i}setup(e){const t=this.textureNode,r=t.uvNode||uv(),o=Fn((()=>{const e=this.samples,o=Math.floor(e/2),s=vec3(0).toVar();return Loop({start:-o,end:o},(({i:e})=>{const i=float(e).abs().div(o).oneMinus(),a=(e=>t.uv(e))(vec2(r.x.add(this._invSize.x.mul(e).mul(this.scaleNode)),r.y)),d=threshold(a,this.tresholdNode).mul(i);s.addAssign(d)})),s.mul(this.colorNode)})),s=this._material||(this._material=new NodeMaterial);s.name="Anamorphic",s.fragmentNode=o();return e.getNodeProperties(this).textureNode=t,this._textureNode}dispose(){this._renderTarget.dispose()}}export const anamorphic=(e,t=.9,r=3,o=32)=>nodeObject(new AnamorphicNode(convertToTexture(e),nodeObject(t),nodeObject(r),o));export default AnamorphicNode;
//# sourceMappingURL=/sm/8415c57f0c9b86e9830ccd7455e3721934dc1ea91f1d167b2772b596d02e2f60.map