/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.169.0/src/nodes/display/GaussianBlurNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import TempNode from"../core/TempNode.js";import{nodeObject,Fn,float,vec2,vec4}from"../tsl/TSLBase.js";import{NodeUpdateType}from"../core/constants.js";import{mul}from"../math/OperatorNode.js";import{uv}from"../accessors/UV.js";import{passTexture}from"./PassNode.js";import{uniform}from"../core/UniformNode.js";import{convertToTexture}from"../utils/RTTNode.js";import QuadMesh from"../../renderers/common/QuadMesh.js";import{Vector2}from"../../math/Vector2.js";import{RenderTarget}from"../../core/RenderTarget.js";import NodeMaterial from"../../materials/nodes/NodeMaterial.js";const _quadMesh1=new QuadMesh,_quadMesh2=new QuadMesh;class GaussianBlurNode extends TempNode{static get type(){return"GaussianBlurNode"}constructor(e,t=null,r=2){super("vec4"),this.textureNode=e,this.directionNode=t,this.sigma=r,this._invSize=uniform(new Vector2),this._passDirection=uniform(new Vector2),this._horizontalRT=new RenderTarget,this._horizontalRT.texture.name="GaussianBlurNode.horizontal",this._verticalRT=new RenderTarget,this._verticalRT.texture.name="GaussianBlurNode.vertical",this._textureNode=passTexture(this,this._verticalRT.texture),this.updateBeforeType=NodeUpdateType.RENDER,this.resolution=new Vector2(1,1)}setSize(e,t){e=Math.max(Math.round(e*this.resolution.x),1),t=Math.max(Math.round(t*this.resolution.y),1),this._invSize.value.set(1/e,1/t),this._horizontalRT.setSize(e,t),this._verticalRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e,r=this.textureNode,s=r.value,o=t.getRenderTarget(),i=t.getMRT(),a=r.value;_quadMesh1.material=this._material,_quadMesh2.material=this._material,this.setSize(s.image.width,s.image.height);const n=s.type;this._horizontalRT.texture.type=n,this._verticalRT.texture.type=n,t.setMRT(null),t.setRenderTarget(this._horizontalRT),this._passDirection.value.set(1,0),_quadMesh1.render(t),r.value=this._horizontalRT.texture,t.setRenderTarget(this._verticalRT),this._passDirection.value.set(0,1),_quadMesh2.render(t),t.setRenderTarget(o),t.setMRT(i),r.value=a}getTextureNode(){return this._textureNode}setup(e){const t=this.textureNode;if(!0!==t.isTextureNode)return console.error("GaussianBlurNode requires a TextureNode."),vec4();const r=t.uvNode||uv(),s=vec2(this.directionNode||1),o=e=>t.uv(e),i=Fn((()=>{const e=3+2*this.sigma,t=this._getCoefficients(e),i=this._invSize,a=s.mul(this._passDirection),n=float(t[0]).toVar(),u=vec4(o(r).mul(n)).toVar();for(let s=1;s<e;s++){const e=float(s),d=float(t[s]),h=vec2(a.mul(i.mul(e))).toVar(),l=vec4(o(r.add(h))),m=vec4(o(r.sub(h)));u.addAssign(l.add(m).mul(d)),n.addAssign(mul(2,d))}return u.div(n)})),a=this._material||(this._material=new NodeMaterial);a.fragmentNode=i().context(e.getSharedContext()),a.name="Gaussian_blur",a.needsUpdate=!0;return e.getNodeProperties(this).textureNode=t,this._textureNode}dispose(){this._horizontalRT.dispose(),this._verticalRT.dispose()}_getCoefficients(e){const t=[];for(let r=0;r<e;r++)t.push(.39894*Math.exp(-.5*r*r/(e*e))/e);return t}}export default GaussianBlurNode;export const gaussianBlur=(e,t,r)=>nodeObject(new GaussianBlurNode(convertToTexture(e),t,r));
//# sourceMappingURL=/sm/e51c5f24d03fb2887368f04f787050eb77a0993efed0f2e3eacbcb6d1ac6e959.map