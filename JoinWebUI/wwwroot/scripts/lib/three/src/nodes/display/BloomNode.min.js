/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.169.0/src/nodes/display/BloomNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import TempNode from"../core/TempNode.js";import{Fn,nodeObject,float,vec4,int}from"../tsl/TSLBase.js";import{mix,smoothstep}from"../math/MathNode.js";import{luminance}from"./ColorAdjustment.js";import{uniform}from"../core/UniformNode.js";import{uniformArray}from"../accessors/UniformArrayNode.js";import{uv}from"../accessors/UV.js";import{Color}from"../../math/Color.js";import{passTexture}from"./PassNode.js";import{RenderTarget}from"../../core/RenderTarget.js";import{HalfFloatType}from"../../constants.js";import{NodeUpdateType}from"../core/constants.js";import{Vector2}from"../../math/Vector2.js";import{Loop}from"../utils/LoopNode.js";import{add}from"../math/OperatorNode.js";import QuadMesh from"../../renderers/common/QuadMesh.js";import{texture}from"../accessors/TextureNode.js";import{Vector3}from"../../math/Vector3.js";import NodeMaterial from"../../materials/nodes/NodeMaterial.js";const _quadMesh=new QuadMesh,_clearColor=new Color(0,0,0),_currentClearColor=new Color,_size=new Vector2,_BlurDirectionX=new Vector2(1,0),_BlurDirectionY=new Vector2(0,1);class BloomNode extends TempNode{static get type(){return"BloomNode"}constructor(e,t=1,r=0,s=0){super(),this.inputNode=e,this.strength=uniform(t),this.radius=uniform(r),this.threshold=uniform(s),this.smoothWidth=uniform(.01),this._renderTargetsHorizontal=[],this._renderTargetsVertical=[],this._nMips=5,this._renderTargetBright=new RenderTarget(1,1,{type:HalfFloatType}),this._renderTargetBright.texture.name="UnrealBloomPass.bright",this._renderTargetBright.texture.generateMipmaps=!1;for(let e=0;e<this._nMips;e++){const t=new RenderTarget(1,1,{type:HalfFloatType});t.texture.name="UnrealBloomPass.h"+e,t.texture.generateMipmaps=!1,this._renderTargetsHorizontal.push(t);const r=new RenderTarget(1,1,{type:HalfFloatType});r.texture.name="UnrealBloomPass.v"+e,r.texture.generateMipmaps=!1,this._renderTargetsVertical.push(r)}this._compositeMaterial=null,this._highPassFilterMaterial=null,this._separableBlurMaterials=[],this._textureNodeBright=texture(this._renderTargetBright.texture),this._textureNodeBlur0=texture(this._renderTargetsVertical[0].texture),this._textureNodeBlur1=texture(this._renderTargetsVertical[1].texture),this._textureNodeBlur2=texture(this._renderTargetsVertical[2].texture),this._textureNodeBlur3=texture(this._renderTargetsVertical[3].texture),this._textureNodeBlur4=texture(this._renderTargetsVertical[4].texture),this._textureOutput=passTexture(this,this._renderTargetsHorizontal[0].texture),this.updateBeforeType=NodeUpdateType.FRAME}getTextureNode(){return this._textureOutput}setSize(e,t){let r=Math.round(e/2),s=Math.round(t/2);this._renderTargetBright.setSize(r,s);for(let e=0;e<this._nMips;e++)this._renderTargetsHorizontal[e].setSize(r,s),this._renderTargetsVertical[e].setSize(r,s),this._separableBlurMaterials[e].invSize.value.set(1/r,1/s),r=Math.round(r/2),s=Math.round(s/2)}updateBefore(e){const{renderer:t}=e,r=t.getDrawingBufferSize(_size);this.setSize(r.width,r.height);const s=t.getRenderTarget(),o=t.getMRT();t.getClearColor(_currentClearColor);const a=t.getClearAlpha();this.setSize(r.width,r.height),t.setMRT(null),t.setClearColor(_clearColor,0),t.setRenderTarget(this._renderTargetBright),_quadMesh.material=this._highPassFilterMaterial,_quadMesh.render(t);let i=this._renderTargetBright;for(let e=0;e<this._nMips;e++)_quadMesh.material=this._separableBlurMaterials[e],this._separableBlurMaterials[e].colorTexture.value=i.texture,this._separableBlurMaterials[e].direction.value=_BlurDirectionX,t.setRenderTarget(this._renderTargetsHorizontal[e]),t.clear(),_quadMesh.render(t),this._separableBlurMaterials[e].colorTexture.value=this._renderTargetsHorizontal[e].texture,this._separableBlurMaterials[e].direction.value=_BlurDirectionY,t.setRenderTarget(this._renderTargetsVertical[e]),t.clear(),_quadMesh.render(t),i=this._renderTargetsVertical[e];t.setRenderTarget(this._renderTargetsHorizontal[0]),t.clear(),_quadMesh.material=this._compositeMaterial,_quadMesh.render(t),t.setRenderTarget(s),t.setMRT(o),t.setClearColor(_currentClearColor,a)}setup(e){const t=Fn((()=>{const e=this.inputNode,t=luminance(e.rgb),r=smoothstep(this.threshold,this.threshold.add(this.smoothWidth),t);return mix(vec4(0),e,r)}));this._highPassFilterMaterial=this._highPassFilterMaterial||new NodeMaterial,this._highPassFilterMaterial.fragmentNode=t().context(e.getSharedContext()),this._highPassFilterMaterial.name="Bloom_highPass",this._highPassFilterMaterial.needsUpdate=!0;const r=[3,5,7,9,11];for(let t=0;t<this._nMips;t++)this._separableBlurMaterials.push(this._getSeperableBlurMaterial(e,r[t]));const s=uniformArray([1,.8,.6,.4,.2]),o=uniformArray([new Vector3(1,1,1),new Vector3(1,1,1),new Vector3(1,1,1),new Vector3(1,1,1),new Vector3(1,1,1)]),a=Fn((([e,t])=>{const r=float(1.2).sub(e);return mix(e,r,t)})).setLayout({name:"lerpBloomFactor",type:"float",inputs:[{name:"factor",type:"float"},{name:"radius",type:"float"}]}),i=Fn((()=>{const e=a(s.element(0),this.radius).mul(vec4(o.element(0),1)).mul(this._textureNodeBlur0),t=a(s.element(1),this.radius).mul(vec4(o.element(1),1)).mul(this._textureNodeBlur1),r=a(s.element(2),this.radius).mul(vec4(o.element(2),1)).mul(this._textureNodeBlur2),i=a(s.element(3),this.radius).mul(vec4(o.element(3),1)).mul(this._textureNodeBlur3),l=a(s.element(4),this.radius).mul(vec4(o.element(4),1)).mul(this._textureNodeBlur4);return e.add(t).add(r).add(i).add(l).mul(this.strength)}));return this._compositeMaterial=this._compositeMaterial||new NodeMaterial,this._compositeMaterial.fragmentNode=i().context(e.getSharedContext()),this._compositeMaterial.name="Bloom_comp",this._compositeMaterial.needsUpdate=!0,this._textureOutput}dispose(){for(let e=0;e<this._renderTargetsHorizontal.length;e++)this._renderTargetsHorizontal[e].dispose();for(let e=0;e<this._renderTargetsVertical.length;e++)this._renderTargetsVertical[e].dispose();this._renderTargetBright.dispose()}_getSeperableBlurMaterial(e,t){const r=[];for(let e=0;e<t;e++)r.push(.39894*Math.exp(-.5*e*e/(t*t))/t);const s=texture(),o=uniformArray(r),a=uniform(new Vector2),i=uniform(new Vector2(.5,.5)),l=uv(),n=e=>s.uv(e),h=Fn((()=>{const e=o.element(0).toVar(),r=n(l).rgb.mul(e).toVar();return Loop({start:int(1),end:int(t),type:"int",condition:"<"},(({i:t})=>{const s=float(t),h=o.element(t),u=i.mul(a).mul(s),d=n(l.add(u)).rgb,m=n(l.sub(u)).rgb;r.addAssign(add(d,m).mul(h)),e.addAssign(float(2).mul(h))})),vec4(r.div(e),1)})),u=new NodeMaterial;return u.fragmentNode=h().context(e.getSharedContext()),u.name="Bloom_seperable",u.needsUpdate=!0,u.colorTexture=s,u.direction=i,u.invSize=a,u}}export const bloom=(e,t,r,s)=>nodeObject(new BloomNode(nodeObject(e),t,r,s));export default BloomNode;
//# sourceMappingURL=/sm/4a8b80b3f00fb2d189138ebf5e582de1700fa3df37495d32f9fdaf978dd506c9.map