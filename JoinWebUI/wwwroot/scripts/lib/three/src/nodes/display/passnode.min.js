/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/display/PassNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import TempNode from"../core/TempNode.js";import{default as TextureNode}from"../accessors/TextureNode.js";import{NodeUpdateType}from"../core/constants.js";import{nodeObject}from"../tsl/TSLBase.js";import{uniform}from"../core/UniformNode.js";import{viewZToOrthographicDepth,perspectiveDepthToViewZ}from"./ViewportDepthNode.js";import{HalfFloatType}from"../../constants.js";import{Vector2}from"../../math/Vector2.js";import{DepthTexture}from"../../textures/DepthTexture.js";import{RenderTarget}from"../../core/RenderTarget.js";const _size=new Vector2;class PassTextureNode extends TextureNode{static get type(){return"PassTextureNode"}constructor(e,t){super(t),this.passNode=e,this.setUpdateMatrix(!1)}setup(e){return e.object.isQuadMesh&&this.passNode.build(e),super.setup(e)}clone(){return new this.constructor(this.passNode,this.value)}}class PassMultipleTextureNode extends PassTextureNode{static get type(){return"PassMultipleTextureNode"}constructor(e,t,s=!1){super(e,null),this.textureName=t,this.previousTexture=s}updateTexture(){this.value=this.previousTexture?this.passNode.getPreviousTexture(this.textureName):this.passNode.getTexture(this.textureName)}setup(e){return this.updateTexture(),super.setup(e)}clone(){return new this.constructor(this.passNode,this.textureName,this.previousTexture)}}class PassNode extends TempNode{static get type(){return"PassNode"}constructor(e,t,s,r={}){super("vec4"),this.scope=e,this.scene=t,this.camera=s,this.options=r,this._pixelRatio=1,this._width=1,this._height=1;const i=new DepthTexture;i.isRenderTargetTexture=!0,i.name="depth";const o=new RenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:HalfFloatType,...r});o.texture.name="output",o.depthTexture=i,this.renderTarget=o,this.updateBeforeType=NodeUpdateType.FRAME,this._textures={output:o.texture,depth:i},this._textureNodes={},this._linearDepthNodes={},this._viewZNodes={},this._previousTextures={},this._previousTextureNodes={},this._cameraNear=uniform(0),this._cameraFar=uniform(0),this._mrt=null,this.isPassNode=!0}setMRT(e){return this._mrt=e,this}getMRT(){return this._mrt}isGlobal(){return!0}getTexture(e){let t=this._textures[e];if(void 0===t){t=this.renderTarget.texture.clone(),t.isRenderTargetTexture=!0,t.name=e,this._textures[e]=t,this.renderTarget.textures.push(t)}return t}getPreviousTexture(e){let t=this._previousTextures[e];return void 0===t&&(t=this.getTexture(e).clone(),t.isRenderTargetTexture=!0,this._previousTextures[e]=t),t}toggleTexture(e){const t=this._previousTextures[e];if(void 0!==t){const s=this._textures[e],r=this.renderTarget.textures.indexOf(s);this.renderTarget.textures[r]=t,this._textures[e]=t,this._previousTextures[e]=s,this._textureNodes[e].updateTexture(),this._previousTextureNodes[e].updateTexture()}}getTextureNode(e="output"){let t=this._textureNodes[e];return void 0===t&&(t=nodeObject(new PassMultipleTextureNode(this,e)),t.updateTexture(),this._textureNodes[e]=t),t}getPreviousTextureNode(e="output"){let t=this._previousTextureNodes[e];return void 0===t&&(void 0===this._textureNodes[e]&&this.getTextureNode(e),t=nodeObject(new PassMultipleTextureNode(this,e,!0)),t.updateTexture(),this._previousTextureNodes[e]=t),t}getViewZNode(e="depth"){let t=this._viewZNodes[e];if(void 0===t){const s=this._cameraNear,r=this._cameraFar;this._viewZNodes[e]=t=perspectiveDepthToViewZ(this.getTextureNode(e),s,r)}return t}getLinearDepthNode(e="depth"){let t=this._linearDepthNodes[e];if(void 0===t){const s=this._cameraNear,r=this._cameraFar,i=this.getViewZNode(e);this._linearDepthNodes[e]=t=viewZToOrthographicDepth(i,s,r)}return t}setup({renderer:e}){return this.renderTarget.samples=void 0===this.options.samples?e.samples:this.options.samples,!0===e.backend.isWebGLBackend&&(this.renderTarget.samples=0),this.renderTarget.depthTexture.isMultisampleRenderTargetTexture=this.renderTarget.samples>1,this.scope===PassNode.COLOR?this.getTextureNode():this.getLinearDepthNode()}updateBefore(e){const{renderer:t}=e,{scene:s,camera:r}=this;this._pixelRatio=t.getPixelRatio();const i=t.getSize(_size);this.setSize(i.width,i.height);const o=t.getRenderTarget(),u=t.getMRT();this._cameraNear.value=r.near,this._cameraFar.value=r.far;for(const e in this._previousTextures)this.toggleTexture(e);t.setRenderTarget(this.renderTarget),t.setMRT(this._mrt),t.render(s,r),t.setRenderTarget(o),t.setMRT(u)}setSize(e,t){this._width=e,this._height=t;const s=this._width*this._pixelRatio,r=this._height*this._pixelRatio;this.renderTarget.setSize(s,r)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}PassNode.COLOR="color",PassNode.DEPTH="depth";export default PassNode;export const pass=(e,t,s)=>nodeObject(new PassNode(PassNode.COLOR,e,t,s));export const passTexture=(e,t)=>nodeObject(new PassTextureNode(e,t));export const depthPass=(e,t)=>nodeObject(new PassNode(PassNode.DEPTH,e,t));
//# sourceMappingURL=/sm/e6f1d282fe098620306c92e799a3a5d8495107cae8d8b05d10a200b0817e7867.map