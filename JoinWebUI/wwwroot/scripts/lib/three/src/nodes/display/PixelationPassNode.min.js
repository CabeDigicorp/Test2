/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.169.0/src/nodes/display/PixelationPassNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import TempNode from"../core/TempNode.js";import{uv}from"../accessors/UV.js";import{Fn,nodeObject,vec2,vec3,float,If}from"../tsl/TSLBase.js";import{NodeUpdateType}from"../core/constants.js";import{uniform}from"../core/UniformNode.js";import{dot,clamp,smoothstep,sign,step,floor}from"../math/MathNode.js";import{Vector4}from"../../math/Vector4.js";import{output,property}from"../core/PropertyNode.js";import PassNode from"./PassNode.js";import{mrt}from"../core/MRTNode.js";import{normalView}from"../accessors/Normal.js";import{convertToTexture}from"../utils/RTTNode.js";import{NearestFilter}from"../../constants.js";class PixelationNode extends TempNode{static get type(){return"PixelationNode"}constructor(e,t,o,r,s,i){super(),this.textureNode=e,this.depthNode=t,this.normalNode=o,this.pixelSize=r,this.normalEdgeStrength=s,this.depthEdgeStrength=i,this._resolution=uniform(new Vector4),this.updateBeforeType=NodeUpdateType.RENDER}updateBefore(){const e=this.textureNode.value,t=e.image.width,o=e.image.height;this._resolution.value.set(t,o,1/t,1/o)}setup(){const{textureNode:e,depthNode:t,normalNode:o}=this,r=e.uvNode||uv(),s=t.uvNode||uv(),i=o.uvNode||uv(),n=(e,o)=>t.uv(s.add(vec2(e,o).mul(this._resolution.zw))).r,a=(e,t)=>o.uv(i.add(vec2(e,t).mul(this._resolution.zw))).rgb.normalize(),d=(e,t,o,r)=>{const s=n(e,t).sub(o),i=a(e,t),d=vec3(1,1,1),p=dot(r.sub(i),d),l=clamp(smoothstep(-.01,.01,p),0,1),u=clamp(sign(s.mul(.25).add(.0025)),0,1);return float(1).sub(dot(r,i)).mul(u).mul(l)};return Fn((()=>{const t=e.uv(r),o=property("float","depth"),s=property("vec3","normal");If(this.depthEdgeStrength.greaterThan(0).or(this.normalEdgeStrength.greaterThan(0)),(()=>{o.assign(n(0,0)),s.assign(a(0,0))}));const i=property("float","dei");If(this.depthEdgeStrength.greaterThan(0),(()=>{i.assign((e=>{const t=property("float","diff");return t.addAssign(clamp(n(1,0).sub(e))),t.addAssign(clamp(n(-1,0).sub(e))),t.addAssign(clamp(n(0,1).sub(e))),t.addAssign(clamp(n(0,-1).sub(e))),floor(smoothstep(.01,.02,t).mul(2)).div(2)})(o))}));const p=property("float","nei");If(this.normalEdgeStrength.greaterThan(0),(()=>{p.assign(((e,t)=>{const o=property("float","indicator");return o.addAssign(d(0,-1,e,t)),o.addAssign(d(0,1,e,t)),o.addAssign(d(-1,0,e,t)),o.addAssign(d(1,0,e,t)),step(.1,o)})(o,s))}));const l=i.greaterThan(0).select(float(1).sub(i.mul(this.depthEdgeStrength)),p.mul(this.normalEdgeStrength).add(1));return t.mul(l)}))()}}const pixelation=(e,t,o,r=6,s=.3,i=.4)=>nodeObject(new PixelationNode(convertToTexture(e),convertToTexture(t),convertToTexture(o),nodeObject(r),nodeObject(s),nodeObject(i)));class PixelationPassNode extends PassNode{static get type(){return"PixelationPassNode"}constructor(e,t,o=6,r=.3,s=.4){super("color",e,t,{minFilter:NearestFilter,magFilter:NearestFilter}),this.pixelSize=o,this.normalEdgeStrength=r,this.depthEdgeStrength=s,this.isPixelationPassNode=!0,this._mrt=mrt({output:output,normal:normalView})}setSize(e,t){const o=this.pixelSize.value?this.pixelSize.value:this.pixelSize,r=Math.floor(e/o),s=Math.floor(t/o);super.setSize(r,s)}setup(){const e=super.getTextureNode("output"),t=super.getTextureNode("depth"),o=super.getTextureNode("normal");return pixelation(e,t,o,this.pixelSize,this.normalEdgeStrength,this.depthEdgeStrength)}}export const pixelationPass=(e,t,o,r,s)=>nodeObject(new PixelationPassNode(e,t,o,r,s));export default PixelationPassNode;
//# sourceMappingURL=/sm/55ac272e5e70fe6dcb7386f84e7afceeeaa8a08f028c6745eb6a0a3a10b23ed9.map