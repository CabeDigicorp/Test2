/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.169.0/src/nodes/display/DenoiseNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import TempNode from"../core/TempNode.js";import{uv}from"../accessors/UV.js";import{Fn,nodeObject,float,int,vec2,vec3,vec4,mat2,If}from"../tsl/TSLBase.js";import{NodeUpdateType}from"../core/constants.js";import{uniform}from"../core/UniformNode.js";import{uniformArray}from"../accessors/UniformArrayNode.js";import{abs,dot,sin,cos,PI,pow,max}from"../math/MathNode.js";import{Loop}from"../utils/LoopNode.js";import{luminance}from"./ColorAdjustment.js";import{textureSize}from"../accessors/TextureSizeNode.js";import{convertToTexture}from"../utils/RTTNode.js";import{Vector2}from"../../math/Vector2.js";import{Vector3}from"../../math/Vector3.js";class DenoiseNode extends TempNode{static get type(){return"DenoiseNode"}constructor(e,t,o,r,i){super(),this.textureNode=e,this.depthNode=t,this.normalNode=o,this.noiseNode=r,this.cameraProjectionMatrixInverse=uniform(i.projectionMatrixInverse),this.lumaPhi=uniform(5),this.depthPhi=uniform(5),this.normalPhi=uniform(5),this.radius=uniform(5),this.index=uniform(0),this._resolution=uniform(new Vector2),this._sampleVectors=uniformArray(generatePdSamplePointInitializer(16,2,1)),this.updateBeforeType=NodeUpdateType.RENDER}updateBefore(){const e=this.textureNode.value;this._resolution.value.set(e.image.width,e.image.height)}setup(){const e=uv(),t=e=>this.textureNode.uv(e),o=e=>this.depthNode.uv(e).x,r=e=>this.normalNode.uv(e),i=e=>this.noiseNode.uv(e),s=Fn((([e,t])=>{e=vec2(e.x,e.y.oneMinus()).mul(2).sub(1);const o=vec4(vec3(e,t),1),r=vec4(this.cameraProjectionMatrixInverse.mul(o));return r.xyz.div(r.w)})),n=Fn((([e,i,n,a])=>{const m=t(a),u=o(a),d=r(a).rgb.normalize(),c=m.rgb,l=s(a,u),h=dot(i,d).toVar(),p=pow(max(h,0),this.normalPhi).toVar(),f=abs(luminance(c).sub(luminance(e))).toVar(),v=max(float(1).sub(f.div(this.lumaPhi)),0).toVar(),x=abs(dot(n.sub(l),i)).toVar(),N=max(float(1).sub(x.div(this.depthPhi)),0),j=v.mul(N).mul(p);return vec4(c.mul(j),j)})),a=Fn((([e])=>{const a=o(e),m=r(e).rgb.normalize(),u=t(e);If(a.greaterThanEqual(1).or(dot(m,m).equal(0)),(()=>u));const d=vec3(u.rgb),c=s(e,a),l=textureSize(this.noiseNode,0);let h=vec2(e.x,e.y.oneMinus());h=h.mul(this._resolution.div(l));const p=i(h),f=sin(p.element(this.index.mod(4).mul(2).mul(PI))),v=cos(p.element(this.index.mod(4).mul(2).mul(PI))),x=vec2(f,v),N=mat2(x.x,x.y.negate(),x.x,x.y),j=float(1).toVar(),b=vec3(u.rgb).toVar();return Loop({start:int(0),end:int(16),type:"int",condition:"<"},(({i:t})=>{const o=this._sampleVectors.element(t).toVar(),r=N.mul(o.xy.mul(float(1).add(o.z.mul(this.radius.sub(1))))).div(this._resolution).toVar(),i=e.add(r).toVar(),s=n(d,m,c,i);b.addAssign(s.xyz),j.addAssign(s.w)})),If(j.greaterThan(float(0)),(()=>{b.divAssign(j)})),vec4(b,u.a)})).setLayout({name:"denoise",type:"vec4",inputs:[{name:"uv",type:"vec2"}]});return Fn((()=>a(e)))()}}export default DenoiseNode;function generatePdSamplePointInitializer(e,t,o){const r=generateDenoiseSamples(e,t,o),i=[];for(let t=0;t<e;t++){const e=r[t];i.push(e)}return i}function generateDenoiseSamples(e,t,o){const r=[];for(let i=0;i<e;i++){const s=2*Math.PI*t*i/e,n=Math.pow(i/(e-1),o);r.push(new Vector3(Math.cos(s),Math.sin(s),n))}return r}export const denoise=(e,t,o,r,i)=>nodeObject(new DenoiseNode(convertToTexture(e),nodeObject(t),nodeObject(o),nodeObject(r),i));
//# sourceMappingURL=/sm/1070e86877333d71612e64651f4e26150a27288e592ab5187111b3de8cbafe5a.map