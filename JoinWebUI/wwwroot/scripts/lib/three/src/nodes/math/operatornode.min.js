/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/math/OperatorNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import TempNode from"../core/TempNode.js";import{addMethodChaining,nodeProxy}from"../tsl/TSLCore.js";class OperatorNode extends TempNode{static get type(){return"OperatorNode"}constructor(e,o,t,...r){if(super(),r.length>0){let d=new OperatorNode(e,o,t);for(let o=0;o<r.length-1;o++)d=new OperatorNode(e,d,r[o]);o=d,t=r[r.length-1]}this.op=e,this.aNode=o,this.bNode=t}getNodeType(e,o){const t=this.op,r=this.aNode,d=this.bNode,n=r.getNodeType(e),a=void 0!==d?d.getNodeType(e):null;if("void"===n||"void"===a)return"void";if("%"===t)return n;if("~"===t||"&"===t||"|"===t||"^"===t||">>"===t||"<<"===t)return e.getIntegerType(n);if("!"===t||"=="===t||"&&"===t||"||"===t||"^^"===t)return"bool";if("<"===t||">"===t||"<="===t||">="===t){const t=o?e.getTypeLength(o):Math.max(e.getTypeLength(n),e.getTypeLength(a));return t>1?`bvec${t}`:"bool"}return"float"===n&&e.isMatrix(a)?a:e.isMatrix(n)&&e.isVector(a)?e.getVectorFromMatrix(n):e.isVector(n)&&e.isMatrix(a)?e.getVectorFromMatrix(a):e.getTypeLength(a)>e.getTypeLength(n)?a:n}generate(e,o){const t=this.op,r=this.aNode,d=this.bNode,n=this.getNodeType(e,o);let a=null,i=null;"void"!==n?(a=r.getNodeType(e),i=void 0!==d?d.getNodeType(e):null,"<"===t||">"===t||"<="===t||">="===t||"=="===t?e.isVector(a)?i=a:a!==i&&(a=i="float"):">>"===t||"<<"===t?(a=n,i=e.changeComponentType(i,"uint")):e.isMatrix(a)&&e.isVector(i)?i=e.getVectorFromMatrix(a):a=e.isVector(a)&&e.isMatrix(i)?e.getVectorFromMatrix(i):i=n):a=i=n;const h=r.build(e,a),s=void 0!==d?d.build(e,i):null,p=e.getTypeLength(o),g=e.getFunctionOperator(t);return"void"!==o?"<"===t&&p>1?e.useComparisonMethod?e.format(`${e.getMethod("lessThan",o)}( ${h}, ${s} )`,n,o):e.format(`( ${h} < ${s} )`,n,o):"<="===t&&p>1?e.useComparisonMethod?e.format(`${e.getMethod("lessThanEqual",o)}( ${h}, ${s} )`,n,o):e.format(`( ${h} <= ${s} )`,n,o):">"===t&&p>1?e.useComparisonMethod?e.format(`${e.getMethod("greaterThan",o)}( ${h}, ${s} )`,n,o):e.format(`( ${h} > ${s} )`,n,o):">="===t&&p>1?e.useComparisonMethod?e.format(`${e.getMethod("greaterThanEqual",o)}( ${h}, ${s} )`,n,o):e.format(`( ${h} >= ${s} )`,n,o):"!"===t||"~"===t?e.format(`(${t}${h})`,a,o):g?e.format(`${g}( ${h}, ${s} )`,n,o):e.format(`( ${h} ${t} ${s} )`,n,o):"void"!==a?g?e.format(`${g}( ${h}, ${s} )`,n,o):e.format(`${h} ${t} ${s}`,n,o):void 0}serialize(e){super.serialize(e),e.op=this.op}deserialize(e){super.deserialize(e),this.op=e.op}}export default OperatorNode;export const add=nodeProxy(OperatorNode,"+");export const sub=nodeProxy(OperatorNode,"-");export const mul=nodeProxy(OperatorNode,"*");export const div=nodeProxy(OperatorNode,"/");export const modInt=nodeProxy(OperatorNode,"%");export const equal=nodeProxy(OperatorNode,"==");export const notEqual=nodeProxy(OperatorNode,"!=");export const lessThan=nodeProxy(OperatorNode,"<");export const greaterThan=nodeProxy(OperatorNode,">");export const lessThanEqual=nodeProxy(OperatorNode,"<=");export const greaterThanEqual=nodeProxy(OperatorNode,">=");export const and=nodeProxy(OperatorNode,"&&");export const or=nodeProxy(OperatorNode,"||");export const not=nodeProxy(OperatorNode,"!");export const xor=nodeProxy(OperatorNode,"^^");export const bitAnd=nodeProxy(OperatorNode,"&");export const bitNot=nodeProxy(OperatorNode,"~");export const bitOr=nodeProxy(OperatorNode,"|");export const bitXor=nodeProxy(OperatorNode,"^");export const shiftLeft=nodeProxy(OperatorNode,"<<");export const shiftRight=nodeProxy(OperatorNode,">>");addMethodChaining("add",add),addMethodChaining("sub",sub),addMethodChaining("mul",mul),addMethodChaining("div",div),addMethodChaining("modInt",modInt),addMethodChaining("equal",equal),addMethodChaining("notEqual",notEqual),addMethodChaining("lessThan",lessThan),addMethodChaining("greaterThan",greaterThan),addMethodChaining("lessThanEqual",lessThanEqual),addMethodChaining("greaterThanEqual",greaterThanEqual),addMethodChaining("and",and),addMethodChaining("or",or),addMethodChaining("not",not),addMethodChaining("xor",xor),addMethodChaining("bitAnd",bitAnd),addMethodChaining("bitNot",bitNot),addMethodChaining("bitOr",bitOr),addMethodChaining("bitXor",bitXor),addMethodChaining("shiftLeft",shiftLeft),addMethodChaining("shiftRight",shiftRight);export const remainder=(...e)=>(console.warn("TSL.OperatorNode: .remainder() has been renamed to .modInt()."),modInt(...e));addMethodChaining("remainder",remainder);
//# sourceMappingURL=/sm/e1302ef890321a6f0df21b6c9a5ea8e21c84da63774328d730f38775b518ad37.map