/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/nodes/math/MathNode.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import TempNode from"../core/TempNode.js";import{sub,mul,div}from"./OperatorNode.js";import{addMethodChaining,nodeObject,nodeProxy,float,vec2,vec3,vec4,Fn}from"../tsl/TSLCore.js";class MathNode extends TempNode{static get type(){return"MathNode"}constructor(o,e,t=null,d=null){super(),this.method=o,this.aNode=e,this.bNode=t,this.cNode=d}getInputType(o){const e=this.aNode.getNodeType(o),t=this.bNode?this.bNode.getNodeType(o):null,d=this.cNode?this.cNode.getNodeType(o):null,a=o.isMatrix(e)?0:o.getTypeLength(e),n=o.isMatrix(t)?0:o.getTypeLength(t),h=o.isMatrix(d)?0:o.getTypeLength(d);return a>n&&a>h?e:n>h?t:h>a?d:e}getNodeType(o){const e=this.method;return e===MathNode.LENGTH||e===MathNode.DISTANCE||e===MathNode.DOT?"float":e===MathNode.CROSS?"vec3":e===MathNode.ALL?"bool":e===MathNode.EQUALS?o.changeComponentType(this.aNode.getNodeType(o),"bool"):e===MathNode.MOD?this.aNode.getNodeType(o):this.getInputType(o)}generate(o,e){const t=this.method,d=this.getNodeType(o),a=this.getInputType(o),n=this.aNode,h=this.bNode,M=this.cNode,r=!0===o.renderer.isWebGLRenderer;if(t===MathNode.TRANSFORM_DIRECTION){let t=n,d=h;o.isMatrix(t.getNodeType(o))?d=vec4(vec3(d),0):t=vec4(vec3(t),0);const a=mul(t,d).xyz;return normalize(a).build(o,e)}if(t===MathNode.NEGATE)return o.format("( - "+n.build(o,a)+" )",d,e);if(t===MathNode.ONE_MINUS)return sub(1,n).build(o,e);if(t===MathNode.RECIPROCAL)return div(1,n).build(o,e);if(t===MathNode.DIFFERENCE)return abs(sub(n,h)).build(o,e);{const N=[];return t===MathNode.CROSS||t===MathNode.MOD?N.push(n.build(o,d),h.build(o,d)):r&&t===MathNode.STEP?N.push(n.build(o,1===o.getTypeLength(n.getNodeType(o))?"float":a),h.build(o,a)):r&&(t===MathNode.MIN||t===MathNode.MAX)||t===MathNode.MOD?N.push(n.build(o,a),h.build(o,1===o.getTypeLength(h.getNodeType(o))?"float":a)):t===MathNode.REFRACT?N.push(n.build(o,a),h.build(o,a),M.build(o,"float")):t===MathNode.MIX?N.push(n.build(o,a),h.build(o,a),M.build(o,1===o.getTypeLength(M.getNodeType(o))?"float":a)):(N.push(n.build(o,a)),null!==h&&N.push(h.build(o,a)),null!==M&&N.push(M.build(o,a))),o.format(`${o.getMethod(t,d)}( ${N.join(", ")} )`,d,e)}}serialize(o){super.serialize(o),o.method=this.method}deserialize(o){super.deserialize(o),this.method=o.method}}MathNode.ALL="all",MathNode.ANY="any",MathNode.EQUALS="equals",MathNode.RADIANS="radians",MathNode.DEGREES="degrees",MathNode.EXP="exp",MathNode.EXP2="exp2",MathNode.LOG="log",MathNode.LOG2="log2",MathNode.SQRT="sqrt",MathNode.INVERSE_SQRT="inversesqrt",MathNode.FLOOR="floor",MathNode.CEIL="ceil",MathNode.NORMALIZE="normalize",MathNode.FRACT="fract",MathNode.SIN="sin",MathNode.COS="cos",MathNode.TAN="tan",MathNode.ASIN="asin",MathNode.ACOS="acos",MathNode.ATAN="atan",MathNode.ABS="abs",MathNode.SIGN="sign",MathNode.LENGTH="length",MathNode.NEGATE="negate",MathNode.ONE_MINUS="oneMinus",MathNode.DFDX="dFdx",MathNode.DFDY="dFdy",MathNode.ROUND="round",MathNode.RECIPROCAL="reciprocal",MathNode.TRUNC="trunc",MathNode.FWIDTH="fwidth",MathNode.BITCAST="bitcast",MathNode.TRANSPOSE="transpose",MathNode.ATAN2="atan2",MathNode.MIN="min",MathNode.MAX="max",MathNode.MOD="mod",MathNode.STEP="step",MathNode.REFLECT="reflect",MathNode.DISTANCE="distance",MathNode.DIFFERENCE="difference",MathNode.DOT="dot",MathNode.CROSS="cross",MathNode.POW="pow",MathNode.TRANSFORM_DIRECTION="transformDirection",MathNode.MIX="mix",MathNode.CLAMP="clamp",MathNode.REFRACT="refract",MathNode.SMOOTHSTEP="smoothstep",MathNode.FACEFORWARD="faceforward";export default MathNode;export const EPSILON=float(1e-6);export const INFINITY=float(1e6);export const PI=float(Math.PI);export const PI2=float(2*Math.PI);export const all=nodeProxy(MathNode,MathNode.ALL);export const any=nodeProxy(MathNode,MathNode.ANY);export const equals=nodeProxy(MathNode,MathNode.EQUALS);export const radians=nodeProxy(MathNode,MathNode.RADIANS);export const degrees=nodeProxy(MathNode,MathNode.DEGREES);export const exp=nodeProxy(MathNode,MathNode.EXP);export const exp2=nodeProxy(MathNode,MathNode.EXP2);export const log=nodeProxy(MathNode,MathNode.LOG);export const log2=nodeProxy(MathNode,MathNode.LOG2);export const sqrt=nodeProxy(MathNode,MathNode.SQRT);export const inverseSqrt=nodeProxy(MathNode,MathNode.INVERSE_SQRT);export const floor=nodeProxy(MathNode,MathNode.FLOOR);export const ceil=nodeProxy(MathNode,MathNode.CEIL);export const normalize=nodeProxy(MathNode,MathNode.NORMALIZE);export const fract=nodeProxy(MathNode,MathNode.FRACT);export const sin=nodeProxy(MathNode,MathNode.SIN);export const cos=nodeProxy(MathNode,MathNode.COS);export const tan=nodeProxy(MathNode,MathNode.TAN);export const asin=nodeProxy(MathNode,MathNode.ASIN);export const acos=nodeProxy(MathNode,MathNode.ACOS);export const atan=nodeProxy(MathNode,MathNode.ATAN);export const abs=nodeProxy(MathNode,MathNode.ABS);export const sign=nodeProxy(MathNode,MathNode.SIGN);export const length=nodeProxy(MathNode,MathNode.LENGTH);export const negate=nodeProxy(MathNode,MathNode.NEGATE);export const oneMinus=nodeProxy(MathNode,MathNode.ONE_MINUS);export const dFdx=nodeProxy(MathNode,MathNode.DFDX);export const dFdy=nodeProxy(MathNode,MathNode.DFDY);export const round=nodeProxy(MathNode,MathNode.ROUND);export const reciprocal=nodeProxy(MathNode,MathNode.RECIPROCAL);export const trunc=nodeProxy(MathNode,MathNode.TRUNC);export const fwidth=nodeProxy(MathNode,MathNode.FWIDTH);export const bitcast=nodeProxy(MathNode,MathNode.BITCAST);export const transpose=nodeProxy(MathNode,MathNode.TRANSPOSE);export const atan2=nodeProxy(MathNode,MathNode.ATAN2);export const min=nodeProxy(MathNode,MathNode.MIN);export const max=nodeProxy(MathNode,MathNode.MAX);export const mod=nodeProxy(MathNode,MathNode.MOD);export const step=nodeProxy(MathNode,MathNode.STEP);export const reflect=nodeProxy(MathNode,MathNode.REFLECT);export const distance=nodeProxy(MathNode,MathNode.DISTANCE);export const difference=nodeProxy(MathNode,MathNode.DIFFERENCE);export const dot=nodeProxy(MathNode,MathNode.DOT);export const cross=nodeProxy(MathNode,MathNode.CROSS);export const pow=nodeProxy(MathNode,MathNode.POW);export const pow2=nodeProxy(MathNode,MathNode.POW,2);export const pow3=nodeProxy(MathNode,MathNode.POW,3);export const pow4=nodeProxy(MathNode,MathNode.POW,4);export const transformDirection=nodeProxy(MathNode,MathNode.TRANSFORM_DIRECTION);export const cbrt=o=>mul(sign(o),pow(abs(o),1/3));export const lengthSq=o=>dot(o,o);export const mix=nodeProxy(MathNode,MathNode.MIX);export const clamp=(o,e=0,t=1)=>nodeObject(new MathNode(MathNode.CLAMP,nodeObject(o),nodeObject(e),nodeObject(t)));export const saturate=o=>clamp(o);export const refract=nodeProxy(MathNode,MathNode.REFRACT);export const smoothstep=nodeProxy(MathNode,MathNode.SMOOTHSTEP);export const faceForward=nodeProxy(MathNode,MathNode.FACEFORWARD);export const rand=Fn((([o])=>{const e=dot(o.xy,vec2(12.9898,78.233)),t=mod(e,PI);return fract(sin(t).mul(43758.5453))}));export const mixElement=(o,e,t)=>mix(e,t,o);export const smoothstepElement=(o,e,t)=>smoothstep(e,t,o);addMethodChaining("all",all),addMethodChaining("any",any),addMethodChaining("equals",equals),addMethodChaining("radians",radians),addMethodChaining("degrees",degrees),addMethodChaining("exp",exp),addMethodChaining("exp2",exp2),addMethodChaining("log",log),addMethodChaining("log2",log2),addMethodChaining("sqrt",sqrt),addMethodChaining("inverseSqrt",inverseSqrt),addMethodChaining("floor",floor),addMethodChaining("ceil",ceil),addMethodChaining("normalize",normalize),addMethodChaining("fract",fract),addMethodChaining("sin",sin),addMethodChaining("cos",cos),addMethodChaining("tan",tan),addMethodChaining("asin",asin),addMethodChaining("acos",acos),addMethodChaining("atan",atan),addMethodChaining("abs",abs),addMethodChaining("sign",sign),addMethodChaining("length",length),addMethodChaining("lengthSq",lengthSq),addMethodChaining("negate",negate),addMethodChaining("oneMinus",oneMinus),addMethodChaining("dFdx",dFdx),addMethodChaining("dFdy",dFdy),addMethodChaining("round",round),addMethodChaining("reciprocal",reciprocal),addMethodChaining("trunc",trunc),addMethodChaining("fwidth",fwidth),addMethodChaining("atan2",atan2),addMethodChaining("min",min),addMethodChaining("max",max),addMethodChaining("mod",mod),addMethodChaining("step",step),addMethodChaining("reflect",reflect),addMethodChaining("distance",distance),addMethodChaining("dot",dot),addMethodChaining("cross",cross),addMethodChaining("pow",pow),addMethodChaining("pow2",pow2),addMethodChaining("pow3",pow3),addMethodChaining("pow4",pow4),addMethodChaining("transformDirection",transformDirection),addMethodChaining("mix",mixElement),addMethodChaining("clamp",clamp),addMethodChaining("refract",refract),addMethodChaining("smoothstep",smoothstepElement),addMethodChaining("faceForward",faceForward),addMethodChaining("difference",difference),addMethodChaining("saturate",saturate),addMethodChaining("cbrt",cbrt),addMethodChaining("transpose",transpose),addMethodChaining("rand",rand);
//# sourceMappingURL=/sm/2de378da8405688874a71574f9237325c1dd67e19a5a41ce315a8c5aaeff8b3f.map