/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/objects/Sprite.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Vector2}from"../math/Vector2.js";import{Vector3}from"../math/Vector3.js";import{Matrix4}from"../math/Matrix4.js";import{Triangle}from"../math/Triangle.js";import{Object3D}from"../core/Object3D.js";import{BufferGeometry}from"../core/BufferGeometry.js";import{InterleavedBuffer}from"../core/InterleavedBuffer.js";import{InterleavedBufferAttribute}from"../core/InterleavedBufferAttribute.js";import{SpriteMaterial}from"../materials/SpriteMaterial.js";let _geometry;const _intersectPoint=new Vector3,_worldScale=new Vector3,_mvPosition=new Vector3,_alignedPosition=new Vector2,_rotatedPosition=new Vector2,_viewWorldMatrix=new Matrix4,_vA=new Vector3,_vB=new Vector3,_vC=new Vector3,_uvA=new Vector2,_uvB=new Vector2,_uvC=new Vector2;class Sprite extends Object3D{constructor(e=new SpriteMaterial){if(super(),this.isSprite=!0,this.type="Sprite",void 0===_geometry){_geometry=new BufferGeometry;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new InterleavedBuffer(e,5);_geometry.setIndex([0,1,2,0,2,3]),_geometry.setAttribute("position",new InterleavedBufferAttribute(t,3,0,!1)),_geometry.setAttribute("uv",new InterleavedBufferAttribute(t,2,3,!1))}this.geometry=_geometry,this.material=e,this.center=new Vector2(.5,.5)}raycast(e,t){null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),_worldScale.setFromMatrixScale(this.matrixWorld),_viewWorldMatrix.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),_mvPosition.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&_worldScale.multiplyScalar(-_mvPosition.z);const r=this.material.rotation;let o,i;0!==r&&(i=Math.cos(r),o=Math.sin(r));const a=this.center;transformVertex(_vA.set(-.5,-.5,0),_mvPosition,a,_worldScale,o,i),transformVertex(_vB.set(.5,-.5,0),_mvPosition,a,_worldScale,o,i),transformVertex(_vC.set(.5,.5,0),_mvPosition,a,_worldScale,o,i),_uvA.set(0,0),_uvB.set(1,0),_uvC.set(1,1);let n=e.ray.intersectTriangle(_vA,_vB,_vC,!1,_intersectPoint);if(null===n&&(transformVertex(_vB.set(-.5,.5,0),_mvPosition,a,_worldScale,o,i),_uvB.set(0,1),n=e.ray.intersectTriangle(_vA,_vC,_vB,!1,_intersectPoint),null===n))return;const s=e.ray.origin.distanceTo(_intersectPoint);s<e.near||s>e.far||t.push({distance:s,point:_intersectPoint.clone(),uv:Triangle.getInterpolation(_intersectPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2),face:null,object:this})}copy(e,t){return super.copy(e,t),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}}function transformVertex(e,t,r,o,i,a){_alignedPosition.subVectors(e,r).addScalar(.5).multiply(o),void 0!==i?(_rotatedPosition.x=a*_alignedPosition.x-i*_alignedPosition.y,_rotatedPosition.y=i*_alignedPosition.x+a*_alignedPosition.y):_rotatedPosition.copy(_alignedPosition),e.copy(t),e.x+=_rotatedPosition.x,e.y+=_rotatedPosition.y,e.applyMatrix4(_viewWorldMatrix)}export{Sprite};
//# sourceMappingURL=/sm/f9309d76319d3f8345645f04b7bc5874e8350066ba2eb7408f7c151d16dcdb26.map