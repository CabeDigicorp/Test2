/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/geometries/ExtrudeGeometry.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{BufferGeometry}from"../core/BufferGeometry.js";import{Float32BufferAttribute}from"../core/BufferAttribute.js";import*as Curves from"../extras/curves/Curves.js";import{Vector2}from"../math/Vector2.js";import{Vector3}from"../math/Vector3.js";import{Shape}from"../extras/core/Shape.js";import{ShapeUtils}from"../extras/ShapeUtils.js";class ExtrudeGeometry extends BufferGeometry{constructor(t=new Shape([new Vector2(.5,.5),new Vector2(-.5,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const o=this,r=[],n=[];for(let e=0,o=t.length;e<o;e++){s(t[e])}function s(t){const s=[],c=void 0!==e.curveSegments?e.curveSegments:12,l=void 0!==e.steps?e.steps:1,a=void 0!==e.depth?e.depth:1;let i=void 0===e.bevelEnabled||e.bevelEnabled,h=void 0!==e.bevelThickness?e.bevelThickness:.2,u=void 0!==e.bevelSize?e.bevelSize:h-.1,p=void 0!==e.bevelOffset?e.bevelOffset:0,f=void 0!==e.bevelSegments?e.bevelSegments:3;const m=e.extrudePath,d=void 0!==e.UVGenerator?e.UVGenerator:WorldUVGenerator;let y,g,x,S,V,v=!1;m&&(y=m.getSpacedPoints(l),v=!0,i=!1,g=m.computeFrenetFrames(l,!1),x=new Vector3,S=new Vector3,V=new Vector3),i||(f=0,h=0,u=0,p=0);const b=t.extractPoints(c);let w=b.shape;const M=b.holes;if(!ShapeUtils.isClockWise(w)){w=w.reverse();for(let t=0,e=M.length;t<e;t++){const e=M[t];ShapeUtils.isClockWise(e)&&(M[t]=e.reverse())}}const N=ShapeUtils.triangulateShape(w,M),P=w;for(let t=0,e=M.length;t<e;t++){const e=M[t];w=w.concat(e)}function O(t,e,o){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().addScaledVector(e,o)}const E=w.length,G=N.length;function U(t,e,o){let r,n,s;const c=t.x-e.x,l=t.y-e.y,a=o.x-t.x,i=o.y-t.y,h=c*c+l*l,u=c*i-l*a;if(Math.abs(u)>Number.EPSILON){const u=Math.sqrt(h),p=Math.sqrt(a*a+i*i),f=e.x-l/u,m=e.y+c/u,d=((o.x-i/p-f)*i-(o.y+a/p-m)*a)/(c*i-l*a);r=f+c*d-t.x,n=m+l*d-t.y;const y=r*r+n*n;if(y<=2)return new Vector2(r,n);s=Math.sqrt(y/2)}else{let t=!1;c>Number.EPSILON?a>Number.EPSILON&&(t=!0):c<-Number.EPSILON?a<-Number.EPSILON&&(t=!0):Math.sign(l)===Math.sign(i)&&(t=!0),t?(r=-l,n=c,s=Math.sqrt(h)):(r=c,n=l,s=Math.sqrt(h/2))}return new Vector2(r/s,n/s)}const A=[];for(let t=0,e=P.length,o=e-1,r=t+1;t<e;t++,o++,r++)o===e&&(o=0),r===e&&(r=0),A[t]=U(P[t],P[o],P[r]);const j=[];let I,B=A.concat();for(let t=0,e=M.length;t<e;t++){const e=M[t];I=[];for(let t=0,o=e.length,r=o-1,n=t+1;t<o;t++,r++,n++)r===o&&(r=0),n===o&&(n=0),I[t]=U(e[t],e[r],e[n]);j.push(I),B=B.concat(I)}for(let t=0;t<f;t++){const e=t/f,o=h*Math.cos(e*Math.PI/2),r=u*Math.sin(e*Math.PI/2)+p;for(let t=0,e=P.length;t<e;t++){const e=O(P[t],A[t],r);q(e.x,e.y,-o)}for(let t=0,e=M.length;t<e;t++){const e=M[t];I=j[t];for(let t=0,n=e.length;t<n;t++){const n=O(e[t],I[t],r);q(n.x,n.y,-o)}}}const J=u+p;for(let t=0;t<E;t++){const e=i?O(w[t],B[t],J):w[t];v?(S.copy(g.normals[0]).multiplyScalar(e.x),x.copy(g.binormals[0]).multiplyScalar(e.y),V.copy(y[0]).add(S).add(x),q(V.x,V.y,V.z)):q(e.x,e.y,0)}for(let t=1;t<=l;t++)for(let e=0;e<E;e++){const o=i?O(w[e],B[e],J):w[e];v?(S.copy(g.normals[t]).multiplyScalar(o.x),x.copy(g.binormals[t]).multiplyScalar(o.y),V.copy(y[t]).add(S).add(x),q(V.x,V.y,V.z)):q(o.x,o.y,a/l*t)}for(let t=f-1;t>=0;t--){const e=t/f,o=h*Math.cos(e*Math.PI/2),r=u*Math.sin(e*Math.PI/2)+p;for(let t=0,e=P.length;t<e;t++){const e=O(P[t],A[t],r);q(e.x,e.y,a+o)}for(let t=0,e=M.length;t<e;t++){const e=M[t];I=j[t];for(let t=0,n=e.length;t<n;t++){const n=O(e[t],I[t],r);v?q(n.x,n.y+y[l-1].y,y[l-1].x+o):q(n.x,n.y,a+o)}}}function W(t,e){let o=t.length;for(;--o>=0;){const r=o;let n=o-1;n<0&&(n=t.length-1);for(let t=0,o=l+2*f;t<o;t++){const o=E*t,s=E*(t+1);F(e+r+o,e+n+o,e+n+s,e+r+s)}}}function q(t,e,o){s.push(t),s.push(e),s.push(o)}function C(t,e,n){L(t),L(e),L(n);const s=r.length/3,c=d.generateTopUV(o,r,s-3,s-2,s-1);T(c[0]),T(c[1]),T(c[2])}function F(t,e,n,s){L(t),L(e),L(s),L(e),L(n),L(s);const c=r.length/3,l=d.generateSideWallUV(o,r,c-6,c-3,c-2,c-1);T(l[0]),T(l[1]),T(l[3]),T(l[1]),T(l[2]),T(l[3])}function L(t){r.push(s[3*t+0]),r.push(s[3*t+1]),r.push(s[3*t+2])}function T(t){n.push(t.x),n.push(t.y)}!function(){const t=r.length/3;if(i){let t=0,e=E*t;for(let t=0;t<G;t++){const o=N[t];C(o[2]+e,o[1]+e,o[0]+e)}t=l+2*f,e=E*t;for(let t=0;t<G;t++){const o=N[t];C(o[0]+e,o[1]+e,o[2]+e)}}else{for(let t=0;t<G;t++){const e=N[t];C(e[2],e[1],e[0])}for(let t=0;t<G;t++){const e=N[t];C(e[0]+E*l,e[1]+E*l,e[2]+E*l)}}o.addGroup(t,r.length/3-t,0)}(),function(){const t=r.length/3;let e=0;W(P,e),e+=P.length;for(let t=0,o=M.length;t<o;t++){const o=M[t];W(o,e),e+=o.length}o.addGroup(t,r.length/3-t,1)}()}this.setAttribute("position",new Float32BufferAttribute(r,3)),this.setAttribute("uv",new Float32BufferAttribute(n,2)),this.computeVertexNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return toJSON(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const o=[];for(let r=0,n=t.shapes.length;r<n;r++){const n=e[t.shapes[r]];o.push(n)}const r=t.options.extrudePath;return void 0!==r&&(t.options.extrudePath=(new Curves[r.type]).fromJSON(r)),new ExtrudeGeometry(o,t.options)}}const WorldUVGenerator={generateTopUV:function(t,e,o,r,n){const s=e[3*o],c=e[3*o+1],l=e[3*r],a=e[3*r+1],i=e[3*n],h=e[3*n+1];return[new Vector2(s,c),new Vector2(l,a),new Vector2(i,h)]},generateSideWallUV:function(t,e,o,r,n,s){const c=e[3*o],l=e[3*o+1],a=e[3*o+2],i=e[3*r],h=e[3*r+1],u=e[3*r+2],p=e[3*n],f=e[3*n+1],m=e[3*n+2],d=e[3*s],y=e[3*s+1],g=e[3*s+2];return Math.abs(l-h)<Math.abs(c-i)?[new Vector2(c,1-a),new Vector2(i,1-u),new Vector2(p,1-m),new Vector2(d,1-g)]:[new Vector2(l,1-a),new Vector2(h,1-u),new Vector2(f,1-m),new Vector2(y,1-g)]}};function toJSON(t,e,o){if(o.shapes=[],Array.isArray(t))for(let e=0,r=t.length;e<r;e++){const r=t[e];o.shapes.push(r.uuid)}else o.shapes.push(t.uuid);return o.options=Object.assign({},e),void 0!==e.extrudePath&&(o.options.extrudePath=e.extrudePath.toJSON()),o}export{ExtrudeGeometry};
//# sourceMappingURL=/sm/6aa6978bfed42cfcd766c6da00b614ef9ba5ae874ad469fa88ed8e6882107d5d.map