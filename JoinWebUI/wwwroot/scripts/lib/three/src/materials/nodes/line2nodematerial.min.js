/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/materials/nodes/Line2NodeMaterial.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import NodeMaterial from"./NodeMaterial.js";import{varyingProperty}from"../../nodes/core/PropertyNode.js";import{attribute}from"../../nodes/core/AttributeNode.js";import{cameraProjectionMatrix}from"../../nodes/accessors/Camera.js";import{materialColor,materialLineScale,materialLineDashSize,materialLineGapSize,materialLineDashOffset,materialLineWidth}from"../../nodes/accessors/MaterialNode.js";import{modelViewMatrix}from"../../nodes/accessors/ModelNode.js";import{positionGeometry}from"../../nodes/accessors/Position.js";import{mix,smoothstep}from"../../nodes/math/MathNode.js";import{Fn,varying,float,vec2,vec3,vec4,If}from"../../nodes/tsl/TSLBase.js";import{uv}from"../../nodes/accessors/UV.js";import{viewport}from"../../nodes/display/ScreenNode.js";import{dashSize,gapSize}from"../../nodes/core/PropertyNode.js";import{LineDashedMaterial}from"../LineDashedMaterial.js";const _defaultValues=new LineDashedMaterial;class Line2NodeMaterial extends NodeMaterial{static get type(){return"Line2NodeMaterial"}constructor(e={}){super(),this.lights=!1,this.setDefaultValues(_defaultValues),this.useAlphaToCoverage=!0,this.useColor=e.vertexColors,this.useDash=e.dashed,this.useWorldUnits=!1,this.dashOffset=0,this.lineWidth=1,this.lineColorNode=null,this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(e)}setup(e){this.setupShaders(e),super.setup(e)}setupShaders({renderer:e}){const s=this.alphaToCoverage,t=this.useColor,a=this.dashed,i=this.worldUnits,o=Fn((({start:e,end:s})=>{const t=cameraProjectionMatrix.element(2).element(2),a=cameraProjectionMatrix.element(3).element(2).mul(-.5).div(t).sub(e.z).div(s.z.sub(e.z));return vec4(mix(e.xyz,s.xyz,a),s.w)})).setLayout({name:"trimSegment",type:"vec4",inputs:[{name:"start",type:"vec4"},{name:"end",type:"vec4"}]});this.vertexNode=Fn((()=>{const e=attribute("instanceStart"),s=attribute("instanceEnd"),t=vec4(modelViewMatrix.mul(vec4(e,1))).toVar("start"),r=vec4(modelViewMatrix.mul(vec4(s,1))).toVar("end");i&&(varyingProperty("vec3","worldStart").assign(t.xyz),varyingProperty("vec3","worldEnd").assign(r.xyz));const n=viewport.z.div(viewport.w),l=cameraProjectionMatrix.element(2).element(3).equal(-1);If(l,(()=>{If(t.z.lessThan(0).and(r.z.greaterThan(0)),(()=>{r.assign(o({start:t,end:r}))})).ElseIf(r.z.lessThan(0).and(t.z.greaterThanEqual(0)),(()=>{t.assign(o({start:r,end:t}))}))}));const d=cameraProjectionMatrix.mul(t),m=cameraProjectionMatrix.mul(r),h=d.xyz.div(d.w),c=m.xyz.div(m.w),u=c.xy.sub(h.xy).toVar();u.x.assign(u.x.mul(n)),u.assign(u.normalize());const p=vec4().toVar();if(i){const e=r.xyz.sub(t.xyz).normalize(),s=mix(t.xyz,r.xyz,.5).normalize(),i=e.cross(s).normalize(),o=e.cross(i),n=varyingProperty("vec4","worldPos");n.assign(positionGeometry.y.lessThan(.5).select(t,r));const l=materialLineWidth.mul(.5);n.addAssign(vec4(positionGeometry.x.lessThan(0).select(i.mul(l),i.mul(l).negate()),0)),a||(n.addAssign(vec4(positionGeometry.y.lessThan(.5).select(e.mul(l).negate(),e.mul(l)),0)),n.addAssign(vec4(o.mul(l),0)),If(positionGeometry.y.greaterThan(1).or(positionGeometry.y.lessThan(0)),(()=>{n.subAssign(vec4(o.mul(2).mul(l),0))}))),p.assign(cameraProjectionMatrix.mul(n));const d=vec3().toVar();d.assign(positionGeometry.y.lessThan(.5).select(h,c)),p.z.assign(d.z.mul(p.w))}else{const e=vec2(u.y,u.x.negate()).toVar("offset");u.x.assign(u.x.div(n)),e.x.assign(e.x.div(n)),e.assign(positionGeometry.x.lessThan(0).select(e.negate(),e)),If(positionGeometry.y.lessThan(0),(()=>{e.assign(e.sub(u))})).ElseIf(positionGeometry.y.greaterThan(1),(()=>{e.assign(e.add(u))})),e.assign(e.mul(materialLineWidth)),e.assign(e.div(viewport.w)),p.assign(positionGeometry.y.lessThan(.5).select(d,m)),e.assign(e.mul(p.w)),p.assign(p.add(vec4(e,0,0)))}return p}))();const r=Fn((({p1:e,p2:s,p3:t,p4:a})=>{const i=e.sub(t),o=a.sub(t),r=s.sub(e),n=i.dot(o),l=o.dot(r),d=i.dot(r),m=o.dot(o),h=r.dot(r).mul(m).sub(l.mul(l)),c=n.mul(l).sub(d.mul(m)).div(h).clamp(),u=n.add(l.mul(c)).div(m).clamp();return vec2(c,u)}));this.fragmentNode=Fn((()=>{const o=uv();if(a){const e=this.offsetNode?float(this.offsetNodeNode):materialLineDashOffset,s=this.dashScaleNode?float(this.dashScaleNode):materialLineScale,t=this.dashSizeNode?float(this.dashSizeNode):materialLineDashSize,a=this.dashSizeNode?float(this.dashGapNode):materialLineGapSize;dashSize.assign(t),gapSize.assign(a);const i=attribute("instanceDistanceStart"),r=attribute("instanceDistanceEnd"),n=positionGeometry.y.lessThan(.5).select(s.mul(i),materialLineScale.mul(r)),l=varying(n.add(materialLineDashOffset)),d=e?l.add(e):l;o.y.lessThan(-1).or(o.y.greaterThan(1)).discard(),d.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard()}const n=float(1).toVar("alpha");if(i){const t=varyingProperty("vec3","worldStart"),i=varyingProperty("vec3","worldEnd"),o=varyingProperty("vec4","worldPos").xyz.normalize().mul(1e5),l=i.sub(t),d=r({p1:t,p2:i,p3:vec3(0,0,0),p4:o}),m=t.add(l.mul(d.x)),h=o.mul(d.y),c=m.sub(h).length().div(materialLineWidth);if(!a)if(s&&e.samples>1){const e=c.fwidth();n.assign(smoothstep(e.negate().add(.5),e.add(.5),c).oneMinus())}else c.greaterThan(.5).discard()}else if(s&&e.samples>1){const e=o.x,s=o.y.greaterThan(0).select(o.y.sub(1),o.y.add(1)),t=e.mul(e).add(s.mul(s)),a=float(t.fwidth()).toVar("dlen");If(o.y.abs().greaterThan(1),(()=>{n.assign(smoothstep(a.oneMinus(),a.add(1),t).oneMinus())}))}else If(o.y.abs().greaterThan(1),(()=>{const e=o.x,s=o.y.greaterThan(0).select(o.y.sub(1),o.y.add(1));e.mul(e).add(s.mul(s)).greaterThan(1).discard()}));let l;if(this.lineColorNode)l=this.lineColorNode;else if(t){const e=attribute("instanceColorStart"),s=attribute("instanceColorEnd");l=positionGeometry.y.lessThan(.5).select(e,s).mul(materialColor)}else l=materialColor;return vec4(l,n)}))()}get worldUnits(){return this.useWorldUnits}set worldUnits(e){this.useWorldUnits!==e&&(this.useWorldUnits=e,this.needsUpdate=!0)}get dashed(){return this.useDash}set dashed(e){this.useDash!==e&&(this.useDash=e,this.needsUpdate=!0)}get alphaToCoverage(){return this.useAlphaToCoverage}set alphaToCoverage(e){this.useAlphaToCoverage!==e&&(this.useAlphaToCoverage=e,this.needsUpdate=!0)}}export default Line2NodeMaterial;
//# sourceMappingURL=/sm/a9520424837b67fc4e2cbbb7c15cec8e6c64125c93e70c3f030ce1cf3665cd7e.map