/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/three@0.170.0/src/materials/nodes/NodeMaterial.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Material}from"../Material.js";import{NormalBlending}from"../../constants.js";import{getNodeChildren,getCacheKey}from"../../nodes/core/NodeUtils.js";import{attribute}from"../../nodes/core/AttributeNode.js";import{output,diffuseColor,emissive,varyingProperty}from"../../nodes/core/PropertyNode.js";import{materialAlphaTest,materialColor,materialOpacity,materialEmissive,materialNormal,materialLightMap,materialAOMap}from"../../nodes/accessors/MaterialNode.js";import{modelViewProjection}from"../../nodes/accessors/ModelViewProjectionNode.js";import{normalLocal}from"../../nodes/accessors/Normal.js";import{instance}from"../../nodes/accessors/InstanceNode.js";import{batch}from"../../nodes/accessors/BatchNode.js";import{materialReference}from"../../nodes/accessors/MaterialReferenceNode.js";import{positionLocal,positionView}from"../../nodes/accessors/Position.js";import{skinningReference}from"../../nodes/accessors/SkinningNode.js";import{morphReference}from"../../nodes/accessors/MorphNode.js";import{mix}from"../../nodes/math/MathNode.js";import{float,vec3,vec4}from"../../nodes/tsl/TSLBase.js";import AONode from"../../nodes/lighting/AONode.js";import{lightingContext}from"../../nodes/lighting/LightingContextNode.js";import IrradianceNode from"../../nodes/lighting/IrradianceNode.js";import{depth,perspectiveDepthToLogarithmicDepth,viewZToOrthographicDepth}from"../../nodes/display/ViewportDepthNode.js";import{cameraFar,cameraNear}from"../../nodes/accessors/Camera.js";import{clipping,clippingAlpha}from"../../nodes/accessors/ClippingNode.js";import NodeMaterialObserver from"./manager/NodeMaterialObserver.js";import getAlphaHashThreshold from"../../nodes/functions/material/getAlphaHashThreshold.js";class NodeMaterial extends Material{static get type(){return"NodeMaterial"}constructor(){super(),this.isNodeMaterial=!0,this.type=this.constructor.type,this.forceSinglePass=!1,this.fog=!0,this.lights=!1,this.lightsNode=null,this.envNode=null,this.aoNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null,this.geometryNode=null,this.depthNode=null,this.shadowNode=null,this.shadowPositionNode=null,this.outputNode=null,this.mrtNode=null,this.fragmentNode=null,this.vertexNode=null}customProgramCacheKey(){return this.type+getCacheKey(this)}build(e){this.setup(e)}setupObserver(e){return new NodeMaterialObserver(e)}setup(e){let t;e.context.setupNormal=()=>this.setupNormal(e),e.addStack(),e.stack.outputNode=this.vertexNode||this.setupPosition(e),null!==this.geometryNode&&(e.stack.outputNode=e.stack.outputNode.bypass(this.geometryNode)),e.addFlow("vertex",e.removeStack()),e.addStack();const o=this.setupClipping(e);if(!0===this.depthWrite&&this.setupDepth(e),null===this.fragmentNode){this.setupDiffuseColor(e),this.setupVariants(e);const s=this.setupLighting(e);null!==o&&e.stack.add(o);const i=vec4(s,diffuseColor.a).max(0);t=this.setupOutput(e,i),output.assign(t),null!==this.outputNode&&(t=this.outputNode);if(null!==e.renderer.getRenderTarget()){const o=e.renderer.getMRT(),s=this.mrtNode;null!==o?(t=o,null!==s&&(t=o.merge(s))):null!==s&&(t=s)}}else{let o=this.fragmentNode;!0!==o.isOutputStructNode&&(o=vec4(o)),t=this.setupOutput(e,o)}e.stack.outputNode=t,e.addFlow("fragment",e.removeStack()),e.monitor=this.setupObserver(e)}setupClipping(e){if(null===e.clippingContext)return null;const{globalClippingCount:t,localClippingCount:o}=e.clippingContext;let s=null;if(t||o){const t=e.renderer.samples;this.alphaToCoverage&&t>1?s=clippingAlpha():e.stack.add(clipping())}return s}setupDepth(e){const{renderer:t,camera:o}=e;let s=this.depthNode;if(null===s){const e=t.getMRT();e&&e.has("depth")?s=e.get("depth"):!0===t.logarithmicDepthBuffer&&(s=o.isPerspectiveCamera?perspectiveDepthToLogarithmicDepth(modelViewProjection().w,cameraNear,cameraFar):viewZToOrthographicDepth(positionView.z,cameraNear,cameraFar))}null!==s&&depth.assign(s).append()}setupPosition(e){const{object:t}=e,o=t.geometry;if(e.addStack(),(o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color)&&morphReference(t).append(),!0===t.isSkinnedMesh&&skinningReference(t).append(),this.displacementMap){const e=materialReference("displacementMap","texture"),t=materialReference("displacementScale","float"),o=materialReference("displacementBias","float");positionLocal.addAssign(normalLocal.normalize().mul(e.x.mul(t).add(o)))}t.isBatchedMesh&&batch(t).append(),t.instanceMatrix&&!0===t.instanceMatrix.isInstancedBufferAttribute&&instance(t).append(),null!==this.positionNode&&positionLocal.assign(this.positionNode);const s=modelViewProjection();return e.context.vertex=e.removeStack(),e.context.mvp=s,s}setupDiffuseColor({object:e,geometry:t}){let o=this.colorNode?vec4(this.colorNode):materialColor;if(!0===this.vertexColors&&t.hasAttribute("color")&&(o=vec4(o.xyz.mul(attribute("color","vec3")),o.a)),e.instanceColor){o=varyingProperty("vec3","vInstanceColor").mul(o)}if(e.isBatchedMesh&&e._colorsTexture){o=varyingProperty("vec3","vBatchColor").mul(o)}diffuseColor.assign(o);const s=this.opacityNode?float(this.opacityNode):materialOpacity;if(diffuseColor.a.assign(diffuseColor.a.mul(s)),null!==this.alphaTestNode||this.alphaTest>0){const e=null!==this.alphaTestNode?float(this.alphaTestNode):materialAlphaTest;diffuseColor.a.lessThanEqual(e).discard()}!0===this.alphaHash&&diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal)).discard(),!1===this.transparent&&this.blending===NormalBlending&&!1===this.alphaToCoverage&&diffuseColor.a.assign(1)}setupVariants(){}setupOutgoingLight(){return!0===this.lights?vec3(0):diffuseColor.rgb}setupNormal(){return this.normalNode?vec3(this.normalNode):materialNormal}setupEnvironment(){let e=null;return this.envNode?e=this.envNode:this.envMap&&(e=this.envMap.isCubeTexture?materialReference("envMap","cubeTexture"):materialReference("envMap","texture")),e}setupLightMap(e){let t=null;return e.material.lightMap&&(t=new IrradianceNode(materialLightMap)),t}setupLights(e){const t=[],o=this.setupEnvironment(e);o&&o.isLightingNode&&t.push(o);const s=this.setupLightMap(e);if(s&&s.isLightingNode&&t.push(s),null!==this.aoNode||e.material.aoMap){const e=null!==this.aoNode?this.aoNode:materialAOMap;t.push(new AONode(e))}let i=this.lightsNode||e.lightsNode;return t.length>0&&(i=e.renderer.lighting.createNode([...i.getLights(),...t])),i}setupLightingModel(){}setupLighting(e){const{material:t}=e,{backdropNode:o,backdropAlphaNode:s,emissiveNode:i}=this,r=!0===this.lights||null!==this.lightsNode?this.setupLights(e):null;let a=this.setupOutgoingLight(e);if(r&&r.getScope().hasLights){const t=this.setupLightingModel(e);a=lightingContext(r,t,o,s)}else null!==o&&(a=vec3(null!==s?mix(a,o,s):o));return(i&&!0===i.isNode||t.emissive&&!0===t.emissive.isColor)&&(emissive.assign(vec3(i||materialEmissive)),a=a.add(emissive)),a}setupOutput(e,t){if(!0===this.fog){const o=e.fogNode;o&&(t=vec4(o.mix(t.rgb,o.colorNode),t.a))}return t}setDefaultValues(e){for(const t in e){const o=e[t];void 0===this[t]&&(this[t]=o,o&&o.clone&&(this[t]=o.clone()))}const t=Object.getOwnPropertyDescriptors(e.constructor.prototype);for(const e in t)void 0===Object.getOwnPropertyDescriptor(this.constructor.prototype,e)&&void 0!==t[e].get&&Object.defineProperty(this.constructor.prototype,e,t[e])}toJSON(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{},nodes:{}});const o=Material.prototype.toJSON.call(this,e),s=getNodeChildren(this);o.inputNodes={};for(const{property:t,childNode:i}of s)o.inputNodes[t]=i.toJSON(e).uuid;function i(e){const t=[];for(const o in e){const s=e[o];delete s.metadata,t.push(s)}return t}if(t){const t=i(e.textures),s=i(e.images),r=i(e.nodes);t.length>0&&(o.textures=t),s.length>0&&(o.images=s),r.length>0&&(o.nodes=r)}return o}copy(e){return this.lightsNode=e.lightsNode,this.envNode=e.envNode,this.colorNode=e.colorNode,this.normalNode=e.normalNode,this.opacityNode=e.opacityNode,this.backdropNode=e.backdropNode,this.backdropAlphaNode=e.backdropAlphaNode,this.alphaTestNode=e.alphaTestNode,this.positionNode=e.positionNode,this.geometryNode=e.geometryNode,this.depthNode=e.depthNode,this.shadowNode=e.shadowNode,this.shadowPositionNode=e.shadowPositionNode,this.outputNode=e.outputNode,this.mrtNode=e.mrtNode,this.fragmentNode=e.fragmentNode,this.vertexNode=e.vertexNode,super.copy(e)}}export default NodeMaterial;
//# sourceMappingURL=/sm/e510158b2c4bea1002f7dc20413feae0ed95df1f057673306dd28835c0982da7.map