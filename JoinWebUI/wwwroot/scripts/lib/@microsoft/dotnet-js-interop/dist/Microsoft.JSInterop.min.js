/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@microsoft/dotnet-js-interop@8.0.0/dist/Microsoft.JSInterop.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
export var DotNet;!function(e){const t=[],n="__jsObjectId",r="__dotNetObject",o="__byte[]",s="__dotNetStream",i="__jsStreamReferenceLength";let c,a;class h{constructor(e){this._jsObject=e,this._cachedFunctions=new Map}findFunction(e){const t=this._cachedFunctions.get(e);if(t)return t;let n,r=this._jsObject;if(e.split(".").forEach((t=>{if(!(t in r))throw new Error(`Could not find '${e}' ('${t}' was undefined).`);n=r,r=r[t]})),r instanceof Function)return r=r.bind(n),this._cachedFunctions.set(e,r),r;throw new Error(`The value '${e}' is not a function.`)}getWrappedObject(){return this._jsObject}}const l={0:new h(window)};l[0]._cachedFunctions.set("import",(e=>("string"==typeof e&&e.startsWith("./")&&(e=new URL(e.substr(2),document.baseURI).toString()),import(e))));let u,d=1;function f(e){t.push(e)}function p(e){if(e&&"object"==typeof e){l[d]=new h(e);const t={[n]:d};return d++,t}throw new Error(`Cannot create a JSObjectReference from the value '${e}'.`)}function S(e){let t=-1;if(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),e instanceof Blob)t=e.size;else{if(!(e.buffer instanceof ArrayBuffer))throw new Error("Supplied value is not a typed array or blob.");if(void 0===e.byteLength)throw new Error(`Cannot create a JSStreamReference from the value '${e}' as it doesn't have a byteLength.`);t=e.byteLength}const r={[i]:t};try{const t=p(e);r[n]=t[n]}catch(t){throw new Error(`Cannot create a JSStreamReference from the value '${e}'.`)}return r}function y(e,n){a=e;const r=n?JSON.parse(n,((e,n)=>t.reduce(((t,n)=>n(e,t)),n))):null;return a=void 0,r}function m(){if(void 0===c)throw new Error("No call dispatcher has been set.");if(null===c)throw new Error("There are multiple .NET runtimes present, so a default dispatcher could not be resolved. Use DotNetObject to invoke .NET instance methods.");return c}e.attachDispatcher=function(e){const t=new w(e);return void 0===c?c=t:c&&(c=null),t},e.attachReviver=f,e.invokeMethod=function(e,t,...n){return m().invokeDotNetStaticMethod(e,t,...n)},e.invokeMethodAsync=function(e,t,...n){return m().invokeDotNetStaticMethodAsync(e,t,...n)},e.createJSObjectReference=p,e.createJSStreamReference=S,e.disposeJSObjectReference=function(e){const t=e&&e[n];"number"==typeof t&&_(t)},function(e){e[e.Default=0]="Default",e[e.JSObjectReference=1]="JSObjectReference",e[e.JSStreamReference=2]="JSStreamReference",e[e.JSVoidResult=3]="JSVoidResult"}(u=e.JSCallResultType||(e.JSCallResultType={}));class w{constructor(e){this._dotNetCallDispatcher=e,this._byteArraysToBeRevived=new Map,this._pendingDotNetToJSStreams=new Map,this._pendingAsyncCalls={},this._nextAsyncCallId=1}getDotNetCallDispatcher(){return this._dotNetCallDispatcher}invokeJSFromDotNet(e,t,n,r){const o=y(this,t),s=g(v(e,r)(...o||[]),n);return null==s?null:j(this,s)}beginInvokeJSFromDotNet(e,t,n,r,o){const s=new Promise((e=>{const r=y(this,n);e(v(t,o)(...r||[]))}));e&&s.then((t=>j(this,[e,!0,g(t,r)]))).then((t=>this._dotNetCallDispatcher.endInvokeJSFromDotNet(e,!0,t)),(t=>this._dotNetCallDispatcher.endInvokeJSFromDotNet(e,!1,JSON.stringify([e,!1,D(t)]))))}endInvokeDotNetFromJS(e,t,n){const r=t?y(this,n):new Error(n);this.completePendingCall(parseInt(e,10),t,r)}invokeDotNetStaticMethod(e,t,...n){return this.invokeDotNetMethod(e,t,null,n)}invokeDotNetStaticMethodAsync(e,t,...n){return this.invokeDotNetMethodAsync(e,t,null,n)}invokeDotNetMethod(e,t,n,r){if(this._dotNetCallDispatcher.invokeDotNetFromJS){const o=j(this,r),s=this._dotNetCallDispatcher.invokeDotNetFromJS(e,t,n,o);return s?y(this,s):null}throw new Error("The current dispatcher does not support synchronous calls from JS to .NET. Use invokeDotNetMethodAsync instead.")}invokeDotNetMethodAsync(e,t,n,r){if(e&&n)throw new Error(`For instance method calls, assemblyName should be null. Received '${e}'.`);const o=this._nextAsyncCallId++,s=new Promise(((e,t)=>{this._pendingAsyncCalls[o]={resolve:e,reject:t}}));try{const s=j(this,r);this._dotNetCallDispatcher.beginInvokeDotNetFromJS(o,e,t,n,s)}catch(e){this.completePendingCall(o,!1,e)}return s}receiveByteArray(e,t){this._byteArraysToBeRevived.set(e,t)}processByteArray(e){const t=this._byteArraysToBeRevived.get(e);return t?(this._byteArraysToBeRevived.delete(e),t):null}supplyDotNetStream(e,t){if(this._pendingDotNetToJSStreams.has(e)){const n=this._pendingDotNetToJSStreams.get(e);this._pendingDotNetToJSStreams.delete(e),n.resolve(t)}else{const n=new J;n.resolve(t),this._pendingDotNetToJSStreams.set(e,n)}}getDotNetStreamPromise(e){let t;if(this._pendingDotNetToJSStreams.has(e))t=this._pendingDotNetToJSStreams.get(e).streamPromise,this._pendingDotNetToJSStreams.delete(e);else{const n=new J;this._pendingDotNetToJSStreams.set(e,n),t=n.streamPromise}return t}completePendingCall(e,t,n){if(!this._pendingAsyncCalls.hasOwnProperty(e))throw new Error(`There is no pending async call with ID ${e}.`);const r=this._pendingAsyncCalls[e];delete this._pendingAsyncCalls[e],t?r.resolve(n):r.reject(n)}}function D(e){return e instanceof Error?`${e.message}\n${e.stack}`:e?e.toString():"null"}function v(e,t){const n=l[t];if(n)return n.findFunction(e);throw new Error(`JS object instance with ID ${t} does not exist (has it been disposed?).`)}function _(e){delete l[e]}e.findJSFunction=v,e.disposeJSObjectReferenceById=_;class N{constructor(e,t){this._id=e,this._callDispatcher=t}invokeMethod(e,...t){return this._callDispatcher.invokeDotNetMethod(null,e,this._id,t)}invokeMethodAsync(e,...t){return this._callDispatcher.invokeDotNetMethodAsync(null,e,this._id,t)}dispose(){this._callDispatcher.invokeDotNetMethodAsync(null,"__Dispose",this._id,null).catch((e=>console.error(e)))}serializeAsArg(){return{[r]:this._id}}}e.DotNetObject=N,f((function(e,t){if(t&&"object"==typeof t){if(t.hasOwnProperty(r))return new N(t[r],a);if(t.hasOwnProperty(n)){const e=t[n],r=l[e];if(r)return r.getWrappedObject();throw new Error(`JS object instance with Id '${e}' does not exist. It may have been disposed.`)}if(t.hasOwnProperty(o)){const e=t[o],n=a.processByteArray(e);if(void 0===n)throw new Error(`Byte array index '${e}' does not exist.`);return n}if(t.hasOwnProperty(s)){const e=t[s],n=a.getDotNetStreamPromise(e);return new b(n)}}return t}));class b{constructor(e){this._streamPromise=e}stream(){return this._streamPromise}async arrayBuffer(){return new Response(await this.stream()).arrayBuffer()}}class J{constructor(){this.streamPromise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}}function g(e,t){switch(t){case u.Default:return e;case u.JSObjectReference:return p(e);case u.JSStreamReference:return S(e);case u.JSVoidResult:return null;default:throw new Error(`Invalid JS call result type '${t}'.`)}}let A=0;function j(e,t){A=0,a=e;const n=JSON.stringify(t,R);return a=void 0,n}function R(e,t){if(t instanceof N)return t.serializeAsArg();if(t instanceof Uint8Array){a.getDotNetCallDispatcher().sendByteArray(A,t);const e={[o]:A};return A++,e}return t}}(DotNet||(DotNet={}));
//# sourceMappingURL=/sm/8b2b424951e7e2803c360f4b66c49434b4a91f3f78a291795ff55057aca2f1a3.map